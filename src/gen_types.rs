use crate::bot::Part;
use anyhow::{anyhow, Result};
use reqwest::multipart::Form;
use serde::{Deserialize, Serialize};
use std::borrow::Cow;
use std::default::Default;
use std::fmt;
trait TraitLoginUrl {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (url, forward_text, bot_username, request_write_access)"]
    fn into_tuple(self) -> (String, Option<String>, Option<String>, Option<bool>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."]
    fn get_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."]
    fn get_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."]
    fn set_url<'a>(&'a mut self, url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New text of the button in forwarded messages."]
    fn get_forward_text<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New text of the button in forwarded messages."]
    fn get_forward_text_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New text of the button in forwarded messages."]
    fn set_forward_text<'a>(&'a mut self, forward_text: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."]
    fn get_bot_username<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."]
    fn get_bot_username_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."]
    fn set_bot_username<'a>(&'a mut self, bot_username: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request the permission for your bot to send messages to the user."]
    fn get_request_write_access<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request the permission for your bot to send messages to the user."]
    fn get_request_write_access_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request the permission for your bot to send messages to the user."]
    fn set_request_write_access<'a>(
        &'a mut self,
        request_write_access: Option<bool>,
    ) -> &'a mut Self;
}
trait TraitBotCommandScopeChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, chat_id)"]
    fn into_tuple(self) -> (String, ::ordered_float::OrderedFloat<f64>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn set_chat_id<'a>(&'a mut self, chat_id: ::ordered_float::OrderedFloat<f64>) -> &'a mut Self;
}
trait TraitChatPermissions {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, can_send_voice_notes, can_send_polls, can_send_other_messages, can_add_web_page_previews, can_change_info, can_invite_users, can_pin_messages, can_manage_topics)"]
    fn into_tuple(
        self,
    ) -> (
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    fn get_can_send_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    fn get_can_send_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    fn set_can_send_messages<'a>(&'a mut self, can_send_messages: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send audios"]
    fn get_can_send_audios<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send audios"]
    fn get_can_send_audios_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send audios"]
    fn set_can_send_audios<'a>(&'a mut self, can_send_audios: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send documents"]
    fn get_can_send_documents<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send documents"]
    fn get_can_send_documents_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send documents"]
    fn set_can_send_documents<'a>(&'a mut self, can_send_documents: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send photos"]
    fn get_can_send_photos<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send photos"]
    fn get_can_send_photos_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send photos"]
    fn set_can_send_photos<'a>(&'a mut self, can_send_photos: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send videos"]
    fn get_can_send_videos<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send videos"]
    fn get_can_send_videos_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send videos"]
    fn set_can_send_videos<'a>(&'a mut self, can_send_videos: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send video notes"]
    fn get_can_send_video_notes<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send video notes"]
    fn get_can_send_video_notes_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send video notes"]
    fn set_can_send_video_notes<'a>(
        &'a mut self,
        can_send_video_notes: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send voice notes"]
    fn get_can_send_voice_notes<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send voice notes"]
    fn get_can_send_voice_notes_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send voice notes"]
    fn set_can_send_voice_notes<'a>(
        &'a mut self,
        can_send_voice_notes: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send polls"]
    fn get_can_send_polls<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send polls"]
    fn get_can_send_polls_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send polls"]
    fn set_can_send_polls<'a>(&'a mut self, can_send_polls: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"]
    fn get_can_send_other_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"]
    fn get_can_send_other_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"]
    fn set_can_send_other_messages<'a>(
        &'a mut self,
        can_send_other_messages: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to add web page previews to their messages"]
    fn get_can_add_web_page_previews<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to add web page previews to their messages"]
    fn get_can_add_web_page_previews_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to add web page previews to their messages"]
    fn set_can_add_web_page_previews<'a>(
        &'a mut self,
        can_add_web_page_previews: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"]
    fn get_can_change_info<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"]
    fn get_can_change_info_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"]
    fn set_can_change_info<'a>(&'a mut self, can_change_info: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to invite new users to the chat"]
    fn set_can_invite_users<'a>(&'a mut self, can_invite_users: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"]
    fn get_can_pin_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"]
    fn get_can_pin_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"]
    fn set_can_pin_messages<'a>(&'a mut self, can_pin_messages: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"]
    fn get_can_manage_topics<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"]
    fn get_can_manage_topics_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"]
    fn set_can_manage_topics<'a>(&'a mut self, can_manage_topics: Option<bool>) -> &'a mut Self;
}
trait TraitAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, duration, performer, title, file_name, mime_type, file_size, thumbnail)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        i64,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<i64>,
        Option<PhotoSize>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    fn get_duration<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    fn get_duration_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio as defined by sender or by audio tags"]
    fn get_performer<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio as defined by sender or by audio tags"]
    fn get_performer_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio as defined by sender or by audio tags"]
    fn set_performer<'a>(&'a mut self, performer: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio as defined by sender or by audio tags"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio as defined by sender or by audio tags"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio as defined by sender or by audio tags"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    fn get_file_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    fn get_file_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    fn set_file_name<'a>(&'a mut self, file_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn get_mime_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn get_mime_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn set_mime_type<'a>(&'a mut self, mime_type: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the album cover to which the music file belongs"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the album cover to which the music file belongs"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&PhotoSize>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the album cover to which the music file belongs"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self;
}
trait TraitInputContactMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (phone_number, first_name, last_name, vcard)"]
    fn into_tuple(self) -> (String, String, Option<String>, Option<String>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn get_phone_number<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn get_phone_number_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn set_phone_number<'a>(&'a mut self, phone_number: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn get_first_name<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn get_first_name_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn set_first_name<'a>(&'a mut self, first_name: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn get_last_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn get_vcard<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn get_vcard_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn set_vcard<'a>(&'a mut self, vcard: Option<String>) -> &'a mut Self;
}
trait TraitInputMediaPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, caption, parse_mode, caption_entities, has_spoiler)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media_ref<'a>(&'a self) -> &Option<InputFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    fn get_has_spoiler<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    fn get_has_spoiler_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    fn set_has_spoiler<'a>(&'a mut self, has_spoiler: Option<bool>) -> &'a mut Self;
}
trait TraitOrderInfo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (name, phone_number, email, shipping_address)"]
    fn into_tuple(
        self,
    ) -> (
        Option<String>,
        Option<String>,
        Option<String>,
        Option<ShippingAddress>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User name"]
    fn get_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User name"]
    fn get_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User name"]
    fn set_name<'a>(&'a mut self, name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's phone number"]
    fn get_phone_number<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's phone number"]
    fn get_phone_number_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's phone number"]
    fn set_phone_number<'a>(&'a mut self, phone_number: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User email"]
    fn get_email<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User email"]
    fn get_email_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User email"]
    fn set_email<'a>(&'a mut self, email: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User shipping address"]
    fn get_shipping_address<'a>(&'a self) -> Option<Cow<'a, ShippingAddress>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User shipping address"]
    fn get_shipping_address_ref<'a>(&'a self) -> Option<&ShippingAddress>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User shipping address"]
    fn set_shipping_address<'a>(
        &'a mut self,
        shipping_address: Option<ShippingAddress>,
    ) -> &'a mut Self;
}
trait TraitForumTopic {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_thread_id, name, icon_color, icon_custom_emoji_id)"]
    fn into_tuple(self) -> (i64, String, i64, Option<String>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the forum topic"]
    fn get_message_thread_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the forum topic"]
    fn get_message_thread_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the forum topic"]
    fn set_message_thread_id<'a>(&'a mut self, message_thread_id: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    fn get_name<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    fn get_name_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    fn set_name<'a>(&'a mut self, name: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    fn get_icon_color<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    fn get_icon_color_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    fn set_icon_color<'a>(&'a mut self, icon_color: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    fn get_icon_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    fn get_icon_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    fn set_icon_custom_emoji_id<'a>(
        &'a mut self,
        icon_custom_emoji_id: Option<String>,
    ) -> &'a mut Self;
}
trait TraitWriteAccessAllowed {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (from_request, web_app_name, from_attachment_menu)"]
    fn into_tuple(self) -> (Option<bool>, Option<String>, Option<bool>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"]
    fn get_from_request<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"]
    fn get_from_request_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"]
    fn set_from_request<'a>(&'a mut self, from_request: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"]
    fn get_web_app_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"]
    fn get_web_app_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"]
    fn set_web_app_name<'a>(&'a mut self, web_app_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted when the bot was added to the attachment or side menu"]
    fn get_from_attachment_menu<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted when the bot was added to the attachment or side menu"]
    fn get_from_attachment_menu_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted when the bot was added to the attachment or side menu"]
    fn set_from_attachment_menu<'a>(
        &'a mut self,
        from_attachment_menu: Option<bool>,
    ) -> &'a mut Self;
}
trait TraitBotCommandScope:
    TraitBotCommandScopeDefault
    + TraitBotCommandScopeAllPrivateChats
    + TraitBotCommandScopeAllGroupChats
    + TraitBotCommandScopeAllChatAdministrators
    + TraitBotCommandScopeChat
    + TraitBotCommandScopeChatAdministrators
    + TraitBotCommandScopeChatMember
{
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitInputMediaAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, duration, performer, title)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<String>,
        Option<String>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media_ref<'a>(&'a self) -> &Option<InputFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&InputFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    fn get_duration<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    fn get_duration_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    fn set_duration<'a>(&'a mut self, duration: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    fn get_performer<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    fn get_performer_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    fn set_performer<'a>(&'a mut self, performer: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self;
}
trait TraitInputMedia:
    TraitInputMediaAnimation
    + TraitInputMediaDocument
    + TraitInputMediaAudio
    + TraitInputMediaPhoto
    + TraitInputMediaVideo
{
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitChosenInlineResult {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (result_id, from, location, inline_message_id, query)"]
    fn into_tuple(self) -> (String, User, Option<Location>, Option<String>, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    fn get_result_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    fn get_result_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    fn set_result_id<'a>(&'a mut self, result_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The user that chose the result"]
    fn get_from<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The user that chose the result"]
    fn get_from_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The user that chose the result"]
    fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    fn get_location<'a>(&'a self) -> Option<Cow<'a, Location>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    fn get_location_ref<'a>(&'a self) -> Option<&Location>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    fn set_location<'a>(&'a mut self, location: Option<Location>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    fn get_inline_message_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    fn get_inline_message_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    fn set_inline_message_id<'a>(&'a mut self, inline_message_id: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    fn get_query<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    fn get_query_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    fn set_query<'a>(&'a mut self, query: String) -> &'a mut Self;
}
trait TraitGeneralForumTopicUnhidden {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitCallbackQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, from, message, inline_message_id, chat_instance, data, game_short_name)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        User,
        Option<Message>,
        Option<String>,
        String,
        Option<String>,
        Option<String>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    fn get_from<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    fn get_from_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    fn get_message<'a>(&'a self) -> Option<Cow<'a, Message>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    fn get_message_ref<'a>(&'a self) -> Option<&Message>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    fn set_message<'a>(&'a mut self, message: Option<Message>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."]
    fn get_inline_message_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."]
    fn get_inline_message_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."]
    fn set_inline_message_id<'a>(&'a mut self, inline_message_id: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    fn get_chat_instance<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    fn get_chat_instance_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    fn set_chat_instance<'a>(&'a mut self, chat_instance: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    fn get_data<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    fn get_data_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    fn set_data<'a>(&'a mut self, data: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    fn get_game_short_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    fn get_game_short_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    fn set_game_short_name<'a>(&'a mut self, game_short_name: Option<String>) -> &'a mut Self;
}
trait TraitChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, type, title, username, first_name, last_name, is_forum, photo, active_usernames, emoji_status_custom_emoji_id, emoji_status_expiration_date, bio, has_private_forwards, has_restricted_voice_and_video_messages, join_to_send_messages, join_by_request, description, invite_link, pinned_message, permissions, slow_mode_delay, message_auto_delete_time, has_aggressive_anti_spam_enabled, has_hidden_members, has_protected_content, sticker_set_name, can_set_sticker_set, linked_chat_id, location)"]
    fn into_tuple(
        self,
    ) -> (
        i64,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<bool>,
        Option<ChatPhoto>,
        Option<Vec<String>>,
        Option<String>,
        Option<i64>,
        Option<String>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<String>,
        Option<String>,
        Option<Message>,
        Option<ChatPermissions>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<String>,
        Option<bool>,
        Option<i64>,
        Option<ChatLocation>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn set_id<'a>(&'a mut self, id: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of chat, can be either \"private\", \"group\", \"supergroup\" or \"channel\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of chat, can be either \"private\", \"group\", \"supergroup\" or \"channel\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of chat, can be either \"private\", \"group\", \"supergroup\" or \"channel\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title, for supergroups, channels and group chats"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title, for supergroups, channels and group chats"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title, for supergroups, channels and group chats"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username, for private chats, supergroups and channels if available"]
    fn get_username<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username, for private chats, supergroups and channels if available"]
    fn get_username_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username, for private chats, supergroups and channels if available"]
    fn set_username<'a>(&'a mut self, username: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. First name of the other party in a private chat"]
    fn get_first_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. First name of the other party in a private chat"]
    fn get_first_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. First name of the other party in a private chat"]
    fn set_first_name<'a>(&'a mut self, first_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Last name of the other party in a private chat"]
    fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Last name of the other party in a private chat"]
    fn get_last_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Last name of the other party in a private chat"]
    fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the supergroup chat is a forum (has topics enabled)"]
    fn get_is_forum<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the supergroup chat is a forum (has topics enabled)"]
    fn get_is_forum_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the supergroup chat is a forum (has topics enabled)"]
    fn set_is_forum<'a>(&'a mut self, is_forum: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat photo. Returned only in getChat."]
    fn get_photo<'a>(&'a self) -> Option<Cow<'a, ChatPhoto>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat photo. Returned only in getChat."]
    fn get_photo_ref<'a>(&'a self) -> Option<&ChatPhoto>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat photo. Returned only in getChat."]
    fn set_photo<'a>(&'a mut self, photo: Option<ChatPhoto>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."]
    fn get_active_usernames<'a>(&'a self) -> Option<Cow<'a, Vec<String>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."]
    fn get_active_usernames_ref<'a>(&'a self) -> Option<&Vec<String>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."]
    fn set_active_usernames<'a>(
        &'a mut self,
        active_usernames: Option<Vec<String>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."]
    fn get_emoji_status_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."]
    fn get_emoji_status_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."]
    fn set_emoji_status_custom_emoji_id<'a>(
        &'a mut self,
        emoji_status_custom_emoji_id: Option<String>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."]
    fn get_emoji_status_expiration_date<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."]
    fn get_emoji_status_expiration_date_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."]
    fn set_emoji_status_expiration_date<'a>(
        &'a mut self,
        emoji_status_expiration_date: Option<i64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the other party in a private chat. Returned only in getChat."]
    fn get_bio<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the other party in a private chat. Returned only in getChat."]
    fn get_bio_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the other party in a private chat. Returned only in getChat."]
    fn set_bio<'a>(&'a mut self, bio: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."]
    fn get_has_private_forwards<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."]
    fn get_has_private_forwards_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."]
    fn set_has_private_forwards<'a>(
        &'a mut self,
        has_private_forwards: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."]
    fn get_has_restricted_voice_and_video_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."]
    fn get_has_restricted_voice_and_video_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."]
    fn set_has_restricted_voice_and_video_messages<'a>(
        &'a mut self,
        has_restricted_voice_and_video_messages: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."]
    fn get_join_to_send_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."]
    fn get_join_to_send_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."]
    fn set_join_to_send_messages<'a>(
        &'a mut self,
        join_to_send_messages: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."]
    fn get_join_by_request<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."]
    fn get_join_by_request_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."]
    fn set_join_by_request<'a>(&'a mut self, join_by_request: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."]
    fn get_invite_link<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."]
    fn get_invite_link_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."]
    fn set_invite_link<'a>(&'a mut self, invite_link: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The most recent pinned message (by sending date). Returned only in getChat."]
    fn get_pinned_message<'a>(&'a self) -> Option<Cow<'a, Message>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The most recent pinned message (by sending date). Returned only in getChat."]
    fn get_pinned_message_ref<'a>(&'a self) -> Option<&Message>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The most recent pinned message (by sending date). Returned only in getChat."]
    fn set_pinned_message<'a>(&'a mut self, pinned_message: Option<Message>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."]
    fn get_permissions<'a>(&'a self) -> Option<Cow<'a, ChatPermissions>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."]
    fn get_permissions_ref<'a>(&'a self) -> Option<&ChatPermissions>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."]
    fn set_permissions<'a>(&'a mut self, permissions: Option<ChatPermissions>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."]
    fn get_slow_mode_delay<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."]
    fn get_slow_mode_delay_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."]
    fn set_slow_mode_delay<'a>(&'a mut self, slow_mode_delay: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."]
    fn get_message_auto_delete_time<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."]
    fn get_message_auto_delete_time_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."]
    fn set_message_auto_delete_time<'a>(
        &'a mut self,
        message_auto_delete_time: Option<i64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."]
    fn get_has_aggressive_anti_spam_enabled<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."]
    fn get_has_aggressive_anti_spam_enabled_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."]
    fn set_has_aggressive_anti_spam_enabled<'a>(
        &'a mut self,
        has_aggressive_anti_spam_enabled: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."]
    fn get_has_hidden_members<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."]
    fn get_has_hidden_members_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."]
    fn set_has_hidden_members<'a>(&'a mut self, has_hidden_members: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."]
    fn get_has_protected_content<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."]
    fn get_has_protected_content_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."]
    fn set_has_protected_content<'a>(
        &'a mut self,
        has_protected_content: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, name of group sticker set. Returned only in getChat."]
    fn get_sticker_set_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, name of group sticker set. Returned only in getChat."]
    fn get_sticker_set_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, name of group sticker set. Returned only in getChat."]
    fn set_sticker_set_name<'a>(&'a mut self, sticker_set_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can change the group sticker set. Returned only in getChat."]
    fn get_can_set_sticker_set<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can change the group sticker set. Returned only in getChat."]
    fn get_can_set_sticker_set_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can change the group sticker set. Returned only in getChat."]
    fn set_can_set_sticker_set<'a>(&'a mut self, can_set_sticker_set: Option<bool>)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."]
    fn get_linked_chat_id<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."]
    fn get_linked_chat_id_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."]
    fn set_linked_chat_id<'a>(&'a mut self, linked_chat_id: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."]
    fn get_location<'a>(&'a self) -> Option<Cow<'a, ChatLocation>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."]
    fn get_location_ref<'a>(&'a self) -> Option<&ChatLocation>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."]
    fn set_location<'a>(&'a mut self, location: Option<ChatLocation>) -> &'a mut Self;
}
trait TraitChatMemberUpdated {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (chat, from, date, old_chat_member, new_chat_member, invite_link, via_chat_folder_invite_link)"]
    fn into_tuple(
        self,
    ) -> (
        Chat,
        User,
        i64,
        ChatMember,
        ChatMember,
        Option<ChatInviteLink>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat the user belongs to"]
    fn get_chat<'a>(&'a self) -> Cow<'a, Chat>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat the user belongs to"]
    fn get_chat_ref<'a>(&'a self) -> &Chat;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat the user belongs to"]
    fn set_chat<'a>(&'a mut self, chat: Chat) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Performer of the action, which resulted in the change"]
    fn get_from<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Performer of the action, which resulted in the change"]
    fn get_from_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Performer of the action, which resulted in the change"]
    fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the change was done in Unix time"]
    fn get_date<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the change was done in Unix time"]
    fn get_date_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the change was done in Unix time"]
    fn set_date<'a>(&'a mut self, date: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    fn get_old_chat_member<'a>(&'a self) -> Cow<'a, ChatMember>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    fn get_old_chat_member_ref<'a>(&'a self) -> &ChatMember;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    fn set_old_chat_member<'a>(&'a mut self, old_chat_member: ChatMember) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    fn get_new_chat_member<'a>(&'a self) -> Cow<'a, ChatMember>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    fn get_new_chat_member_ref<'a>(&'a self) -> &ChatMember;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    fn set_new_chat_member<'a>(&'a mut self, new_chat_member: ChatMember) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."]
    fn get_invite_link<'a>(&'a self) -> Option<Cow<'a, ChatInviteLink>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."]
    fn get_invite_link_ref<'a>(&'a self) -> Option<&ChatInviteLink>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."]
    fn set_invite_link<'a>(&'a mut self, invite_link: Option<ChatInviteLink>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    fn get_via_chat_folder_invite_link<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    fn get_via_chat_folder_invite_link_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    fn set_via_chat_folder_invite_link<'a>(
        &'a mut self,
        via_chat_folder_invite_link: Option<bool>,
    ) -> &'a mut Self;
}
trait TraitBotDescription {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (description)"]
    fn into_tuple(self) -> String;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's description"]
    fn get_description<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's description"]
    fn get_description_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's description"]
    fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self;
}
trait TraitInputLocationMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (latitude, longitude, horizontal_accuracy, live_period, heading, proximity_alert_radius)"]
    fn into_tuple(
        self,
    ) -> (
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        Option<::ordered_float::OrderedFloat<f64>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    fn set_latitude<'a>(&'a mut self, latitude: ::ordered_float::OrderedFloat<f64>)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn get_horizontal_accuracy<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn get_horizontal_accuracy_ref<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn set_horizontal_accuracy<'a>(
        &'a mut self,
        horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn get_live_period<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn get_live_period_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn set_live_period<'a>(&'a mut self, live_period: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn get_heading<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn get_heading_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn set_heading<'a>(&'a mut self, heading: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn get_proximity_alert_radius<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn get_proximity_alert_radius_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn set_proximity_alert_radius<'a>(
        &'a mut self,
        proximity_alert_radius: Option<i64>,
    ) -> &'a mut Self;
}
trait TraitReplyKeyboardMarkup {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (keyboard, is_persistent, resize_keyboard, one_time_keyboard, input_field_placeholder, selective)"]
    fn into_tuple(
        self,
    ) -> (
        Vec<Vec<KeyboardButton>>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<String>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of KeyboardButton objects"]
    fn get_keyboard<'a>(&'a self) -> Cow<'a, Vec<Vec<KeyboardButton>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of KeyboardButton objects"]
    fn get_keyboard_ref<'a>(&'a self) -> &Vec<Vec<KeyboardButton>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of KeyboardButton objects"]
    fn set_keyboard<'a>(&'a mut self, keyboard: Vec<Vec<KeyboardButton>>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."]
    fn get_is_persistent<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."]
    fn get_is_persistent_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."]
    fn set_is_persistent<'a>(&'a mut self, is_persistent: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."]
    fn get_resize_keyboard<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."]
    fn get_resize_keyboard_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."]
    fn set_resize_keyboard<'a>(&'a mut self, resize_keyboard: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."]
    fn get_one_time_keyboard<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."]
    fn get_one_time_keyboard_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."]
    fn set_one_time_keyboard<'a>(&'a mut self, one_time_keyboard: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"]
    fn get_input_field_placeholder<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"]
    fn get_input_field_placeholder_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"]
    fn set_input_field_placeholder<'a>(
        &'a mut self,
        input_field_placeholder: Option<String>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."]
    fn get_selective<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."]
    fn get_selective_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."]
    fn set_selective<'a>(&'a mut self, selective: Option<bool>) -> &'a mut Self;
}
trait TraitMessageId {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_id)"]
    fn into_tuple(self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier"]
    fn get_message_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier"]
    fn get_message_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier"]
    fn set_message_id<'a>(&'a mut self, message_id: i64) -> &'a mut Self;
}
trait TraitPollOption {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (text, voter_count)"]
    fn into_tuple(self) -> (String, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option text, 1-100 characters"]
    fn get_text<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option text, 1-100 characters"]
    fn get_text_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option text, 1-100 characters"]
    fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of users that voted for this option"]
    fn get_voter_count<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of users that voted for this option"]
    fn get_voter_count_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of users that voted for this option"]
    fn set_voter_count<'a>(&'a mut self, voter_count: i64) -> &'a mut Self;
}
trait TraitBotShortDescription {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (short_description)"]
    fn into_tuple(self) -> String;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's short description"]
    fn get_short_description<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's short description"]
    fn get_short_description_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's short description"]
    fn set_short_description<'a>(&'a mut self, short_description: String) -> &'a mut Self;
}
trait TraitInputMediaVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, width, height, duration, supports_streaming, has_spoiler)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media_ref<'a>(&'a self) -> &Option<InputFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&InputFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn set_width<'a>(&'a mut self, width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn set_height<'a>(&'a mut self, height: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_duration<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_duration_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn set_duration<'a>(&'a mut self, duration: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    fn get_supports_streaming<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    fn get_supports_streaming_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    fn set_supports_streaming<'a>(&'a mut self, supports_streaming: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    fn get_has_spoiler<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    fn get_has_spoiler_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    fn set_has_spoiler<'a>(&'a mut self, has_spoiler: Option<bool>) -> &'a mut Self;
}
trait TraitPassportElementErrorFrontSide {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    fn get_source<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    fn get_source_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    fn get_file_hash<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    fn get_file_hash_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self;
}
trait TraitMenuButtonDefault {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
}
trait TraitEncryptedCredentials {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (data, hash, secret)"]
    fn into_tuple(self) -> (String, String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"]
    fn get_data<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"]
    fn get_data_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"]
    fn set_data<'a>(&'a mut self, data: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash for data authentication"]
    fn get_hash<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash for data authentication"]
    fn get_hash_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash for data authentication"]
    fn set_hash<'a>(&'a mut self, hash: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"]
    fn get_secret<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"]
    fn get_secret_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"]
    fn set_secret<'a>(&'a mut self, secret: String) -> &'a mut Self;
}
trait TraitPassportElementErrorFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    fn get_source<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    fn get_source_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn get_file_hash<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn get_file_hash_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self;
}
trait TraitGameHighScore {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (position, user, score)"]
    fn into_tuple(self) -> (i64, User, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Position in high score table for the game"]
    fn get_position<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Position in high score table for the game"]
    fn get_position_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Position in high score table for the game"]
    fn set_position<'a>(&'a mut self, position: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User"]
    fn get_user<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User"]
    fn get_user_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Score"]
    fn get_score<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Score"]
    fn get_score_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Score"]
    fn set_score<'a>(&'a mut self, score: i64) -> &'a mut Self;
}
trait TraitShippingQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, from, invoice_payload, shipping_address)"]
    fn into_tuple(self) -> (String, User, String, ShippingAddress);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    fn get_from<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    fn get_from_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    fn get_invoice_payload<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    fn get_invoice_payload_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    fn set_invoice_payload<'a>(&'a mut self, invoice_payload: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    fn get_shipping_address<'a>(&'a self) -> Cow<'a, ShippingAddress>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    fn get_shipping_address_ref<'a>(&'a self) -> &ShippingAddress;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    fn set_shipping_address<'a>(&'a mut self, shipping_address: ShippingAddress) -> &'a mut Self;
}
trait TraitInlineQueryResultVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, video_url, mime_type, thumbnail_url, title, caption, parse_mode, caption_entities, video_width, video_height, video_duration, description, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    fn get_video_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    fn get_video_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    fn set_video_url<'a>(&'a mut self, video_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    fn get_mime_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    fn get_mime_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    fn set_mime_type<'a>(&'a mut self, mime_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_video_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_video_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn set_video_width<'a>(&'a mut self, video_width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_video_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_video_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn set_video_height<'a>(&'a mut self, video_height: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_video_duration<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_video_duration_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn set_video_duration<'a>(&'a mut self, video_duration: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitSwitchInlineQueryChosenChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (query, allow_user_chats, allow_bot_chats, allow_group_chats, allow_channel_chats)"]
    fn into_tuple(
        self,
    ) -> (
        Option<String>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"]
    fn get_query<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"]
    fn get_query_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"]
    fn set_query<'a>(&'a mut self, query: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with users can be chosen"]
    fn get_allow_user_chats<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with users can be chosen"]
    fn get_allow_user_chats_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with users can be chosen"]
    fn set_allow_user_chats<'a>(&'a mut self, allow_user_chats: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with bots can be chosen"]
    fn get_allow_bot_chats<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with bots can be chosen"]
    fn get_allow_bot_chats_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with bots can be chosen"]
    fn set_allow_bot_chats<'a>(&'a mut self, allow_bot_chats: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if group and supergroup chats can be chosen"]
    fn get_allow_group_chats<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if group and supergroup chats can be chosen"]
    fn get_allow_group_chats_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if group and supergroup chats can be chosen"]
    fn set_allow_group_chats<'a>(&'a mut self, allow_group_chats: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if channel chats can be chosen"]
    fn get_allow_channel_chats<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if channel chats can be chosen"]
    fn get_allow_channel_chats_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if channel chats can be chosen"]
    fn set_allow_channel_chats<'a>(&'a mut self, allow_channel_chats: Option<bool>)
        -> &'a mut Self;
}
trait TraitDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, thumbnail, file_name, mime_type, file_size)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        Option<PhotoSize>,
        Option<String>,
        Option<String>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Document thumbnail as defined by sender"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Document thumbnail as defined by sender"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&PhotoSize>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Document thumbnail as defined by sender"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    fn get_file_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    fn get_file_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    fn set_file_name<'a>(&'a mut self, file_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn get_mime_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn get_mime_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn set_mime_type<'a>(&'a mut self, mime_type: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self;
}
trait TraitPassportElementErrorTranslationFiles {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hashes, message)"]
    fn into_tuple(self) -> (String, String, Vec<String>, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    fn get_source<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    fn get_source_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn get_file_hashes<'a>(&'a self) -> Cow<'a, Vec<String>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn get_file_hashes_ref<'a>(&'a self) -> &Vec<String>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn set_file_hashes<'a>(&'a mut self, file_hashes: Vec<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self;
}
trait TraitMessageEntity {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, offset, length, url, user, language, custom_emoji_id)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        i64,
        i64,
        Option<String>,
        Option<User>,
        Option<String>,
        Option<String>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the entity. Currently, can be \"mention\" (@username), \"hashtag\" (#hashtag), \"cashtag\" ($USD), \"bot_command\" (/start@jobs_bot), \"url\" (https://telegram.org), \"email\" (do-not-reply@telegram.org), \"phone_number\" (+1-212-555-0123), \"bold\" (bold text), \"italic\" (italic text), \"underline\" (underlined text), \"strikethrough\" (strikethrough text), \"spoiler\" (spoiler message), \"code\" (monowidth string), \"pre\" (monowidth block), \"text_link\" (for clickable text URLs), \"text_mention\" (for users without usernames), \"custom_emoji\" (for inline custom emoji stickers)"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the entity. Currently, can be \"mention\" (@username), \"hashtag\" (#hashtag), \"cashtag\" ($USD), \"bot_command\" (/start@jobs_bot), \"url\" (https://telegram.org), \"email\" (do-not-reply@telegram.org), \"phone_number\" (+1-212-555-0123), \"bold\" (bold text), \"italic\" (italic text), \"underline\" (underlined text), \"strikethrough\" (strikethrough text), \"spoiler\" (spoiler message), \"code\" (monowidth string), \"pre\" (monowidth block), \"text_link\" (for clickable text URLs), \"text_mention\" (for users without usernames), \"custom_emoji\" (for inline custom emoji stickers)"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the entity. Currently, can be \"mention\" (@username), \"hashtag\" (#hashtag), \"cashtag\" ($USD), \"bot_command\" (/start@jobs_bot), \"url\" (https://telegram.org), \"email\" (do-not-reply@telegram.org), \"phone_number\" (+1-212-555-0123), \"bold\" (bold text), \"italic\" (italic text), \"underline\" (underlined text), \"strikethrough\" (strikethrough text), \"spoiler\" (spoiler message), \"code\" (monowidth string), \"pre\" (monowidth block), \"text_link\" (for clickable text URLs), \"text_mention\" (for users without usernames), \"custom_emoji\" (for inline custom emoji stickers)"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset in UTF-16 code units to the start of the entity"]
    fn get_offset<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset in UTF-16 code units to the start of the entity"]
    fn get_offset_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset in UTF-16 code units to the start of the entity"]
    fn set_offset<'a>(&'a mut self, offset: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Length of the entity in UTF-16 code units"]
    fn get_length<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Length of the entity in UTF-16 code units"]
    fn get_length_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Length of the entity in UTF-16 code units"]
    fn set_length<'a>(&'a mut self, length: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_link\" only, URL that will be opened after user taps on the text"]
    fn get_url<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_link\" only, URL that will be opened after user taps on the text"]
    fn get_url_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_link\" only, URL that will be opened after user taps on the text"]
    fn set_url<'a>(&'a mut self, url: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_mention\" only, the mentioned user"]
    fn get_user<'a>(&'a self) -> Option<Cow<'a, User>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_mention\" only, the mentioned user"]
    fn get_user_ref<'a>(&'a self) -> Option<&User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_mention\" only, the mentioned user"]
    fn set_user<'a>(&'a mut self, user: Option<User>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"pre\" only, the programming language of the entity text"]
    fn get_language<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"pre\" only, the programming language of the entity text"]
    fn get_language_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"pre\" only, the programming language of the entity text"]
    fn set_language<'a>(&'a mut self, language: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"custom_emoji\" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker"]
    fn get_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"custom_emoji\" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker"]
    fn get_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"custom_emoji\" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker"]
    fn set_custom_emoji_id<'a>(&'a mut self, custom_emoji_id: Option<String>) -> &'a mut Self;
}
trait TraitChatMemberAdministrator {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, can_be_edited, is_anonymous, can_manage_chat, can_delete_messages, can_manage_video_chats, can_restrict_members, can_promote_members, can_change_info, can_invite_users, can_post_messages, can_edit_messages, can_pin_messages, can_post_stories, can_edit_stories, can_delete_stories, can_manage_topics, custom_title)"]
    fn into_tuple(
        self,
    ) -> (
        User,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<String>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    fn get_can_be_edited<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    fn get_can_be_edited_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    fn set_can_be_edited<'a>(&'a mut self, can_be_edited: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn get_is_anonymous<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn get_is_anonymous_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn set_is_anonymous<'a>(&'a mut self, is_anonymous: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    fn get_can_manage_chat<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    fn get_can_manage_chat_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    fn set_can_manage_chat<'a>(&'a mut self, can_manage_chat: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    fn get_can_delete_messages<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    fn get_can_delete_messages_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    fn set_can_delete_messages<'a>(&'a mut self, can_delete_messages: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    fn get_can_manage_video_chats<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    fn get_can_manage_video_chats_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    fn set_can_manage_video_chats<'a>(&'a mut self, can_manage_video_chats: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    fn get_can_restrict_members<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    fn get_can_restrict_members_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    fn set_can_restrict_members<'a>(&'a mut self, can_restrict_members: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    fn get_can_promote_members<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    fn get_can_promote_members_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    fn set_can_promote_members<'a>(&'a mut self, can_promote_members: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn get_can_change_info<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn get_can_change_info_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn set_can_change_info<'a>(&'a mut self, can_change_info: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn set_can_invite_users<'a>(&'a mut self, can_invite_users: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    fn get_can_post_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    fn get_can_post_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    fn set_can_post_messages<'a>(&'a mut self, can_post_messages: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    fn get_can_edit_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    fn get_can_edit_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    fn set_can_edit_messages<'a>(&'a mut self, can_edit_messages: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    fn get_can_pin_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    fn get_can_pin_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    fn set_can_pin_messages<'a>(&'a mut self, can_pin_messages: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    fn get_can_post_stories<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    fn get_can_post_stories_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    fn set_can_post_stories<'a>(&'a mut self, can_post_stories: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    fn get_can_edit_stories<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    fn get_can_edit_stories_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    fn set_can_edit_stories<'a>(&'a mut self, can_edit_stories: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    fn get_can_delete_stories<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    fn get_can_delete_stories_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    fn set_can_delete_stories<'a>(&'a mut self, can_delete_stories: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    fn get_can_manage_topics<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    fn get_can_manage_topics_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    fn set_can_manage_topics<'a>(&'a mut self, can_manage_topics: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn get_custom_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn get_custom_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn set_custom_title<'a>(&'a mut self, custom_title: Option<String>) -> &'a mut Self;
}
trait TraitInlineQueryResultVenue {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, latitude, longitude, title, address, foursquare_id, foursquare_type, google_place_id, google_place_type, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    fn set_latitude<'a>(&'a mut self, latitude: ::ordered_float::OrderedFloat<f64>)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn get_address<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn get_address_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn set_address<'a>(&'a mut self, address: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    fn get_foursquare_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    fn get_foursquare_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    fn set_foursquare_id<'a>(&'a mut self, foursquare_id: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn get_foursquare_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn get_foursquare_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn set_foursquare_type<'a>(&'a mut self, foursquare_type: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn get_google_place_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn get_google_place_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn set_google_place_id<'a>(&'a mut self, google_place_id: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn get_google_place_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn get_google_place_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn set_google_place_type<'a>(&'a mut self, google_place_type: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self;
}
trait TraitContact {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (phone_number, first_name, last_name, user_id, vcard)"]
    fn into_tuple(self) -> (String, String, Option<String>, Option<i64>, Option<String>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn get_phone_number<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn get_phone_number_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn set_phone_number<'a>(&'a mut self, phone_number: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn get_first_name<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn get_first_name_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn set_first_name<'a>(&'a mut self, first_name: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn get_last_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_user_id<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_user_id_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn set_user_id<'a>(&'a mut self, user_id: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard"]
    fn get_vcard<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard"]
    fn get_vcard_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard"]
    fn set_vcard<'a>(&'a mut self, vcard: Option<String>) -> &'a mut Self;
}
trait TraitInlineQueryResultGame {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, game_short_name, reply_markup)"]
    fn into_tuple(self) -> (String, String, String, Option<InlineKeyboardMarkup>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    fn get_game_short_name<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    fn get_game_short_name_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    fn set_game_short_name<'a>(&'a mut self, game_short_name: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
}
trait TraitBotCommandScopeAllPrivateChats {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
}
trait TraitForumTopicReopened {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitUserProfilePhotos {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (total_count, photos)"]
    fn into_tuple(self) -> (i64, Vec<Vec<PhotoSize>>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of profile pictures the target user has"]
    fn get_total_count<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of profile pictures the target user has"]
    fn get_total_count_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of profile pictures the target user has"]
    fn set_total_count<'a>(&'a mut self, total_count: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requested profile pictures (in up to 4 sizes each)"]
    fn get_photos<'a>(&'a self) -> Cow<'a, Vec<Vec<PhotoSize>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requested profile pictures (in up to 4 sizes each)"]
    fn get_photos_ref<'a>(&'a self) -> &Vec<Vec<PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requested profile pictures (in up to 4 sizes each)"]
    fn set_photos<'a>(&'a mut self, photos: Vec<Vec<PhotoSize>>) -> &'a mut Self;
}
trait TraitInlineQueryResultsButton {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (text, web_app, start_parameter)"]
    fn into_tuple(self) -> (String, Option<WebAppInfo>, Option<String>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    fn get_text<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    fn get_text_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."]
    fn get_web_app<'a>(&'a self) -> Option<Cow<'a, WebAppInfo>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."]
    fn get_web_app_ref<'a>(&'a self) -> Option<&WebAppInfo>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."]
    fn set_web_app<'a>(&'a mut self, web_app: Option<WebAppInfo>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."]
    fn get_start_parameter<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."]
    fn get_start_parameter_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."]
    fn set_start_parameter<'a>(&'a mut self, start_parameter: Option<String>) -> &'a mut Self;
}
trait TraitMessage {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_id, message_thread_id, from, sender_chat, date, chat, forward_from, forward_from_chat, forward_from_message_id, forward_signature, forward_sender_name, forward_date, is_topic_message, is_automatic_forward, reply_to_message, via_bot, edit_date, has_protected_content, media_group_id, author_signature, text, entities, animation, audio, document, photo, sticker, story, video, video_note, voice, caption, caption_entities, has_media_spoiler, contact, dice, game, poll, venue, location, new_chat_members, left_chat_member, new_chat_title, new_chat_photo, delete_chat_photo, group_chat_created, supergroup_chat_created, channel_chat_created, message_auto_delete_timer_changed, migrate_to_chat_id, migrate_from_chat_id, pinned_message, invoice, successful_payment, user_shared, chat_shared, connected_website, write_access_allowed, passport_data, proximity_alert_triggered, forum_topic_created, forum_topic_edited, forum_topic_closed, forum_topic_reopened, general_forum_topic_hidden, general_forum_topic_unhidden, video_chat_scheduled, video_chat_started, video_chat_ended, video_chat_participants_invited, web_app_data, reply_markup)"]
    fn into_tuple(
        self,
    ) -> (
        i64,
        Option<i64>,
        Option<User>,
        Option<Chat>,
        i64,
        Chat,
        Option<User>,
        Option<Chat>,
        Option<i64>,
        Option<String>,
        Option<String>,
        Option<i64>,
        Option<bool>,
        Option<bool>,
        Option<Message>,
        Option<User>,
        Option<i64>,
        Option<bool>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<Animation>,
        Option<Audio>,
        Option<Document>,
        Option<Vec<PhotoSize>>,
        Option<Sticker>,
        Option<Story>,
        Option<Video>,
        Option<VideoNote>,
        Option<Voice>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
        Option<Contact>,
        Option<Dice>,
        Option<Game>,
        Option<Poll>,
        Option<Venue>,
        Option<Location>,
        Option<Vec<User>>,
        Option<User>,
        Option<String>,
        Option<Vec<PhotoSize>>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<MessageAutoDeleteTimerChanged>,
        Option<i64>,
        Option<i64>,
        Option<Message>,
        Option<Invoice>,
        Option<SuccessfulPayment>,
        Option<UserShared>,
        Option<ChatShared>,
        Option<String>,
        Option<WriteAccessAllowed>,
        Option<PassportData>,
        Option<ProximityAlertTriggered>,
        Option<ForumTopicCreated>,
        Option<ForumTopicEdited>,
        Option<ForumTopicClosed>,
        Option<ForumTopicReopened>,
        Option<GeneralForumTopicHidden>,
        Option<GeneralForumTopicUnhidden>,
        Option<VideoChatScheduled>,
        Option<VideoChatStarted>,
        Option<VideoChatEnded>,
        Option<VideoChatParticipantsInvited>,
        Option<WebAppData>,
        Option<InlineKeyboardMarkup>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    fn get_message_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    fn get_message_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    fn set_message_id<'a>(&'a mut self, message_id: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    fn get_message_thread_id<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    fn get_message_thread_id_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    fn set_message_thread_id<'a>(&'a mut self, message_thread_id: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    fn get_from<'a>(&'a self) -> Option<Cow<'a, User>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    fn get_from_ref<'a>(&'a self) -> Option<&User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    fn set_from<'a>(&'a mut self, from: Option<User>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    fn get_sender_chat<'a>(&'a self) -> Option<Cow<'a, Chat>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    fn get_sender_chat_ref<'a>(&'a self) -> Option<&Chat>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    fn set_sender_chat<'a>(&'a mut self, sender_chat: Option<Chat>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    fn get_date<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    fn get_date_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    fn set_date<'a>(&'a mut self, date: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    fn get_chat<'a>(&'a self) -> Cow<'a, Chat>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    fn get_chat_ref<'a>(&'a self) -> &Chat;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    fn set_chat<'a>(&'a mut self, chat: Chat) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    fn get_forward_from<'a>(&'a self) -> Option<Cow<'a, User>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    fn get_forward_from_ref<'a>(&'a self) -> Option<&User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    fn set_forward_from<'a>(&'a mut self, forward_from: Option<User>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    fn get_forward_from_chat<'a>(&'a self) -> Option<Cow<'a, Chat>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    fn get_forward_from_chat_ref<'a>(&'a self) -> Option<&Chat>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    fn set_forward_from_chat<'a>(&'a mut self, forward_from_chat: Option<Chat>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    fn get_forward_from_message_id<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    fn get_forward_from_message_id_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    fn set_forward_from_message_id<'a>(
        &'a mut self,
        forward_from_message_id: Option<i64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    fn get_forward_signature<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    fn get_forward_signature_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    fn set_forward_signature<'a>(&'a mut self, forward_signature: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    fn get_forward_sender_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    fn get_forward_sender_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    fn set_forward_sender_name<'a>(
        &'a mut self,
        forward_sender_name: Option<String>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    fn get_forward_date<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    fn get_forward_date_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    fn set_forward_date<'a>(&'a mut self, forward_date: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    fn get_is_topic_message<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    fn get_is_topic_message_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    fn set_is_topic_message<'a>(&'a mut self, is_topic_message: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    fn get_is_automatic_forward<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    fn get_is_automatic_forward_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    fn set_is_automatic_forward<'a>(
        &'a mut self,
        is_automatic_forward: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    fn get_reply_to_message<'a>(&'a self) -> Option<Cow<'a, Message>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    fn get_reply_to_message_ref<'a>(&'a self) -> Option<&Message>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    fn set_reply_to_message<'a>(&'a mut self, reply_to_message: Option<Message>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    fn get_via_bot<'a>(&'a self) -> Option<Cow<'a, User>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    fn get_via_bot_ref<'a>(&'a self) -> Option<&User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    fn set_via_bot<'a>(&'a mut self, via_bot: Option<User>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    fn get_edit_date<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    fn get_edit_date_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    fn set_edit_date<'a>(&'a mut self, edit_date: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    fn get_has_protected_content<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    fn get_has_protected_content_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    fn set_has_protected_content<'a>(
        &'a mut self,
        has_protected_content: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    fn get_media_group_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    fn get_media_group_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    fn set_media_group_id<'a>(&'a mut self, media_group_id: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    fn get_author_signature<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    fn get_author_signature_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    fn set_author_signature<'a>(&'a mut self, author_signature: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    fn get_text<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    fn get_text_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    fn set_text<'a>(&'a mut self, text: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    fn get_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    fn get_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    fn set_entities<'a>(&'a mut self, entities: Option<Vec<MessageEntity>>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    fn get_animation<'a>(&'a self) -> Option<Cow<'a, Animation>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    fn get_animation_ref<'a>(&'a self) -> Option<&Animation>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    fn set_animation<'a>(&'a mut self, animation: Option<Animation>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    fn get_audio<'a>(&'a self) -> Option<Cow<'a, Audio>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    fn get_audio_ref<'a>(&'a self) -> Option<&Audio>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    fn set_audio<'a>(&'a mut self, audio: Option<Audio>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    fn get_document<'a>(&'a self) -> Option<Cow<'a, Document>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    fn get_document_ref<'a>(&'a self) -> Option<&Document>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    fn set_document<'a>(&'a mut self, document: Option<Document>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    fn get_photo<'a>(&'a self) -> Option<Cow<'a, Vec<PhotoSize>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    fn get_photo_ref<'a>(&'a self) -> Option<&Vec<PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    fn set_photo<'a>(&'a mut self, photo: Option<Vec<PhotoSize>>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    fn get_sticker<'a>(&'a self) -> Option<Cow<'a, Sticker>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    fn get_sticker_ref<'a>(&'a self) -> Option<&Sticker>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    fn set_sticker<'a>(&'a mut self, sticker: Option<Sticker>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    fn get_story<'a>(&'a self) -> Option<Cow<'a, Story>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    fn get_story_ref<'a>(&'a self) -> Option<&Story>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    fn set_story<'a>(&'a mut self, story: Option<Story>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    fn get_video<'a>(&'a self) -> Option<Cow<'a, Video>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    fn get_video_ref<'a>(&'a self) -> Option<&Video>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    fn set_video<'a>(&'a mut self, video: Option<Video>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    fn get_video_note<'a>(&'a self) -> Option<Cow<'a, VideoNote>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    fn get_video_note_ref<'a>(&'a self) -> Option<&VideoNote>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    fn set_video_note<'a>(&'a mut self, video_note: Option<VideoNote>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    fn get_voice<'a>(&'a self) -> Option<Cow<'a, Voice>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    fn get_voice_ref<'a>(&'a self) -> Option<&Voice>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    fn set_voice<'a>(&'a mut self, voice: Option<Voice>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    fn get_has_media_spoiler<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    fn get_has_media_spoiler_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    fn set_has_media_spoiler<'a>(&'a mut self, has_media_spoiler: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    fn get_contact<'a>(&'a self) -> Option<Cow<'a, Contact>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    fn get_contact_ref<'a>(&'a self) -> Option<&Contact>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    fn set_contact<'a>(&'a mut self, contact: Option<Contact>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    fn get_dice<'a>(&'a self) -> Option<Cow<'a, Dice>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    fn get_dice_ref<'a>(&'a self) -> Option<&Dice>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    fn set_dice<'a>(&'a mut self, dice: Option<Dice>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    fn get_game<'a>(&'a self) -> Option<Cow<'a, Game>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    fn get_game_ref<'a>(&'a self) -> Option<&Game>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    fn set_game<'a>(&'a mut self, game: Option<Game>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    fn get_poll<'a>(&'a self) -> Option<Cow<'a, Poll>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    fn get_poll_ref<'a>(&'a self) -> Option<&Poll>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    fn set_poll<'a>(&'a mut self, poll: Option<Poll>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    fn get_venue<'a>(&'a self) -> Option<Cow<'a, Venue>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    fn get_venue_ref<'a>(&'a self) -> Option<&Venue>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    fn set_venue<'a>(&'a mut self, venue: Option<Venue>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared location, information about the location"]
    fn get_location<'a>(&'a self) -> Option<Cow<'a, Location>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared location, information about the location"]
    fn get_location_ref<'a>(&'a self) -> Option<&Location>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared location, information about the location"]
    fn set_location<'a>(&'a mut self, location: Option<Location>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    fn get_new_chat_members<'a>(&'a self) -> Option<Cow<'a, Vec<User>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    fn get_new_chat_members_ref<'a>(&'a self) -> Option<&Vec<User>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    fn set_new_chat_members<'a>(&'a mut self, new_chat_members: Option<Vec<User>>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    fn get_left_chat_member<'a>(&'a self) -> Option<Cow<'a, User>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    fn get_left_chat_member_ref<'a>(&'a self) -> Option<&User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    fn set_left_chat_member<'a>(&'a mut self, left_chat_member: Option<User>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    fn get_new_chat_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    fn get_new_chat_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    fn set_new_chat_title<'a>(&'a mut self, new_chat_title: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    fn get_new_chat_photo<'a>(&'a self) -> Option<Cow<'a, Vec<PhotoSize>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    fn get_new_chat_photo_ref<'a>(&'a self) -> Option<&Vec<PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    fn set_new_chat_photo<'a>(&'a mut self, new_chat_photo: Option<Vec<PhotoSize>>)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    fn get_delete_chat_photo<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    fn get_delete_chat_photo_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    fn set_delete_chat_photo<'a>(&'a mut self, delete_chat_photo: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    fn get_group_chat_created<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    fn get_group_chat_created_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    fn set_group_chat_created<'a>(&'a mut self, group_chat_created: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    fn get_supergroup_chat_created<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    fn get_supergroup_chat_created_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    fn set_supergroup_chat_created<'a>(
        &'a mut self,
        supergroup_chat_created: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    fn get_channel_chat_created<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    fn get_channel_chat_created_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    fn set_channel_chat_created<'a>(
        &'a mut self,
        channel_chat_created: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    fn get_message_auto_delete_timer_changed<'a>(
        &'a self,
    ) -> Option<Cow<'a, MessageAutoDeleteTimerChanged>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    fn get_message_auto_delete_timer_changed_ref<'a>(
        &'a self,
    ) -> Option<&MessageAutoDeleteTimerChanged>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    fn set_message_auto_delete_timer_changed<'a>(
        &'a mut self,
        message_auto_delete_timer_changed: Option<MessageAutoDeleteTimerChanged>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_migrate_to_chat_id<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_migrate_to_chat_id_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn set_migrate_to_chat_id<'a>(&'a mut self, migrate_to_chat_id: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_migrate_from_chat_id<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_migrate_from_chat_id_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn set_migrate_from_chat_id<'a>(
        &'a mut self,
        migrate_from_chat_id: Option<i64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    fn get_pinned_message<'a>(&'a self) -> Option<Cow<'a, Message>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    fn get_pinned_message_ref<'a>(&'a self) -> Option<&Message>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    fn set_pinned_message<'a>(&'a mut self, pinned_message: Option<Message>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    fn get_invoice<'a>(&'a self) -> Option<Cow<'a, Invoice>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    fn get_invoice_ref<'a>(&'a self) -> Option<&Invoice>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    fn set_invoice<'a>(&'a mut self, invoice: Option<Invoice>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    fn get_successful_payment<'a>(&'a self) -> Option<Cow<'a, SuccessfulPayment>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    fn get_successful_payment_ref<'a>(&'a self) -> Option<&SuccessfulPayment>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    fn set_successful_payment<'a>(
        &'a mut self,
        successful_payment: Option<SuccessfulPayment>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    fn get_user_shared<'a>(&'a self) -> Option<Cow<'a, UserShared>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    fn get_user_shared_ref<'a>(&'a self) -> Option<&UserShared>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    fn set_user_shared<'a>(&'a mut self, user_shared: Option<UserShared>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    fn get_chat_shared<'a>(&'a self) -> Option<Cow<'a, ChatShared>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    fn get_chat_shared_ref<'a>(&'a self) -> Option<&ChatShared>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    fn set_chat_shared<'a>(&'a mut self, chat_shared: Option<ChatShared>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    fn get_connected_website<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    fn get_connected_website_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    fn set_connected_website<'a>(&'a mut self, connected_website: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    fn get_write_access_allowed<'a>(&'a self) -> Option<Cow<'a, WriteAccessAllowed>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    fn get_write_access_allowed_ref<'a>(&'a self) -> Option<&WriteAccessAllowed>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    fn set_write_access_allowed<'a>(
        &'a mut self,
        write_access_allowed: Option<WriteAccessAllowed>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    fn get_passport_data<'a>(&'a self) -> Option<Cow<'a, PassportData>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    fn get_passport_data_ref<'a>(&'a self) -> Option<&PassportData>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    fn set_passport_data<'a>(&'a mut self, passport_data: Option<PassportData>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    fn get_proximity_alert_triggered<'a>(&'a self) -> Option<Cow<'a, ProximityAlertTriggered>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    fn get_proximity_alert_triggered_ref<'a>(&'a self) -> Option<&ProximityAlertTriggered>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    fn set_proximity_alert_triggered<'a>(
        &'a mut self,
        proximity_alert_triggered: Option<ProximityAlertTriggered>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    fn get_forum_topic_created<'a>(&'a self) -> Option<Cow<'a, ForumTopicCreated>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    fn get_forum_topic_created_ref<'a>(&'a self) -> Option<&ForumTopicCreated>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    fn set_forum_topic_created<'a>(
        &'a mut self,
        forum_topic_created: Option<ForumTopicCreated>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    fn get_forum_topic_edited<'a>(&'a self) -> Option<Cow<'a, ForumTopicEdited>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    fn get_forum_topic_edited_ref<'a>(&'a self) -> Option<&ForumTopicEdited>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    fn set_forum_topic_edited<'a>(
        &'a mut self,
        forum_topic_edited: Option<ForumTopicEdited>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    fn get_forum_topic_closed<'a>(&'a self) -> Option<Cow<'a, ForumTopicClosed>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    fn get_forum_topic_closed_ref<'a>(&'a self) -> Option<&ForumTopicClosed>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    fn set_forum_topic_closed<'a>(
        &'a mut self,
        forum_topic_closed: Option<ForumTopicClosed>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    fn get_forum_topic_reopened<'a>(&'a self) -> Option<Cow<'a, ForumTopicReopened>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    fn get_forum_topic_reopened_ref<'a>(&'a self) -> Option<&ForumTopicReopened>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    fn set_forum_topic_reopened<'a>(
        &'a mut self,
        forum_topic_reopened: Option<ForumTopicReopened>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    fn get_general_forum_topic_hidden<'a>(&'a self) -> Option<Cow<'a, GeneralForumTopicHidden>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    fn get_general_forum_topic_hidden_ref<'a>(&'a self) -> Option<&GeneralForumTopicHidden>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    fn set_general_forum_topic_hidden<'a>(
        &'a mut self,
        general_forum_topic_hidden: Option<GeneralForumTopicHidden>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    fn get_general_forum_topic_unhidden<'a>(&'a self)
        -> Option<Cow<'a, GeneralForumTopicUnhidden>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    fn get_general_forum_topic_unhidden_ref<'a>(&'a self) -> Option<&GeneralForumTopicUnhidden>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    fn set_general_forum_topic_unhidden<'a>(
        &'a mut self,
        general_forum_topic_unhidden: Option<GeneralForumTopicUnhidden>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    fn get_video_chat_scheduled<'a>(&'a self) -> Option<Cow<'a, VideoChatScheduled>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    fn get_video_chat_scheduled_ref<'a>(&'a self) -> Option<&VideoChatScheduled>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    fn set_video_chat_scheduled<'a>(
        &'a mut self,
        video_chat_scheduled: Option<VideoChatScheduled>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    fn get_video_chat_started<'a>(&'a self) -> Option<Cow<'a, VideoChatStarted>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    fn get_video_chat_started_ref<'a>(&'a self) -> Option<&VideoChatStarted>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    fn set_video_chat_started<'a>(
        &'a mut self,
        video_chat_started: Option<VideoChatStarted>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    fn get_video_chat_ended<'a>(&'a self) -> Option<Cow<'a, VideoChatEnded>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    fn get_video_chat_ended_ref<'a>(&'a self) -> Option<&VideoChatEnded>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    fn set_video_chat_ended<'a>(
        &'a mut self,
        video_chat_ended: Option<VideoChatEnded>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    fn get_video_chat_participants_invited<'a>(
        &'a self,
    ) -> Option<Cow<'a, VideoChatParticipantsInvited>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    fn get_video_chat_participants_invited_ref<'a>(
        &'a self,
    ) -> Option<&VideoChatParticipantsInvited>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    fn set_video_chat_participants_invited<'a>(
        &'a mut self,
        video_chat_participants_invited: Option<VideoChatParticipantsInvited>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    fn get_web_app_data<'a>(&'a self) -> Option<Cow<'a, WebAppData>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    fn get_web_app_data_ref<'a>(&'a self) -> Option<&WebAppData>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    fn set_web_app_data<'a>(&'a mut self, web_app_data: Option<WebAppData>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
}
trait TraitPreCheckoutQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, from, currency, total_amount, invoice_payload, shipping_option_id, order_info)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        User,
        String,
        i64,
        String,
        Option<String>,
        Option<OrderInfo>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    fn get_from<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    fn get_from_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    fn get_currency<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    fn get_currency_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    fn set_currency<'a>(&'a mut self, currency: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn get_total_amount<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn get_total_amount_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn set_total_amount<'a>(&'a mut self, total_amount: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    fn get_invoice_payload<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    fn get_invoice_payload_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    fn set_invoice_payload<'a>(&'a mut self, invoice_payload: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    fn get_shipping_option_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    fn get_shipping_option_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    fn set_shipping_option_id<'a>(&'a mut self, shipping_option_id: Option<String>)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    fn get_order_info<'a>(&'a self) -> Option<Cow<'a, OrderInfo>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    fn get_order_info_ref<'a>(&'a self) -> Option<&OrderInfo>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    fn set_order_info<'a>(&'a mut self, order_info: Option<OrderInfo>) -> &'a mut Self;
}
trait TraitForumTopicEdited {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (name, icon_custom_emoji_id)"]
    fn into_tuple(self) -> (Option<String>, Option<String>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New name of the topic, if it was edited"]
    fn get_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New name of the topic, if it was edited"]
    fn get_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New name of the topic, if it was edited"]
    fn set_name<'a>(&'a mut self, name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"]
    fn get_icon_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"]
    fn get_icon_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"]
    fn set_icon_custom_emoji_id<'a>(
        &'a mut self,
        icon_custom_emoji_id: Option<String>,
    ) -> &'a mut Self;
}
trait TraitFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, file_size, file_path)"]
    fn into_tuple(self) -> (String, String, Option<i64>, Option<String>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."]
    fn get_file_path<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."]
    fn get_file_path_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."]
    fn set_file_path<'a>(&'a mut self, file_path: Option<String>) -> &'a mut Self;
}
trait TraitChatMember:
    TraitChatMemberOwner
    + TraitChatMemberAdministrator
    + TraitChatMemberMember
    + TraitChatMemberRestricted
    + TraitChatMemberLeft
    + TraitChatMemberBanned
{
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitPoll {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, question, options, total_voter_count, is_closed, is_anonymous, type, allows_multiple_answers, correct_option_id, explanation, explanation_entities, open_period, close_date)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        Vec<PollOption>,
        i64,
        bool,
        bool,
        String,
        bool,
        Option<i64>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    fn get_question<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    fn get_question_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    fn set_question<'a>(&'a mut self, question: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    fn get_options<'a>(&'a self) -> Cow<'a, Vec<PollOption>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    fn get_options_ref<'a>(&'a self) -> &Vec<PollOption>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    fn set_options<'a>(&'a mut self, options: Vec<PollOption>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    fn get_total_voter_count<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    fn get_total_voter_count_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    fn set_total_voter_count<'a>(&'a mut self, total_voter_count: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    fn get_is_closed<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    fn get_is_closed_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    fn set_is_closed<'a>(&'a mut self, is_closed: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    fn get_is_anonymous<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    fn get_is_anonymous_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    fn set_is_anonymous<'a>(&'a mut self, is_anonymous: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    fn get_allows_multiple_answers<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    fn get_allows_multiple_answers_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    fn set_allows_multiple_answers<'a>(&'a mut self, allows_multiple_answers: bool)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    fn get_correct_option_id<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    fn get_correct_option_id_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    fn set_correct_option_id<'a>(&'a mut self, correct_option_id: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    fn get_explanation<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    fn get_explanation_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    fn set_explanation<'a>(&'a mut self, explanation: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    fn get_explanation_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    fn get_explanation_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    fn set_explanation_entities<'a>(
        &'a mut self,
        explanation_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    fn get_open_period<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    fn get_open_period_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    fn set_open_period<'a>(&'a mut self, open_period: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    fn get_close_date<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    fn get_close_date_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    fn set_close_date<'a>(&'a mut self, close_date: Option<i64>) -> &'a mut Self;
}
trait TraitInlineQueryResultCachedVoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, voice_file_id, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    fn get_voice_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    fn get_voice_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    fn set_voice_file_id<'a>(&'a mut self, voice_file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitSuccessfulPayment {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (currency, total_amount, invoice_payload, shipping_option_id, order_info, telegram_payment_charge_id, provider_payment_charge_id)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        i64,
        String,
        Option<String>,
        Option<OrderInfo>,
        String,
        String,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    fn get_currency<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    fn get_currency_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    fn set_currency<'a>(&'a mut self, currency: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn get_total_amount<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn get_total_amount_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn set_total_amount<'a>(&'a mut self, total_amount: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    fn get_invoice_payload<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    fn get_invoice_payload_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    fn set_invoice_payload<'a>(&'a mut self, invoice_payload: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    fn get_shipping_option_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    fn get_shipping_option_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    fn set_shipping_option_id<'a>(&'a mut self, shipping_option_id: Option<String>)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    fn get_order_info<'a>(&'a self) -> Option<Cow<'a, OrderInfo>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    fn get_order_info_ref<'a>(&'a self) -> Option<&OrderInfo>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    fn set_order_info<'a>(&'a mut self, order_info: Option<OrderInfo>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Telegram payment identifier"]
    fn get_telegram_payment_charge_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Telegram payment identifier"]
    fn get_telegram_payment_charge_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Telegram payment identifier"]
    fn set_telegram_payment_charge_id<'a>(
        &'a mut self,
        telegram_payment_charge_id: String,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Provider payment identifier"]
    fn get_provider_payment_charge_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Provider payment identifier"]
    fn get_provider_payment_charge_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Provider payment identifier"]
    fn set_provider_payment_charge_id<'a>(
        &'a mut self,
        provider_payment_charge_id: String,
    ) -> &'a mut Self;
}
trait TraitInputMediaDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, disable_content_type_detection)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media_ref<'a>(&'a self) -> &Option<InputFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&InputFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    fn get_disable_content_type_detection<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    fn get_disable_content_type_detection_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    fn set_disable_content_type_detection<'a>(
        &'a mut self,
        disable_content_type_detection: Option<bool>,
    ) -> &'a mut Self;
}
trait TraitLocation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (longitude, latitude, horizontal_accuracy, live_period, heading, proximity_alert_radius)"]
    fn into_tuple(
        self,
    ) -> (
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        Option<::ordered_float::OrderedFloat<f64>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude as defined by sender"]
    fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude as defined by sender"]
    fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude as defined by sender"]
    fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude as defined by sender"]
    fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude as defined by sender"]
    fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude as defined by sender"]
    fn set_latitude<'a>(&'a mut self, latitude: ::ordered_float::OrderedFloat<f64>)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn get_horizontal_accuracy<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn get_horizontal_accuracy_ref<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn set_horizontal_accuracy<'a>(
        &'a mut self,
        horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."]
    fn get_live_period<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."]
    fn get_live_period_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."]
    fn set_live_period<'a>(&'a mut self, live_period: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."]
    fn get_heading<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."]
    fn get_heading_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."]
    fn set_heading<'a>(&'a mut self, heading: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."]
    fn get_proximity_alert_radius<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."]
    fn get_proximity_alert_radius_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."]
    fn set_proximity_alert_radius<'a>(
        &'a mut self,
        proximity_alert_radius: Option<i64>,
    ) -> &'a mut Self;
}
trait TraitKeyboardButton {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (text, request_user, request_chat, request_contact, request_location, request_poll, web_app)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<KeyboardButtonRequestUser>,
        Option<KeyboardButtonRequestChat>,
        Option<bool>,
        Option<bool>,
        Option<KeyboardButtonPollType>,
        Option<WebAppInfo>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"]
    fn get_text<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"]
    fn get_text_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"]
    fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a \"user_shared\" service message. Available in private chats only."]
    fn get_request_user<'a>(&'a self) -> Option<Cow<'a, KeyboardButtonRequestUser>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a \"user_shared\" service message. Available in private chats only."]
    fn get_request_user_ref<'a>(&'a self) -> Option<&KeyboardButtonRequestUser>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a \"user_shared\" service message. Available in private chats only."]
    fn set_request_user<'a>(
        &'a mut self,
        request_user: Option<KeyboardButtonRequestUser>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a \"chat_shared\" service message. Available in private chats only."]
    fn get_request_chat<'a>(&'a self) -> Option<Cow<'a, KeyboardButtonRequestChat>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a \"chat_shared\" service message. Available in private chats only."]
    fn get_request_chat_ref<'a>(&'a self) -> Option<&KeyboardButtonRequestChat>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a \"chat_shared\" service message. Available in private chats only."]
    fn set_request_chat<'a>(
        &'a mut self,
        request_chat: Option<KeyboardButtonRequestChat>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."]
    fn get_request_contact<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."]
    fn get_request_contact_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."]
    fn set_request_contact<'a>(&'a mut self, request_contact: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."]
    fn get_request_location<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."]
    fn get_request_location_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."]
    fn set_request_location<'a>(&'a mut self, request_location: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."]
    fn get_request_poll<'a>(&'a self) -> Option<Cow<'a, KeyboardButtonPollType>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."]
    fn get_request_poll_ref<'a>(&'a self) -> Option<&KeyboardButtonPollType>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."]
    fn set_request_poll<'a>(
        &'a mut self,
        request_poll: Option<KeyboardButtonPollType>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a \"web_app_data\" service message. Available in private chats only."]
    fn get_web_app<'a>(&'a self) -> Option<Cow<'a, WebAppInfo>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a \"web_app_data\" service message. Available in private chats only."]
    fn get_web_app_ref<'a>(&'a self) -> Option<&WebAppInfo>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a \"web_app_data\" service message. Available in private chats only."]
    fn set_web_app<'a>(&'a mut self, web_app: Option<WebAppInfo>) -> &'a mut Self;
}
trait TraitChatMemberLeft {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user)"]
    fn into_tuple(self) -> User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self;
}
trait TraitBotCommand {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (command, description)"]
    fn into_tuple(self) -> (String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."]
    fn get_command<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."]
    fn get_command_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."]
    fn set_command<'a>(&'a mut self, command: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the command; 1-256 characters."]
    fn get_description<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the command; 1-256 characters."]
    fn get_description_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the command; 1-256 characters."]
    fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self;
}
trait TraitVenue {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (location, title, address, foursquare_id, foursquare_type, google_place_id, google_place_type)"]
    fn into_tuple(
        self,
    ) -> (
        Location,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Venue location. Can't be a live location"]
    fn get_location<'a>(&'a self) -> Cow<'a, Location>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Venue location. Can't be a live location"]
    fn get_location_ref<'a>(&'a self) -> &Location;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Venue location. Can't be a live location"]
    fn set_location<'a>(&'a mut self, location: Location) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn get_address<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn get_address_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn set_address<'a>(&'a mut self, address: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue"]
    fn get_foursquare_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue"]
    fn get_foursquare_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue"]
    fn set_foursquare_id<'a>(&'a mut self, foursquare_id: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn get_foursquare_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn get_foursquare_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn set_foursquare_type<'a>(&'a mut self, foursquare_type: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn get_google_place_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn get_google_place_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn set_google_place_id<'a>(&'a mut self, google_place_id: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn get_google_place_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn get_google_place_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn set_google_place_type<'a>(&'a mut self, google_place_type: Option<String>) -> &'a mut Self;
}
trait TraitPassportElementErrorSelfie {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    fn get_source<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    fn get_source_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    fn get_file_hash<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    fn get_file_hash_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self;
}
trait TraitForumTopicClosed {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitVideoNote {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, length, duration, thumbnail, file_size)"]
    fn into_tuple(self) -> (String, String, i64, i64, Option<PhotoSize>, Option<i64>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width and height (diameter of the video message) as defined by sender"]
    fn get_length<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width and height (diameter of the video message) as defined by sender"]
    fn get_length_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width and height (diameter of the video message) as defined by sender"]
    fn set_length<'a>(&'a mut self, length: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    fn get_duration<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    fn get_duration_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&PhotoSize>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    fn get_file_size<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    fn get_file_size_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self;
}
trait TraitInlineKeyboardMarkup {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (inline_keyboard)"]
    fn into_tuple(self) -> Vec<Vec<InlineKeyboardButton>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of InlineKeyboardButton objects"]
    fn get_inline_keyboard<'a>(&'a self) -> Cow<'a, Vec<Vec<InlineKeyboardButton>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of InlineKeyboardButton objects"]
    fn get_inline_keyboard_ref<'a>(&'a self) -> &Vec<Vec<InlineKeyboardButton>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of InlineKeyboardButton objects"]
    fn set_inline_keyboard<'a>(
        &'a mut self,
        inline_keyboard: Vec<Vec<InlineKeyboardButton>>,
    ) -> &'a mut Self;
}
trait TraitProximityAlertTriggered {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (traveler, watcher, distance)"]
    fn into_tuple(self) -> (User, User, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that triggered the alert"]
    fn get_traveler<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that triggered the alert"]
    fn get_traveler_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that triggered the alert"]
    fn set_traveler<'a>(&'a mut self, traveler: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that set the alert"]
    fn get_watcher<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that set the alert"]
    fn get_watcher_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that set the alert"]
    fn set_watcher<'a>(&'a mut self, watcher: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The distance between the users"]
    fn get_distance<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The distance between the users"]
    fn get_distance_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The distance between the users"]
    fn set_distance<'a>(&'a mut self, distance: i64) -> &'a mut Self;
}
trait TraitForumTopicCreated {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (name, icon_color, icon_custom_emoji_id)"]
    fn into_tuple(self) -> (String, i64, Option<String>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    fn get_name<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    fn get_name_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    fn set_name<'a>(&'a mut self, name: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    fn get_icon_color<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    fn get_icon_color_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    fn set_icon_color<'a>(&'a mut self, icon_color: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    fn get_icon_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    fn get_icon_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    fn set_icon_custom_emoji_id<'a>(
        &'a mut self,
        icon_custom_emoji_id: Option<String>,
    ) -> &'a mut Self;
}
trait TraitSticker {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, type, width, height, is_animated, is_video, thumbnail, emoji, set_name, premium_animation, mask_position, custom_emoji_id, needs_repainting, file_size)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        i64,
        i64,
        bool,
        bool,
        Option<PhotoSize>,
        Option<String>,
        Option<String>,
        Option<File>,
        Option<MaskPosition>,
        Option<String>,
        Option<bool>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the sticker, currently one of \"regular\", \"mask\", \"custom_emoji\". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video."]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the sticker, currently one of \"regular\", \"mask\", \"custom_emoji\". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video."]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the sticker, currently one of \"regular\", \"mask\", \"custom_emoji\". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video."]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker width"]
    fn get_width<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker width"]
    fn get_width_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker width"]
    fn set_width<'a>(&'a mut self, width: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker height"]
    fn get_height<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker height"]
    fn get_height_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker height"]
    fn set_height<'a>(&'a mut self, height: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is animated"]
    fn get_is_animated<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is animated"]
    fn get_is_animated_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is animated"]
    fn set_is_animated<'a>(&'a mut self, is_animated: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is a video sticker"]
    fn get_is_video<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is a video sticker"]
    fn get_is_video_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is a video sticker"]
    fn set_is_video<'a>(&'a mut self, is_video: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker thumbnail in the .WEBP or .JPG format"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker thumbnail in the .WEBP or .JPG format"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&PhotoSize>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker thumbnail in the .WEBP or .JPG format"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Emoji associated with the sticker"]
    fn get_emoji<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Emoji associated with the sticker"]
    fn get_emoji_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Emoji associated with the sticker"]
    fn set_emoji<'a>(&'a mut self, emoji: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the sticker set to which the sticker belongs"]
    fn get_set_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the sticker set to which the sticker belongs"]
    fn get_set_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the sticker set to which the sticker belongs"]
    fn set_set_name<'a>(&'a mut self, set_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For premium regular stickers, premium animation for the sticker"]
    fn get_premium_animation<'a>(&'a self) -> Option<Cow<'a, File>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For premium regular stickers, premium animation for the sticker"]
    fn get_premium_animation_ref<'a>(&'a self) -> Option<&File>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For premium regular stickers, premium animation for the sticker"]
    fn set_premium_animation<'a>(&'a mut self, premium_animation: Option<File>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For mask stickers, the position where the mask should be placed"]
    fn get_mask_position<'a>(&'a self) -> Option<Cow<'a, MaskPosition>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For mask stickers, the position where the mask should be placed"]
    fn get_mask_position_ref<'a>(&'a self) -> Option<&MaskPosition>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For mask stickers, the position where the mask should be placed"]
    fn set_mask_position<'a>(&'a mut self, mask_position: Option<MaskPosition>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For custom emoji stickers, unique identifier of the custom emoji"]
    fn get_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For custom emoji stickers, unique identifier of the custom emoji"]
    fn get_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For custom emoji stickers, unique identifier of the custom emoji"]
    fn set_custom_emoji_id<'a>(&'a mut self, custom_emoji_id: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"]
    fn get_needs_repainting<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"]
    fn get_needs_repainting_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"]
    fn set_needs_repainting<'a>(&'a mut self, needs_repainting: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    fn get_file_size<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    fn get_file_size_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self;
}
trait TraitInlineQueryResultContact {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, phone_number, first_name, last_name, vcard, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn get_phone_number<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn get_phone_number_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn set_phone_number<'a>(&'a mut self, phone_number: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn get_first_name<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn get_first_name_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn set_first_name<'a>(&'a mut self, first_name: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn get_last_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn get_vcard<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn get_vcard_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn set_vcard<'a>(&'a mut self, vcard: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self;
}
trait TraitMaskPosition {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (point, x_shift, y_shift, scale)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The part of the face relative to which the mask should be placed. One of \"forehead\", \"eyes\", \"mouth\", or \"chin\"."]
    fn get_point<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The part of the face relative to which the mask should be placed. One of \"forehead\", \"eyes\", \"mouth\", or \"chin\"."]
    fn get_point_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The part of the face relative to which the mask should be placed. One of \"forehead\", \"eyes\", \"mouth\", or \"chin\"."]
    fn set_point<'a>(&'a mut self, point: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."]
    fn get_x_shift<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."]
    fn get_x_shift_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."]
    fn set_x_shift<'a>(&'a mut self, x_shift: ::ordered_float::OrderedFloat<f64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."]
    fn get_y_shift<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."]
    fn get_y_shift_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."]
    fn set_y_shift<'a>(&'a mut self, y_shift: ::ordered_float::OrderedFloat<f64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Mask scaling coefficient. For example, 2.0 means double size."]
    fn get_scale<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Mask scaling coefficient. For example, 2.0 means double size."]
    fn get_scale_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Mask scaling coefficient. For example, 2.0 means double size."]
    fn set_scale<'a>(&'a mut self, scale: ::ordered_float::OrderedFloat<f64>) -> &'a mut Self;
}
trait TraitUserShared {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (request_id, user_id)"]
    fn into_tuple(self) -> (i64, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    fn get_request_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    fn get_request_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    fn set_request_id<'a>(&'a mut self, request_id: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."]
    fn get_user_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."]
    fn get_user_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."]
    fn set_user_id<'a>(&'a mut self, user_id: i64) -> &'a mut Self;
}
trait TraitBotCommandScopeAllChatAdministrators {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
}
trait TraitInputMediaAnimation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, width, height, duration, has_spoiler)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media_ref<'a>(&'a self) -> &Option<InputFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&InputFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    fn get_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    fn get_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    fn set_width<'a>(&'a mut self, width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    fn get_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    fn get_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    fn set_height<'a>(&'a mut self, height: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    fn get_duration<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    fn get_duration_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    fn set_duration<'a>(&'a mut self, duration: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    fn get_has_spoiler<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    fn get_has_spoiler_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    fn set_has_spoiler<'a>(&'a mut self, has_spoiler: Option<bool>) -> &'a mut Self;
}
trait TraitKeyboardButtonPollType {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> Option<String>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."]
    fn get_tg_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."]
    fn get_tg_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."]
    fn set_tg_type<'a>(&'a mut self, tg_type: Option<String>) -> &'a mut Self;
}
trait TraitChatJoinRequest {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (chat, from, user_chat_id, date, bio, invite_link)"]
    fn into_tuple(self) -> (Chat, User, i64, i64, Option<String>, Option<ChatInviteLink>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat to which the request was sent"]
    fn get_chat<'a>(&'a self) -> Cow<'a, Chat>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat to which the request was sent"]
    fn get_chat_ref<'a>(&'a self) -> &Chat;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat to which the request was sent"]
    fn set_chat<'a>(&'a mut self, chat: Chat) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that sent the join request"]
    fn get_from<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that sent the join request"]
    fn get_from_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that sent the join request"]
    fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    fn get_user_chat_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    fn get_user_chat_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    fn set_user_chat_id<'a>(&'a mut self, user_chat_id: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the request was sent in Unix time"]
    fn get_date<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the request was sent in Unix time"]
    fn get_date_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the request was sent in Unix time"]
    fn set_date<'a>(&'a mut self, date: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    fn get_bio<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    fn get_bio_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    fn set_bio<'a>(&'a mut self, bio: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    fn get_invite_link<'a>(&'a self) -> Option<Cow<'a, ChatInviteLink>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    fn get_invite_link_ref<'a>(&'a self) -> Option<&ChatInviteLink>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    fn set_invite_link<'a>(&'a mut self, invite_link: Option<ChatInviteLink>) -> &'a mut Self;
}
trait TraitInputFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitInlineQueryResultCachedDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, title, document_file_id, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    fn get_document_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    fn get_document_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    fn set_document_file_id<'a>(&'a mut self, document_file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitChatAdministratorRights {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (is_anonymous, can_manage_chat, can_delete_messages, can_manage_video_chats, can_restrict_members, can_promote_members, can_change_info, can_invite_users, can_post_messages, can_edit_messages, can_pin_messages, can_post_stories, can_edit_stories, can_delete_stories, can_manage_topics)"]
    fn into_tuple(
        self,
    ) -> (
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn get_is_anonymous<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn get_is_anonymous_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn set_is_anonymous<'a>(&'a mut self, is_anonymous: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    fn get_can_manage_chat<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    fn get_can_manage_chat_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    fn set_can_manage_chat<'a>(&'a mut self, can_manage_chat: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    fn get_can_delete_messages<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    fn get_can_delete_messages_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    fn set_can_delete_messages<'a>(&'a mut self, can_delete_messages: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    fn get_can_manage_video_chats<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    fn get_can_manage_video_chats_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    fn set_can_manage_video_chats<'a>(&'a mut self, can_manage_video_chats: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    fn get_can_restrict_members<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    fn get_can_restrict_members_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    fn set_can_restrict_members<'a>(&'a mut self, can_restrict_members: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    fn get_can_promote_members<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    fn get_can_promote_members_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    fn set_can_promote_members<'a>(&'a mut self, can_promote_members: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn get_can_change_info<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn get_can_change_info_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn set_can_change_info<'a>(&'a mut self, can_change_info: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn set_can_invite_users<'a>(&'a mut self, can_invite_users: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    fn get_can_post_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    fn get_can_post_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    fn set_can_post_messages<'a>(&'a mut self, can_post_messages: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    fn get_can_edit_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    fn get_can_edit_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    fn set_can_edit_messages<'a>(&'a mut self, can_edit_messages: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    fn get_can_pin_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    fn get_can_pin_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    fn set_can_pin_messages<'a>(&'a mut self, can_pin_messages: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    fn get_can_post_stories<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    fn get_can_post_stories_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    fn set_can_post_stories<'a>(&'a mut self, can_post_stories: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    fn get_can_edit_stories<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    fn get_can_edit_stories_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    fn set_can_edit_stories<'a>(&'a mut self, can_edit_stories: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    fn get_can_delete_stories<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    fn get_can_delete_stories_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    fn set_can_delete_stories<'a>(&'a mut self, can_delete_stories: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    fn get_can_manage_topics<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    fn get_can_manage_topics_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    fn set_can_manage_topics<'a>(&'a mut self, can_manage_topics: Option<bool>) -> &'a mut Self;
}
trait TraitVideoChatStarted {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitWebhookInfo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (url, has_custom_certificate, pending_update_count, ip_address, last_error_date, last_error_message, last_synchronization_error_date, max_connections, allowed_updates)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        bool,
        i64,
        Option<String>,
        Option<i64>,
        Option<String>,
        Option<i64>,
        Option<i64>,
        Option<Vec<String>>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Webhook URL, may be empty if webhook is not set up"]
    fn get_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Webhook URL, may be empty if webhook is not set up"]
    fn get_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Webhook URL, may be empty if webhook is not set up"]
    fn set_url<'a>(&'a mut self, url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if a custom certificate was provided for webhook certificate checks"]
    fn get_has_custom_certificate<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if a custom certificate was provided for webhook certificate checks"]
    fn get_has_custom_certificate_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if a custom certificate was provided for webhook certificate checks"]
    fn set_has_custom_certificate<'a>(&'a mut self, has_custom_certificate: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of updates awaiting delivery"]
    fn get_pending_update_count<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of updates awaiting delivery"]
    fn get_pending_update_count_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of updates awaiting delivery"]
    fn set_pending_update_count<'a>(&'a mut self, pending_update_count: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Currently used webhook IP address"]
    fn get_ip_address<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Currently used webhook IP address"]
    fn get_ip_address_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Currently used webhook IP address"]
    fn set_ip_address<'a>(&'a mut self, ip_address: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"]
    fn get_last_error_date<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"]
    fn get_last_error_date_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"]
    fn set_last_error_date<'a>(&'a mut self, last_error_date: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"]
    fn get_last_error_message<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"]
    fn get_last_error_message_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"]
    fn set_last_error_message<'a>(&'a mut self, last_error_message: Option<String>)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"]
    fn get_last_synchronization_error_date<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"]
    fn get_last_synchronization_error_date_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"]
    fn set_last_synchronization_error_date<'a>(
        &'a mut self,
        last_synchronization_error_date: Option<i64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"]
    fn get_max_connections<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"]
    fn get_max_connections_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"]
    fn set_max_connections<'a>(&'a mut self, max_connections: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"]
    fn get_allowed_updates<'a>(&'a self) -> Option<Cow<'a, Vec<String>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"]
    fn get_allowed_updates_ref<'a>(&'a self) -> Option<&Vec<String>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"]
    fn set_allowed_updates<'a>(&'a mut self, allowed_updates: Option<Vec<String>>) -> &'a mut Self;
}
trait TraitWebAppData {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (data, button_text)"]
    fn into_tuple(self) -> (String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The data. Be aware that a bad client can send arbitrary data in this field."]
    fn get_data<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The data. Be aware that a bad client can send arbitrary data in this field."]
    fn get_data_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The data. Be aware that a bad client can send arbitrary data in this field."]
    fn set_data<'a>(&'a mut self, data: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."]
    fn get_button_text<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."]
    fn get_button_text_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."]
    fn set_button_text<'a>(&'a mut self, button_text: String) -> &'a mut Self;
}
trait TraitInlineQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, from, query, offset, chat_type, location)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        User,
        String,
        String,
        Option<String>,
        Option<Location>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    fn get_from<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    fn get_from_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the query (up to 256 characters)"]
    fn get_query<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the query (up to 256 characters)"]
    fn get_query_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the query (up to 256 characters)"]
    fn set_query<'a>(&'a mut self, query: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    fn get_offset<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    fn get_offset_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    fn set_offset<'a>(&'a mut self, offset: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    fn get_chat_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    fn get_chat_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    fn set_chat_type<'a>(&'a mut self, chat_type: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that request user location"]
    fn get_location<'a>(&'a self) -> Option<Cow<'a, Location>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that request user location"]
    fn get_location_ref<'a>(&'a self) -> Option<&Location>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that request user location"]
    fn set_location<'a>(&'a mut self, location: Option<Location>) -> &'a mut Self;
}
trait TraitPassportFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, file_size, file_date)"]
    fn into_tuple(self) -> (String, String, i64, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File size in bytes"]
    fn get_file_size<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File size in bytes"]
    fn get_file_size_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File size in bytes"]
    fn set_file_size<'a>(&'a mut self, file_size: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unix time when the file was uploaded"]
    fn get_file_date<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unix time when the file was uploaded"]
    fn get_file_date_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unix time when the file was uploaded"]
    fn set_file_date<'a>(&'a mut self, file_date: i64) -> &'a mut Self;
}
trait TraitInlineQueryResultCachedSticker {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, sticker_file_id, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    fn get_sticker_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    fn get_sticker_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    fn set_sticker_file_id<'a>(&'a mut self, sticker_file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitAnimation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, width, height, duration, thumbnail, file_name, mime_type, file_size)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        i64,
        i64,
        i64,
        Option<PhotoSize>,
        Option<String>,
        Option<String>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    fn get_width<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    fn get_width_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    fn set_width<'a>(&'a mut self, width: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    fn get_height<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    fn get_height_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    fn set_height<'a>(&'a mut self, height: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    fn get_duration<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    fn get_duration_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation thumbnail as defined by sender"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation thumbnail as defined by sender"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&PhotoSize>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation thumbnail as defined by sender"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original animation filename as defined by sender"]
    fn get_file_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original animation filename as defined by sender"]
    fn get_file_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original animation filename as defined by sender"]
    fn set_file_name<'a>(&'a mut self, file_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn get_mime_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn get_mime_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn set_mime_type<'a>(&'a mut self, mime_type: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self;
}
trait TraitChatPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (small_file_id, small_file_unique_id, big_file_id, big_file_unique_id)"]
    fn into_tuple(self) -> (String, String, String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    fn get_small_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    fn get_small_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    fn set_small_file_id<'a>(&'a mut self, small_file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_small_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_small_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_small_file_unique_id<'a>(&'a mut self, small_file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    fn get_big_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    fn get_big_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    fn set_big_file_id<'a>(&'a mut self, big_file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_big_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_big_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_big_file_unique_id<'a>(&'a mut self, big_file_unique_id: String) -> &'a mut Self;
}
trait TraitStickerSet {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (name, title, sticker_type, is_animated, is_video, stickers, thumbnail)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        bool,
        bool,
        Vec<Sticker>,
        Option<PhotoSize>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set name"]
    fn get_name<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set name"]
    fn get_name_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set name"]
    fn set_name<'a>(&'a mut self, name: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set title"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set title"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set title"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of stickers in the set, currently one of \"regular\", \"mask\", \"custom_emoji\""]
    fn get_sticker_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of stickers in the set, currently one of \"regular\", \"mask\", \"custom_emoji\""]
    fn get_sticker_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of stickers in the set, currently one of \"regular\", \"mask\", \"custom_emoji\""]
    fn set_sticker_type<'a>(&'a mut self, sticker_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains animated stickers"]
    fn get_is_animated<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains animated stickers"]
    fn get_is_animated_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains animated stickers"]
    fn set_is_animated<'a>(&'a mut self, is_animated: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains video stickers"]
    fn get_is_video<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains video stickers"]
    fn get_is_video_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains video stickers"]
    fn set_is_video<'a>(&'a mut self, is_video: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of all set stickers"]
    fn get_stickers<'a>(&'a self) -> Cow<'a, Vec<Sticker>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of all set stickers"]
    fn get_stickers_ref<'a>(&'a self) -> &Vec<Sticker>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of all set stickers"]
    fn set_stickers<'a>(&'a mut self, stickers: Vec<Sticker>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&PhotoSize>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self;
}
trait TraitInputVenueMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (latitude, longitude, title, address, foursquare_id, foursquare_type, google_place_id, google_place_type)"]
    fn into_tuple(
        self,
    ) -> (
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    fn set_latitude<'a>(&'a mut self, latitude: ::ordered_float::OrderedFloat<f64>)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn get_address<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn get_address_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn set_address<'a>(&'a mut self, address: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    fn get_foursquare_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    fn get_foursquare_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    fn set_foursquare_id<'a>(&'a mut self, foursquare_id: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn get_foursquare_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn get_foursquare_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn set_foursquare_type<'a>(&'a mut self, foursquare_type: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn get_google_place_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn get_google_place_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn set_google_place_id<'a>(&'a mut self, google_place_id: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn get_google_place_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn get_google_place_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn set_google_place_type<'a>(&'a mut self, google_place_type: Option<String>) -> &'a mut Self;
}
trait TraitPassportElementErrorFiles {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hashes, message)"]
    fn into_tuple(self) -> (String, String, Vec<String>, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    fn get_source<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    fn get_source_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn get_file_hashes<'a>(&'a self) -> Cow<'a, Vec<String>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn get_file_hashes_ref<'a>(&'a self) -> &Vec<String>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn set_file_hashes<'a>(&'a mut self, file_hashes: Vec<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self;
}
trait TraitBotCommandScopeChatAdministrators {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, chat_id)"]
    fn into_tuple(self) -> (String, ::ordered_float::OrderedFloat<f64>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn set_chat_id<'a>(&'a mut self, chat_id: ::ordered_float::OrderedFloat<f64>) -> &'a mut Self;
}
trait TraitInlineQueryResultCachedPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, photo_file_id, title, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    fn get_photo_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    fn get_photo_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    fn set_photo_file_id<'a>(&'a mut self, photo_file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitInputInvoiceMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (title, description, payload, provider_token, currency, prices, max_tip_amount, suggested_tip_amounts, provider_data, photo_url, photo_size, photo_width, photo_height, need_name, need_phone_number, need_email, need_shipping_address, send_phone_number_to_provider, send_email_to_provider, is_flexible)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        Vec<LabeledPrice>,
        Option<i64>,
        Option<Vec<i64>>,
        Option<String>,
        Option<String>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    fn get_description<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    fn get_description_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    fn get_payload<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    fn get_payload_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    fn set_payload<'a>(&'a mut self, payload: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    fn get_provider_token<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    fn get_provider_token_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    fn set_provider_token<'a>(&'a mut self, provider_token: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    fn get_currency<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    fn get_currency_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    fn set_currency<'a>(&'a mut self, currency: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    fn get_prices<'a>(&'a self) -> Cow<'a, Vec<LabeledPrice>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    fn get_prices_ref<'a>(&'a self) -> &Vec<LabeledPrice>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    fn set_prices<'a>(&'a mut self, prices: Vec<LabeledPrice>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    fn get_max_tip_amount<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    fn get_max_tip_amount_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    fn set_max_tip_amount<'a>(&'a mut self, max_tip_amount: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    fn get_suggested_tip_amounts<'a>(&'a self) -> Option<Cow<'a, Vec<i64>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    fn get_suggested_tip_amounts_ref<'a>(&'a self) -> Option<&Vec<i64>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    fn set_suggested_tip_amounts<'a>(
        &'a mut self,
        suggested_tip_amounts: Option<Vec<i64>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    fn get_provider_data<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    fn get_provider_data_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    fn set_provider_data<'a>(&'a mut self, provider_data: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    fn get_photo_url<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    fn get_photo_url_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    fn set_photo_url<'a>(&'a mut self, photo_url: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    fn get_photo_size<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    fn get_photo_size_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    fn set_photo_size<'a>(&'a mut self, photo_size: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    fn get_photo_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    fn get_photo_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    fn set_photo_width<'a>(&'a mut self, photo_width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    fn get_photo_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    fn get_photo_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    fn set_photo_height<'a>(&'a mut self, photo_height: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    fn get_need_name<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    fn get_need_name_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    fn set_need_name<'a>(&'a mut self, need_name: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    fn get_need_phone_number<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    fn get_need_phone_number_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    fn set_need_phone_number<'a>(&'a mut self, need_phone_number: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    fn get_need_email<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    fn get_need_email_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    fn set_need_email<'a>(&'a mut self, need_email: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    fn get_need_shipping_address<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    fn get_need_shipping_address_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    fn set_need_shipping_address<'a>(
        &'a mut self,
        need_shipping_address: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    fn get_send_phone_number_to_provider<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    fn get_send_phone_number_to_provider_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    fn set_send_phone_number_to_provider<'a>(
        &'a mut self,
        send_phone_number_to_provider: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    fn get_send_email_to_provider<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    fn get_send_email_to_provider_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    fn set_send_email_to_provider<'a>(
        &'a mut self,
        send_email_to_provider: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    fn get_is_flexible<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    fn get_is_flexible_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    fn set_is_flexible<'a>(&'a mut self, is_flexible: Option<bool>) -> &'a mut Self;
}
trait TraitChatMemberMember {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user)"]
    fn into_tuple(self) -> User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self;
}
trait TraitForceReply {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (force_reply, input_field_placeholder, selective)"]
    fn into_tuple(self) -> (bool, Option<String>, Option<bool>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"]
    fn get_force_reply<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"]
    fn get_force_reply_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"]
    fn set_force_reply<'a>(&'a mut self, force_reply: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"]
    fn get_input_field_placeholder<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"]
    fn get_input_field_placeholder_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"]
    fn set_input_field_placeholder<'a>(
        &'a mut self,
        input_field_placeholder: Option<String>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."]
    fn get_selective<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."]
    fn get_selective_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."]
    fn set_selective<'a>(&'a mut self, selective: Option<bool>) -> &'a mut Self;
}
trait TraitMenuButtonWebApp {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, text, web_app)"]
    fn into_tuple(self) -> (String, String, WebAppInfo);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    fn get_text<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    fn get_text_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    fn get_web_app<'a>(&'a self) -> Cow<'a, WebAppInfo>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    fn get_web_app_ref<'a>(&'a self) -> &WebAppInfo;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    fn set_web_app<'a>(&'a mut self, web_app: WebAppInfo) -> &'a mut Self;
}
trait TraitUpdate {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (update_id, message, edited_message, channel_post, edited_channel_post, inline_query, chosen_inline_result, callback_query, shipping_query, pre_checkout_query, poll, poll_answer, my_chat_member, chat_member, chat_join_request)"]
    fn into_tuple(
        self,
    ) -> (
        i64,
        Option<Message>,
        Option<Message>,
        Option<Message>,
        Option<Message>,
        Option<InlineQuery>,
        Option<ChosenInlineResult>,
        Option<CallbackQuery>,
        Option<ShippingQuery>,
        Option<PreCheckoutQuery>,
        Option<Poll>,
        Option<PollAnswer>,
        Option<ChatMemberUpdated>,
        Option<ChatMemberUpdated>,
        Option<ChatJoinRequest>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."]
    fn get_update_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."]
    fn get_update_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."]
    fn set_update_id<'a>(&'a mut self, update_id: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming message of any kind - text, photo, sticker, etc."]
    fn get_message<'a>(&'a self) -> Option<Cow<'a, Message>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming message of any kind - text, photo, sticker, etc."]
    fn get_message_ref<'a>(&'a self) -> Option<&Message>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming message of any kind - text, photo, sticker, etc."]
    fn set_message<'a>(&'a mut self, message: Option<Message>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a message that is known to the bot and was edited"]
    fn get_edited_message<'a>(&'a self) -> Option<Cow<'a, Message>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a message that is known to the bot and was edited"]
    fn get_edited_message_ref<'a>(&'a self) -> Option<&Message>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a message that is known to the bot and was edited"]
    fn set_edited_message<'a>(&'a mut self, edited_message: Option<Message>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming channel post of any kind - text, photo, sticker, etc."]
    fn get_channel_post<'a>(&'a self) -> Option<Cow<'a, Message>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming channel post of any kind - text, photo, sticker, etc."]
    fn get_channel_post_ref<'a>(&'a self) -> Option<&Message>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming channel post of any kind - text, photo, sticker, etc."]
    fn set_channel_post<'a>(&'a mut self, channel_post: Option<Message>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a channel post that is known to the bot and was edited"]
    fn get_edited_channel_post<'a>(&'a self) -> Option<Cow<'a, Message>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a channel post that is known to the bot and was edited"]
    fn get_edited_channel_post_ref<'a>(&'a self) -> Option<&Message>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a channel post that is known to the bot and was edited"]
    fn set_edited_channel_post<'a>(
        &'a mut self,
        edited_channel_post: Option<Message>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming inline query"]
    fn get_inline_query<'a>(&'a self) -> Option<Cow<'a, InlineQuery>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming inline query"]
    fn get_inline_query_ref<'a>(&'a self) -> Option<&InlineQuery>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming inline query"]
    fn set_inline_query<'a>(&'a mut self, inline_query: Option<InlineQuery>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."]
    fn get_chosen_inline_result<'a>(&'a self) -> Option<Cow<'a, ChosenInlineResult>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."]
    fn get_chosen_inline_result_ref<'a>(&'a self) -> Option<&ChosenInlineResult>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."]
    fn set_chosen_inline_result<'a>(
        &'a mut self,
        chosen_inline_result: Option<ChosenInlineResult>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming callback query"]
    fn get_callback_query<'a>(&'a self) -> Option<Cow<'a, CallbackQuery>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming callback query"]
    fn get_callback_query_ref<'a>(&'a self) -> Option<&CallbackQuery>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming callback query"]
    fn set_callback_query<'a>(&'a mut self, callback_query: Option<CallbackQuery>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming shipping query. Only for invoices with flexible price"]
    fn get_shipping_query<'a>(&'a self) -> Option<Cow<'a, ShippingQuery>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming shipping query. Only for invoices with flexible price"]
    fn get_shipping_query_ref<'a>(&'a self) -> Option<&ShippingQuery>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming shipping query. Only for invoices with flexible price"]
    fn set_shipping_query<'a>(&'a mut self, shipping_query: Option<ShippingQuery>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming pre-checkout query. Contains full information about checkout"]
    fn get_pre_checkout_query<'a>(&'a self) -> Option<Cow<'a, PreCheckoutQuery>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming pre-checkout query. Contains full information about checkout"]
    fn get_pre_checkout_query_ref<'a>(&'a self) -> Option<&PreCheckoutQuery>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming pre-checkout query. Contains full information about checkout"]
    fn set_pre_checkout_query<'a>(
        &'a mut self,
        pre_checkout_query: Option<PreCheckoutQuery>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"]
    fn get_poll<'a>(&'a self) -> Option<Cow<'a, Poll>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"]
    fn get_poll_ref<'a>(&'a self) -> Option<&Poll>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"]
    fn set_poll<'a>(&'a mut self, poll: Option<Poll>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."]
    fn get_poll_answer<'a>(&'a self) -> Option<Cow<'a, PollAnswer>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."]
    fn get_poll_answer_ref<'a>(&'a self) -> Option<&PollAnswer>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."]
    fn set_poll_answer<'a>(&'a mut self, poll_answer: Option<PollAnswer>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."]
    fn get_my_chat_member<'a>(&'a self) -> Option<Cow<'a, ChatMemberUpdated>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."]
    fn get_my_chat_member_ref<'a>(&'a self) -> Option<&ChatMemberUpdated>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."]
    fn set_my_chat_member<'a>(
        &'a mut self,
        my_chat_member: Option<ChatMemberUpdated>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify \"chat_member\" in the list of allowed_updates to receive these updates."]
    fn get_chat_member<'a>(&'a self) -> Option<Cow<'a, ChatMemberUpdated>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify \"chat_member\" in the list of allowed_updates to receive these updates."]
    fn get_chat_member_ref<'a>(&'a self) -> Option<&ChatMemberUpdated>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify \"chat_member\" in the list of allowed_updates to receive these updates."]
    fn set_chat_member<'a>(&'a mut self, chat_member: Option<ChatMemberUpdated>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."]
    fn get_chat_join_request<'a>(&'a self) -> Option<Cow<'a, ChatJoinRequest>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."]
    fn get_chat_join_request_ref<'a>(&'a self) -> Option<&ChatJoinRequest>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."]
    fn set_chat_join_request<'a>(
        &'a mut self,
        chat_join_request: Option<ChatJoinRequest>,
    ) -> &'a mut Self;
}
trait TraitMenuButtonCommands {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
}
trait TraitChatMemberRestricted {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, is_member, can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, can_send_voice_notes, can_send_polls, can_send_other_messages, can_add_web_page_previews, can_change_info, can_invite_users, can_pin_messages, can_manage_topics, until_date)"]
    fn into_tuple(
        self,
    ) -> (
        User,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        i64,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    fn get_is_member<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    fn get_is_member_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    fn set_is_member<'a>(&'a mut self, is_member: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    fn get_can_send_messages<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    fn get_can_send_messages_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    fn set_can_send_messages<'a>(&'a mut self, can_send_messages: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    fn get_can_send_audios<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    fn get_can_send_audios_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    fn set_can_send_audios<'a>(&'a mut self, can_send_audios: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    fn get_can_send_documents<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    fn get_can_send_documents_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    fn set_can_send_documents<'a>(&'a mut self, can_send_documents: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    fn get_can_send_photos<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    fn get_can_send_photos_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    fn set_can_send_photos<'a>(&'a mut self, can_send_photos: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    fn get_can_send_videos<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    fn get_can_send_videos_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    fn set_can_send_videos<'a>(&'a mut self, can_send_videos: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    fn get_can_send_video_notes<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    fn get_can_send_video_notes_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    fn set_can_send_video_notes<'a>(&'a mut self, can_send_video_notes: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    fn get_can_send_voice_notes<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    fn get_can_send_voice_notes_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    fn set_can_send_voice_notes<'a>(&'a mut self, can_send_voice_notes: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    fn get_can_send_polls<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    fn get_can_send_polls_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    fn set_can_send_polls<'a>(&'a mut self, can_send_polls: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    fn get_can_send_other_messages<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    fn get_can_send_other_messages_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    fn set_can_send_other_messages<'a>(&'a mut self, can_send_other_messages: bool)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    fn get_can_add_web_page_previews<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    fn get_can_add_web_page_previews_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    fn set_can_add_web_page_previews<'a>(
        &'a mut self,
        can_add_web_page_previews: bool,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn get_can_change_info<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn get_can_change_info_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn set_can_change_info<'a>(&'a mut self, can_change_info: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn set_can_invite_users<'a>(&'a mut self, can_invite_users: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    fn get_can_pin_messages<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    fn get_can_pin_messages_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    fn set_can_pin_messages<'a>(&'a mut self, can_pin_messages: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    fn get_can_manage_topics<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    fn get_can_manage_topics_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    fn set_can_manage_topics<'a>(&'a mut self, can_manage_topics: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    fn get_until_date<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    fn get_until_date_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    fn set_until_date<'a>(&'a mut self, until_date: i64) -> &'a mut Self;
}
trait TraitInlineQueryResultArticle {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, title, input_message_content, reply_markup, url, hide_url, description, thumbnail_url, thumbnail_width, thumbnail_height)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        InputMessageContent,
        Option<InlineKeyboardMarkup>,
        Option<String>,
        Option<bool>,
        Option<String>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    fn get_input_message_content<'a>(&'a self) -> Cow<'a, InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    fn get_input_message_content_ref<'a>(&'a self) -> &InputMessageContent;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: InputMessageContent,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    fn get_url<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    fn get_url_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    fn set_url<'a>(&'a mut self, url: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    fn get_hide_url<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    fn get_hide_url_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    fn set_hide_url<'a>(&'a mut self, hide_url: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self;
}
trait TraitPassportElementError:
    TraitPassportElementErrorDataField
    + TraitPassportElementErrorFrontSide
    + TraitPassportElementErrorReverseSide
    + TraitPassportElementErrorSelfie
    + TraitPassportElementErrorFile
    + TraitPassportElementErrorFiles
    + TraitPassportElementErrorTranslationFile
    + TraitPassportElementErrorTranslationFiles
    + TraitPassportElementErrorUnspecified
{
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitGeneralForumTopicHidden {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitSentWebAppMessage {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (inline_message_id)"]
    fn into_tuple(self) -> Option<String>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."]
    fn get_inline_message_id<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."]
    fn get_inline_message_id_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."]
    fn set_inline_message_id<'a>(&'a mut self, inline_message_id: Option<String>) -> &'a mut Self;
}
trait TraitVideoChatParticipantsInvited {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (users)"]
    fn into_tuple(self) -> Vec<User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New members that were invited to the video chat"]
    fn get_users<'a>(&'a self) -> Cow<'a, Vec<User>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New members that were invited to the video chat"]
    fn get_users_ref<'a>(&'a self) -> &Vec<User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New members that were invited to the video chat"]
    fn set_users<'a>(&'a mut self, users: Vec<User>) -> &'a mut Self;
}
trait TraitInlineKeyboardButton {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (text, url, callback_data, web_app, login_url, switch_inline_query, switch_inline_query_current_chat, switch_inline_query_chosen_chat, callback_game, pay)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<String>,
        Option<String>,
        Option<WebAppInfo>,
        Option<LoginUrl>,
        Option<String>,
        Option<String>,
        Option<SwitchInlineQueryChosenChat>,
        Option<CallbackGame>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    fn get_text<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    fn get_text_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."]
    fn get_url<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."]
    fn get_url_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."]
    fn set_url<'a>(&'a mut self, url: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"]
    fn get_callback_data<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"]
    fn get_callback_data_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"]
    fn set_callback_data<'a>(&'a mut self, callback_data: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."]
    fn get_web_app<'a>(&'a self) -> Option<Cow<'a, WebAppInfo>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."]
    fn get_web_app_ref<'a>(&'a self) -> Option<&WebAppInfo>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."]
    fn set_web_app<'a>(&'a mut self, web_app: Option<WebAppInfo>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."]
    fn get_login_url<'a>(&'a self) -> Option<Cow<'a, LoginUrl>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."]
    fn get_login_url_ref<'a>(&'a self) -> Option<&LoginUrl>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."]
    fn set_login_url<'a>(&'a mut self, login_url: Option<LoginUrl>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."]
    fn get_switch_inline_query<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."]
    fn get_switch_inline_query_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."]
    fn set_switch_inline_query<'a>(
        &'a mut self,
        switch_inline_query: Option<String>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."]
    fn get_switch_inline_query_current_chat<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."]
    fn get_switch_inline_query_current_chat_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."]
    fn set_switch_inline_query_current_chat<'a>(
        &'a mut self,
        switch_inline_query_current_chat: Option<String>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"]
    fn get_switch_inline_query_chosen_chat<'a>(
        &'a self,
    ) -> Option<Cow<'a, SwitchInlineQueryChosenChat>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"]
    fn get_switch_inline_query_chosen_chat_ref<'a>(
        &'a self,
    ) -> Option<&SwitchInlineQueryChosenChat>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"]
    fn set_switch_inline_query_chosen_chat<'a>(
        &'a mut self,
        switch_inline_query_chosen_chat: Option<SwitchInlineQueryChosenChat>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."]
    fn get_callback_game<'a>(&'a self) -> Option<Cow<'a, CallbackGame>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."]
    fn get_callback_game_ref<'a>(&'a self) -> Option<&CallbackGame>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."]
    fn set_callback_game<'a>(&'a mut self, callback_game: Option<CallbackGame>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."]
    fn get_pay<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."]
    fn get_pay_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."]
    fn set_pay<'a>(&'a mut self, pay: Option<bool>) -> &'a mut Self;
}
trait TraitInlineQueryResult:
    TraitInlineQueryResultCachedAudio
    + TraitInlineQueryResultCachedDocument
    + TraitInlineQueryResultCachedGif
    + TraitInlineQueryResultCachedMpeg4Gif
    + TraitInlineQueryResultCachedPhoto
    + TraitInlineQueryResultCachedSticker
    + TraitInlineQueryResultCachedVideo
    + TraitInlineQueryResultCachedVoice
    + TraitInlineQueryResultArticle
    + TraitInlineQueryResultAudio
    + TraitInlineQueryResultContact
    + TraitInlineQueryResultGame
    + TraitInlineQueryResultDocument
    + TraitInlineQueryResultGif
    + TraitInlineQueryResultLocation
    + TraitInlineQueryResultMpeg4Gif
    + TraitInlineQueryResultPhoto
    + TraitInlineQueryResultVenue
    + TraitInlineQueryResultVideo
    + TraitInlineQueryResultVoice
{
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitChatShared {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (request_id, chat_id)"]
    fn into_tuple(self) -> (i64, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    fn get_request_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    fn get_request_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    fn set_request_id<'a>(&'a mut self, request_id: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."]
    fn get_chat_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."]
    fn get_chat_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."]
    fn set_chat_id<'a>(&'a mut self, chat_id: i64) -> &'a mut Self;
}
trait TraitInlineQueryResultMpeg4Gif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, mpeg4_url, mpeg4_width, mpeg4_height, mpeg4_duration, thumbnail_url, thumbnail_mime_type, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    fn get_mpeg_4_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    fn get_mpeg_4_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    fn set_mpeg_4_url<'a>(&'a mut self, mpeg_4_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_mpeg_4_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_mpeg_4_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn set_mpeg_4_width<'a>(&'a mut self, mpeg_4_width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_mpeg_4_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_mpeg_4_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn set_mpeg_4_height<'a>(&'a mut self, mpeg_4_height: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_mpeg_4_duration<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_mpeg_4_duration_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn set_mpeg_4_duration<'a>(&'a mut self, mpeg_4_duration: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn get_thumbnail_mime_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn get_thumbnail_mime_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn set_thumbnail_mime_type<'a>(
        &'a mut self,
        thumbnail_mime_type: Option<String>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitShippingAddress {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (country_code, state, city, street_line1, street_line2, post_code)"]
    fn into_tuple(self) -> (String, String, String, String, String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Two-letter ISO 3166-1 alpha-2 country code"]
    fn get_country_code<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Two-letter ISO 3166-1 alpha-2 country code"]
    fn get_country_code_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Two-letter ISO 3166-1 alpha-2 country code"]
    fn set_country_code<'a>(&'a mut self, country_code: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "State, if applicable"]
    fn get_state<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "State, if applicable"]
    fn get_state_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "State, if applicable"]
    fn set_state<'a>(&'a mut self, state: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "City"]
    fn get_city<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "City"]
    fn get_city_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "City"]
    fn set_city<'a>(&'a mut self, city: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "First line for the address"]
    fn get_street_line_1<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "First line for the address"]
    fn get_street_line_1_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "First line for the address"]
    fn set_street_line_1<'a>(&'a mut self, street_line_1: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Second line for the address"]
    fn get_street_line_2<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Second line for the address"]
    fn get_street_line_2_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Second line for the address"]
    fn set_street_line_2<'a>(&'a mut self, street_line_2: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address post code"]
    fn get_post_code<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address post code"]
    fn get_post_code_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address post code"]
    fn set_post_code<'a>(&'a mut self, post_code: String) -> &'a mut Self;
}
trait TraitPassportElementErrorDataField {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, field_name, data_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    fn get_source<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    fn get_source_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    fn get_field_name<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    fn get_field_name_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    fn set_field_name<'a>(&'a mut self, field_name: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    fn get_data_hash<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    fn get_data_hash_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    fn set_data_hash<'a>(&'a mut self, data_hash: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self;
}
trait TraitDice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (emoji, value)"]
    fn into_tuple(self) -> (String, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Emoji on which the dice throw animation is based"]
    fn get_emoji<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Emoji on which the dice throw animation is based"]
    fn get_emoji_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Emoji on which the dice throw animation is based"]
    fn set_emoji<'a>(&'a mut self, emoji: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Value of the dice, 1-6 for \"\", \"\" and \"\" base emoji, 1-5 for \"\" and \"\" base emoji, 1-64 for \"\" base emoji"]
    fn get_value<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Value of the dice, 1-6 for \"\", \"\" and \"\" base emoji, 1-5 for \"\" and \"\" base emoji, 1-64 for \"\" base emoji"]
    fn get_value_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Value of the dice, 1-6 for \"\", \"\" and \"\" base emoji, 1-5 for \"\" and \"\" base emoji, 1-64 for \"\" base emoji"]
    fn set_value<'a>(&'a mut self, value: i64) -> &'a mut Self;
}
trait TraitPassportElementErrorTranslationFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    fn get_source<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    fn get_source_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn get_file_hash<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn get_file_hash_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self;
}
trait TraitVideoChatScheduled {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (start_date)"]
    fn into_tuple(self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"]
    fn get_start_date<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"]
    fn get_start_date_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"]
    fn set_start_date<'a>(&'a mut self, start_date: i64) -> &'a mut Self;
}
trait TraitShippingOption {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, title, prices)"]
    fn into_tuple(self) -> (String, String, Vec<LabeledPrice>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shipping option identifier"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shipping option identifier"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shipping option identifier"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option title"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option title"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option title"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of price portions"]
    fn get_prices<'a>(&'a self) -> Cow<'a, Vec<LabeledPrice>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of price portions"]
    fn get_prices_ref<'a>(&'a self) -> &Vec<LabeledPrice>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of price portions"]
    fn set_prices<'a>(&'a mut self, prices: Vec<LabeledPrice>) -> &'a mut Self;
}
trait TraitWebAppInfo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (url)"]
    fn into_tuple(self) -> String;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"]
    fn get_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"]
    fn get_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"]
    fn set_url<'a>(&'a mut self, url: String) -> &'a mut Self;
}
trait TraitChatMemberBanned {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, until_date)"]
    fn into_tuple(self) -> (User, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    fn get_until_date<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    fn get_until_date_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    fn set_until_date<'a>(&'a mut self, until_date: i64) -> &'a mut Self;
}
trait TraitBotCommandScopeDefault {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
}
trait TraitPassportData {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (data, credentials)"]
    fn into_tuple(self) -> (Vec<EncryptedPassportElement>, EncryptedCredentials);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array with information about documents and other Telegram Passport elements that was shared with the bot"]
    fn get_data<'a>(&'a self) -> Cow<'a, Vec<EncryptedPassportElement>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array with information about documents and other Telegram Passport elements that was shared with the bot"]
    fn get_data_ref<'a>(&'a self) -> &Vec<EncryptedPassportElement>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array with information about documents and other Telegram Passport elements that was shared with the bot"]
    fn set_data<'a>(&'a mut self, data: Vec<EncryptedPassportElement>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Encrypted credentials required to decrypt the data"]
    fn get_credentials<'a>(&'a self) -> Cow<'a, EncryptedCredentials>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Encrypted credentials required to decrypt the data"]
    fn get_credentials_ref<'a>(&'a self) -> &EncryptedCredentials;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Encrypted credentials required to decrypt the data"]
    fn set_credentials<'a>(&'a mut self, credentials: EncryptedCredentials) -> &'a mut Self;
}
trait TraitInputSticker {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (sticker, emoji_list, mask_position, keywords)"]
    fn into_tuple(
        self,
    ) -> (
        InputFile,
        Vec<String>,
        Option<MaskPosition>,
        Option<Vec<String>>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_sticker<'a>(&'a self) -> Cow<'a, InputFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_sticker_ref<'a>(&'a self) -> &InputFile;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_sticker<'a>(&'a mut self, sticker: InputFile) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of 1-20 emoji associated with the sticker"]
    fn get_emoji_list<'a>(&'a self) -> Cow<'a, Vec<String>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of 1-20 emoji associated with the sticker"]
    fn get_emoji_list_ref<'a>(&'a self) -> &Vec<String>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of 1-20 emoji associated with the sticker"]
    fn set_emoji_list<'a>(&'a mut self, emoji_list: Vec<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Position where the mask should be placed on faces. For \"mask\" stickers only."]
    fn get_mask_position<'a>(&'a self) -> Option<Cow<'a, MaskPosition>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Position where the mask should be placed on faces. For \"mask\" stickers only."]
    fn get_mask_position_ref<'a>(&'a self) -> Option<&MaskPosition>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Position where the mask should be placed on faces. For \"mask\" stickers only."]
    fn set_mask_position<'a>(&'a mut self, mask_position: Option<MaskPosition>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For \"regular\" and \"custom_emoji\" stickers only."]
    fn get_keywords<'a>(&'a self) -> Option<Cow<'a, Vec<String>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For \"regular\" and \"custom_emoji\" stickers only."]
    fn get_keywords_ref<'a>(&'a self) -> Option<&Vec<String>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For \"regular\" and \"custom_emoji\" stickers only."]
    fn set_keywords<'a>(&'a mut self, keywords: Option<Vec<String>>) -> &'a mut Self;
}
trait TraitChatLocation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (location, address)"]
    fn into_tuple(self) -> (Location, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The location to which the supergroup is connected. Can't be a live location."]
    fn get_location<'a>(&'a self) -> Cow<'a, Location>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The location to which the supergroup is connected. Can't be a live location."]
    fn get_location_ref<'a>(&'a self) -> &Location;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The location to which the supergroup is connected. Can't be a live location."]
    fn set_location<'a>(&'a mut self, location: Location) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location address; 1-64 characters, as defined by the chat owner"]
    fn get_address<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location address; 1-64 characters, as defined by the chat owner"]
    fn get_address_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location address; 1-64 characters, as defined by the chat owner"]
    fn set_address<'a>(&'a mut self, address: String) -> &'a mut Self;
}
trait TraitCallbackGame {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitInlineQueryResultGif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, gif_url, gif_width, gif_height, gif_duration, thumbnail_url, thumbnail_mime_type, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    fn get_gif_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    fn get_gif_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    fn set_gif_url<'a>(&'a mut self, gif_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    fn get_gif_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    fn get_gif_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    fn set_gif_width<'a>(&'a mut self, gif_width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    fn get_gif_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    fn get_gif_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    fn set_gif_height<'a>(&'a mut self, gif_height: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    fn get_gif_duration<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    fn get_gif_duration_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    fn set_gif_duration<'a>(&'a mut self, gif_duration: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn get_thumbnail_mime_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn get_thumbnail_mime_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn set_thumbnail_mime_type<'a>(
        &'a mut self,
        thumbnail_mime_type: Option<String>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitBotName {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (name)"]
    fn into_tuple(self) -> String;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's name"]
    fn get_name<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's name"]
    fn get_name_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's name"]
    fn set_name<'a>(&'a mut self, name: String) -> &'a mut Self;
}
trait TraitVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, width, height, duration, thumbnail, file_name, mime_type, file_size)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        i64,
        i64,
        i64,
        Option<PhotoSize>,
        Option<String>,
        Option<String>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    fn get_width<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    fn get_width_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    fn set_width<'a>(&'a mut self, width: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    fn get_height<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    fn get_height_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    fn set_height<'a>(&'a mut self, height: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    fn get_duration<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    fn get_duration_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&PhotoSize>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    fn get_file_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    fn get_file_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    fn set_file_name<'a>(&'a mut self, file_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn get_mime_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn get_mime_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn set_mime_type<'a>(&'a mut self, mime_type: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self;
}
trait TraitInputTextMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_text, parse_mode, entities, disable_web_page_preview)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    fn get_message_text<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    fn get_message_text_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    fn set_message_text<'a>(&'a mut self, message_text: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    fn get_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    fn get_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    fn set_entities<'a>(&'a mut self, entities: Option<Vec<MessageEntity>>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    fn get_disable_web_page_preview<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    fn get_disable_web_page_preview_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    fn set_disable_web_page_preview<'a>(
        &'a mut self,
        disable_web_page_preview: Option<bool>,
    ) -> &'a mut Self;
}
trait TraitInlineQueryResultCachedMpeg4Gif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, mpeg4_file_id, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    fn get_mpeg_4_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    fn get_mpeg_4_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    fn set_mpeg_4_file_id<'a>(&'a mut self, mpeg_4_file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitInlineQueryResultDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, title, caption, parse_mode, caption_entities, document_url, mime_type, description, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        String,
        String,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    fn get_document_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    fn get_document_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    fn set_document_url<'a>(&'a mut self, document_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    fn get_mime_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    fn get_mime_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    fn set_mime_type<'a>(&'a mut self, mime_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self;
}
trait TraitPassportElementErrorUnspecified {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, element_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    fn get_source<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    fn get_source_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    fn get_element_hash<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    fn get_element_hash_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    fn set_element_hash<'a>(&'a mut self, element_hash: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self;
}
trait TraitInlineQueryResultCachedAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, audio_file_id, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    fn get_audio_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    fn get_audio_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    fn set_audio_file_id<'a>(&'a mut self, audio_file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitVideoChatEnded {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (duration)"]
    fn into_tuple(self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video chat duration in seconds"]
    fn get_duration<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video chat duration in seconds"]
    fn get_duration_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video chat duration in seconds"]
    fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self;
}
trait TraitInlineQueryResultVoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, voice_url, title, caption, parse_mode, caption_entities, voice_duration, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    fn get_voice_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    fn get_voice_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    fn set_voice_url<'a>(&'a mut self, voice_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    fn get_voice_duration<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    fn get_voice_duration_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    fn set_voice_duration<'a>(&'a mut self, voice_duration: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitResponseParameters {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (migrate_to_chat_id, retry_after)"]
    fn into_tuple(self) -> (Option<i64>, Option<i64>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_migrate_to_chat_id<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_migrate_to_chat_id_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn set_migrate_to_chat_id<'a>(&'a mut self, migrate_to_chat_id: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"]
    fn get_retry_after<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"]
    fn get_retry_after_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"]
    fn set_retry_after<'a>(&'a mut self, retry_after: Option<i64>) -> &'a mut Self;
}
trait TraitEncryptedPassportElement {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, data, phone_number, email, files, front_side, reverse_side, selfie, translation, hash)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<PassportFile>>,
        Option<PassportFile>,
        Option<PassportFile>,
        Option<PassportFile>,
        Option<Vec<PassportFile>>,
        String,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Element type. One of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\", \"phone_number\", \"email\"."]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Element type. One of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\", \"phone_number\", \"email\"."]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Element type. One of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\", \"phone_number\", \"email\"."]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\" and \"address\" types. Can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_data<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\" and \"address\" types. Can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_data_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\" and \"address\" types. Can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn set_data<'a>(&'a mut self, data: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified phone number, available only for \"phone_number\" type"]
    fn get_phone_number<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified phone number, available only for \"phone_number\" type"]
    fn get_phone_number_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified phone number, available only for \"phone_number\" type"]
    fn set_phone_number<'a>(&'a mut self, phone_number: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified email address, available only for \"email\" type"]
    fn get_email<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified email address, available only for \"email\" type"]
    fn get_email_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified email address, available only for \"email\" type"]
    fn set_email<'a>(&'a mut self, email: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with documents provided by the user, available for \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_files<'a>(&'a self) -> Option<Cow<'a, Vec<PassportFile>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with documents provided by the user, available for \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_files_ref<'a>(&'a self) -> Option<&Vec<PassportFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with documents provided by the user, available for \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn set_files<'a>(&'a mut self, files: Option<Vec<PassportFile>>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the front side of the document, provided by the user. Available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_front_side<'a>(&'a self) -> Option<Cow<'a, PassportFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the front side of the document, provided by the user. Available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_front_side_ref<'a>(&'a self) -> Option<&PassportFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the front side of the document, provided by the user. Available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn set_front_side<'a>(&'a mut self, front_side: Option<PassportFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the reverse side of the document, provided by the user. Available for \"driver_license\" and \"identity_card\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_reverse_side<'a>(&'a self) -> Option<Cow<'a, PassportFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the reverse side of the document, provided by the user. Available for \"driver_license\" and \"identity_card\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_reverse_side_ref<'a>(&'a self) -> Option<&PassportFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the reverse side of the document, provided by the user. Available for \"driver_license\" and \"identity_card\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn set_reverse_side<'a>(&'a mut self, reverse_side: Option<PassportFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_selfie<'a>(&'a self) -> Option<Cow<'a, PassportFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_selfie_ref<'a>(&'a self) -> Option<&PassportFile>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn set_selfie<'a>(&'a mut self, selfie: Option<PassportFile>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_translation<'a>(&'a self) -> Option<Cow<'a, Vec<PassportFile>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn get_translation_ref<'a>(&'a self) -> Option<&Vec<PassportFile>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    fn set_translation<'a>(&'a mut self, translation: Option<Vec<PassportFile>>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash for using in PassportElementErrorUnspecified"]
    fn get_hash<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash for using in PassportElementErrorUnspecified"]
    fn get_hash_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash for using in PassportElementErrorUnspecified"]
    fn set_hash<'a>(&'a mut self, hash: String) -> &'a mut Self;
}
trait TraitPhotoSize {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, width, height, file_size)"]
    fn into_tuple(self) -> (String, String, i64, i64, Option<i64>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo width"]
    fn get_width<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo width"]
    fn get_width_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo width"]
    fn set_width<'a>(&'a mut self, width: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo height"]
    fn get_height<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo height"]
    fn get_height_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo height"]
    fn set_height<'a>(&'a mut self, height: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    fn get_file_size<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    fn get_file_size_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self;
}
trait TraitInlineQueryResultCachedVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, video_file_id, title, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    fn get_video_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    fn get_video_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    fn set_video_file_id<'a>(&'a mut self, video_file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitVoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, duration, mime_type, file_size)"]
    fn into_tuple(self) -> (String, String, i64, Option<String>, Option<i64>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn get_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn get_file_unique_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    fn get_duration<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    fn get_duration_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn get_mime_type<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn get_mime_type_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    fn set_mime_type<'a>(&'a mut self, mime_type: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn get_file_size_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self;
}
trait TraitGame {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (title, description, photo, text, text_entities, animation)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        Vec<PhotoSize>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<Animation>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the game"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the game"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the game"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the game"]
    fn get_description<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the game"]
    fn get_description_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the game"]
    fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo that will be displayed in the game message in chats."]
    fn get_photo<'a>(&'a self) -> Cow<'a, Vec<PhotoSize>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo that will be displayed in the game message in chats."]
    fn get_photo_ref<'a>(&'a self) -> &Vec<PhotoSize>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo that will be displayed in the game message in chats."]
    fn set_photo<'a>(&'a mut self, photo: Vec<PhotoSize>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."]
    fn get_text<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."]
    fn get_text_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."]
    fn set_text<'a>(&'a mut self, text: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."]
    fn get_text_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."]
    fn get_text_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."]
    fn set_text_entities<'a>(
        &'a mut self,
        text_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"]
    fn get_animation<'a>(&'a self) -> Option<Cow<'a, Animation>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"]
    fn get_animation_ref<'a>(&'a self) -> Option<&Animation>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"]
    fn set_animation<'a>(&'a mut self, animation: Option<Animation>) -> &'a mut Self;
}
trait TraitInlineQueryResultPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, photo_url, thumbnail_url, photo_width, photo_height, title, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<i64>,
        Option<i64>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    fn get_photo_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    fn get_photo_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    fn set_photo_url<'a>(&'a mut self, photo_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    fn get_photo_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    fn get_photo_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    fn set_photo_width<'a>(&'a mut self, photo_width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    fn get_photo_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    fn get_photo_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    fn set_photo_height<'a>(&'a mut self, photo_height: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitInlineQueryResultLocation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, latitude, longitude, title, horizontal_accuracy, live_period, heading, proximity_alert_radius, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        String,
        Option<::ordered_float::OrderedFloat<f64>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    fn set_latitude<'a>(&'a mut self, latitude: ::ordered_float::OrderedFloat<f64>)
        -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn get_horizontal_accuracy<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn get_horizontal_accuracy_ref<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn set_horizontal_accuracy<'a>(
        &'a mut self,
        horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn get_live_period<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn get_live_period_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn set_live_period<'a>(&'a mut self, live_period: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn get_heading<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn get_heading_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn set_heading<'a>(&'a mut self, heading: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn get_proximity_alert_radius<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn get_proximity_alert_radius_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn set_proximity_alert_radius<'a>(
        &'a mut self,
        proximity_alert_radius: Option<i64>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self;
}
trait TraitInputMessageContent:
    TraitInputTextMessageContent
    + TraitInputLocationMessageContent
    + TraitInputVenueMessageContent
    + TraitInputContactMessageContent
    + TraitInputInvoiceMessageContent
{
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitChatMemberOwner {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, is_anonymous, custom_title)"]
    fn into_tuple(self) -> (User, bool, Option<String>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn get_is_anonymous<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn get_is_anonymous_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn set_is_anonymous<'a>(&'a mut self, is_anonymous: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn get_custom_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn get_custom_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn set_custom_title<'a>(&'a mut self, custom_title: Option<String>) -> &'a mut Self;
}
trait TraitStory {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitMenuButton:
    TraitMenuButtonCommands + TraitMenuButtonWebApp + TraitMenuButtonDefault
{
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    fn into_tuple(self);
}
trait TraitUser {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, is_bot, first_name, last_name, username, language_code, is_premium, added_to_attachment_menu, can_join_groups, can_read_all_group_messages, supports_inline_queries)"]
    fn into_tuple(
        self,
    ) -> (
        i64,
        bool,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn get_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    fn set_id<'a>(&'a mut self, id: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if this user is a bot"]
    fn get_is_bot<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if this user is a bot"]
    fn get_is_bot_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if this user is a bot"]
    fn set_is_bot<'a>(&'a mut self, is_bot: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User's or bot's first name"]
    fn get_first_name<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User's or bot's first name"]
    fn get_first_name_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User's or bot's first name"]
    fn set_first_name<'a>(&'a mut self, first_name: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's last name"]
    fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's last name"]
    fn get_last_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's last name"]
    fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's username"]
    fn get_username<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's username"]
    fn get_username_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's username"]
    fn set_username<'a>(&'a mut self, username: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. IETF language tag of the user's language"]
    fn get_language_code<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. IETF language tag of the user's language"]
    fn get_language_code_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. IETF language tag of the user's language"]
    fn set_language_code<'a>(&'a mut self, language_code: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user is a Telegram Premium user"]
    fn get_is_premium<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user is a Telegram Premium user"]
    fn get_is_premium_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user is a Telegram Premium user"]
    fn set_is_premium<'a>(&'a mut self, is_premium: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user added the bot to the attachment menu"]
    fn get_added_to_attachment_menu<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user added the bot to the attachment menu"]
    fn get_added_to_attachment_menu_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user added the bot to the attachment menu"]
    fn set_added_to_attachment_menu<'a>(
        &'a mut self,
        added_to_attachment_menu: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can be invited to groups. Returned only in getMe."]
    fn get_can_join_groups<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can be invited to groups. Returned only in getMe."]
    fn get_can_join_groups_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can be invited to groups. Returned only in getMe."]
    fn set_can_join_groups<'a>(&'a mut self, can_join_groups: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."]
    fn get_can_read_all_group_messages<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."]
    fn get_can_read_all_group_messages_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."]
    fn set_can_read_all_group_messages<'a>(
        &'a mut self,
        can_read_all_group_messages: Option<bool>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot supports inline queries. Returned only in getMe."]
    fn get_supports_inline_queries<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot supports inline queries. Returned only in getMe."]
    fn get_supports_inline_queries_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot supports inline queries. Returned only in getMe."]
    fn set_supports_inline_queries<'a>(
        &'a mut self,
        supports_inline_queries: Option<bool>,
    ) -> &'a mut Self;
}
trait TraitInlineQueryResultAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, audio_url, title, caption, parse_mode, caption_entities, performer, audio_duration, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<String>,
        Option<i64>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    fn get_audio_url<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    fn get_audio_url_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    fn set_audio_url<'a>(&'a mut self, audio_url: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    fn get_performer<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    fn get_performer_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    fn set_performer<'a>(&'a mut self, performer: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    fn get_audio_duration<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    fn get_audio_duration_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    fn set_audio_duration<'a>(&'a mut self, audio_duration: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitChatInviteLink {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (invite_link, creator, creates_join_request, is_primary, is_revoked, name, expire_date, member_limit, pending_join_request_count)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        User,
        bool,
        bool,
        bool,
        Option<String>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with \"...\"."]
    fn get_invite_link<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with \"...\"."]
    fn get_invite_link_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with \"...\"."]
    fn set_invite_link<'a>(&'a mut self, invite_link: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Creator of the link"]
    fn get_creator<'a>(&'a self) -> Cow<'a, User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Creator of the link"]
    fn get_creator_ref<'a>(&'a self) -> &User;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Creator of the link"]
    fn set_creator<'a>(&'a mut self, creator: User) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if users joining the chat via the link need to be approved by chat administrators"]
    fn get_creates_join_request<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if users joining the chat via the link need to be approved by chat administrators"]
    fn get_creates_join_request_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if users joining the chat via the link need to be approved by chat administrators"]
    fn set_creates_join_request<'a>(&'a mut self, creates_join_request: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is primary"]
    fn get_is_primary<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is primary"]
    fn get_is_primary_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is primary"]
    fn set_is_primary<'a>(&'a mut self, is_primary: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is revoked"]
    fn get_is_revoked<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is revoked"]
    fn get_is_revoked_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is revoked"]
    fn set_is_revoked<'a>(&'a mut self, is_revoked: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Invite link name"]
    fn get_name<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Invite link name"]
    fn get_name_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Invite link name"]
    fn set_name<'a>(&'a mut self, name: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"]
    fn get_expire_date<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"]
    fn get_expire_date_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"]
    fn set_expire_date<'a>(&'a mut self, expire_date: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"]
    fn get_member_limit<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"]
    fn get_member_limit_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"]
    fn set_member_limit<'a>(&'a mut self, member_limit: Option<i64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Number of pending join requests created using this link"]
    fn get_pending_join_request_count<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Number of pending join requests created using this link"]
    fn get_pending_join_request_count_ref<'a>(&'a self) -> Option<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Number of pending join requests created using this link"]
    fn set_pending_join_request_count<'a>(
        &'a mut self,
        pending_join_request_count: Option<i64>,
    ) -> &'a mut Self;
}
trait TraitMessageAutoDeleteTimerChanged {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_auto_delete_time)"]
    fn into_tuple(self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New auto-delete time for messages in the chat; in seconds"]
    fn get_message_auto_delete_time<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New auto-delete time for messages in the chat; in seconds"]
    fn get_message_auto_delete_time_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New auto-delete time for messages in the chat; in seconds"]
    fn set_message_auto_delete_time<'a>(
        &'a mut self,
        message_auto_delete_time: i64,
    ) -> &'a mut Self;
}
trait TraitInlineQueryResultCachedGif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, gif_file_id, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    fn get_gif_file_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    fn get_gif_file_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    fn set_gif_file_id<'a>(&'a mut self, gif_file_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&Vec<MessageEntity>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&InlineKeyboardMarkup>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&InputMessageContent>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self;
}
trait TraitLabeledPrice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (label, amount)"]
    fn into_tuple(self) -> (String, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Portion label"]
    fn get_label<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Portion label"]
    fn get_label_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Portion label"]
    fn set_label<'a>(&'a mut self, label: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn get_amount<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn get_amount_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn set_amount<'a>(&'a mut self, amount: i64) -> &'a mut Self;
}
trait TraitPollAnswer {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (poll_id, voter_chat, user, option_ids)"]
    fn into_tuple(self) -> (String, Option<Chat>, Option<User>, Vec<i64>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    fn get_poll_id<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    fn get_poll_id_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    fn set_poll_id<'a>(&'a mut self, poll_id: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    fn get_voter_chat<'a>(&'a self) -> Option<Cow<'a, Chat>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    fn get_voter_chat_ref<'a>(&'a self) -> Option<&Chat>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    fn set_voter_chat<'a>(&'a mut self, voter_chat: Option<Chat>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    fn get_user<'a>(&'a self) -> Option<Cow<'a, User>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    fn get_user_ref<'a>(&'a self) -> Option<&User>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    fn set_user<'a>(&'a mut self, user: Option<User>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    fn get_option_ids<'a>(&'a self) -> Cow<'a, Vec<i64>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    fn get_option_ids_ref<'a>(&'a self) -> &Vec<i64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    fn set_option_ids<'a>(&'a mut self, option_ids: Vec<i64>) -> &'a mut Self;
}
trait TraitInvoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (title, description, start_parameter, currency, total_amount)"]
    fn into_tuple(self) -> (String, String, String, String, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name"]
    fn get_title<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name"]
    fn get_title_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description"]
    fn get_description<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description"]
    fn get_description_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description"]
    fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique bot deep-linking parameter that can be used to generate this invoice"]
    fn get_start_parameter<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique bot deep-linking parameter that can be used to generate this invoice"]
    fn get_start_parameter_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique bot deep-linking parameter that can be used to generate this invoice"]
    fn set_start_parameter<'a>(&'a mut self, start_parameter: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    fn get_currency<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    fn get_currency_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    fn set_currency<'a>(&'a mut self, currency: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn get_total_amount<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn get_total_amount_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    fn set_total_amount<'a>(&'a mut self, total_amount: i64) -> &'a mut Self;
}
trait TraitPassportElementErrorReverseSide {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    fn get_source<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    fn get_source_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    fn get_file_hash<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    fn get_file_hash_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self;
}
trait TraitReplyKeyboardRemove {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (remove_keyboard, selective)"]
    fn into_tuple(self) -> (bool, Option<bool>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"]
    fn get_remove_keyboard<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"]
    fn get_remove_keyboard_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"]
    fn set_remove_keyboard<'a>(&'a mut self, remove_keyboard: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."]
    fn get_selective<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."]
    fn get_selective_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."]
    fn set_selective<'a>(&'a mut self, selective: Option<bool>) -> &'a mut Self;
}
trait TraitKeyboardButtonRequestChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (request_id, chat_is_channel, chat_is_forum, chat_has_username, chat_is_created, user_administrator_rights, bot_administrator_rights, bot_is_member)"]
    fn into_tuple(
        self,
    ) -> (
        i64,
        bool,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<ChatAdministratorRights>,
        Option<ChatAdministratorRights>,
        Option<bool>,
    );
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"]
    fn get_request_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"]
    fn get_request_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"]
    fn set_request_id<'a>(&'a mut self, request_id: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Pass True to request a channel chat, pass False to request a group or a supergroup chat."]
    fn get_chat_is_channel<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Pass True to request a channel chat, pass False to request a group or a supergroup chat."]
    fn get_chat_is_channel_ref<'a>(&'a self) -> bool;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Pass True to request a channel chat, pass False to request a group or a supergroup chat."]
    fn set_chat_is_channel<'a>(&'a mut self, chat_is_channel: bool) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."]
    fn get_chat_is_forum<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."]
    fn get_chat_is_forum_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."]
    fn set_chat_is_forum<'a>(&'a mut self, chat_is_forum: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."]
    fn get_chat_has_username<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."]
    fn get_chat_has_username_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."]
    fn set_chat_has_username<'a>(&'a mut self, chat_has_username: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."]
    fn get_chat_is_created<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."]
    fn get_chat_is_created_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."]
    fn set_chat_is_created<'a>(&'a mut self, chat_is_created: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."]
    fn get_user_administrator_rights<'a>(&'a self) -> Option<Cow<'a, ChatAdministratorRights>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."]
    fn get_user_administrator_rights_ref<'a>(&'a self) -> Option<&ChatAdministratorRights>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."]
    fn set_user_administrator_rights<'a>(
        &'a mut self,
        user_administrator_rights: Option<ChatAdministratorRights>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."]
    fn get_bot_administrator_rights<'a>(&'a self) -> Option<Cow<'a, ChatAdministratorRights>>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."]
    fn get_bot_administrator_rights_ref<'a>(&'a self) -> Option<&ChatAdministratorRights>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."]
    fn set_bot_administrator_rights<'a>(
        &'a mut self,
        bot_administrator_rights: Option<ChatAdministratorRights>,
    ) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."]
    fn get_bot_is_member<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."]
    fn get_bot_is_member_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."]
    fn set_bot_is_member<'a>(&'a mut self, bot_is_member: Option<bool>) -> &'a mut Self;
}
trait TraitKeyboardButtonRequestUser {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (request_id, user_is_bot, user_is_premium)"]
    fn into_tuple(self) -> (i64, Option<bool>, Option<bool>);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"]
    fn get_request_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"]
    fn get_request_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"]
    fn set_request_id<'a>(&'a mut self, request_id: i64) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."]
    fn get_user_is_bot<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."]
    fn get_user_is_bot_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."]
    fn set_user_is_bot<'a>(&'a mut self, user_is_bot: Option<bool>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."]
    fn get_user_is_premium<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."]
    fn get_user_is_premium_ref<'a>(&'a self) -> Option<bool>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."]
    fn set_user_is_premium<'a>(&'a mut self, user_is_premium: Option<bool>) -> &'a mut Self;
}
trait TraitBotCommandScopeAllGroupChats {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
}
trait TraitBotCommandScopeChatMember {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, chat_id, user_id)"]
    fn into_tuple(self) -> (String, ::ordered_float::OrderedFloat<f64>, i64);
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64>;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn set_chat_id<'a>(&'a mut self, chat_id: ::ordered_float::OrderedFloat<f64>) -> &'a mut Self;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    fn get_user_id<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    fn get_user_id_ref<'a>(&'a self) -> i64;
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    fn set_user_id<'a>(&'a mut self, user_id: i64) -> &'a mut Self;
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a great replacement for the Telegram Login Widget when the user is coming from Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:Telegram apps support these buttons as of version 5.7."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct LoginUrl {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."]
    #[serde(rename = "url")]
    url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New text of the button in forwarded messages."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_text",
        default
    )]
    forward_text: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "bot_username",
        default
    )]
    bot_username: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request the permission for your bot to send messages to the user."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_write_access",
        default
    )]
    request_write_access: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to LoginUrl that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipLoginUrl {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."]
    #[serde(rename = "url")]
    url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New text of the button in forwarded messages."]
    forward_text: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."]
    bot_username: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request the permission for your bot to send messages to the user."]
    request_write_access: Option<bool>,
}
impl From<NoSkipLoginUrl> for LoginUrl {
    fn from(t: NoSkipLoginUrl) -> Self {
        Self {
            url: t.url,
            forward_text: t.forward_text,
            bot_username: t.bot_username,
            request_write_access: t.request_write_access,
        }
    }
}
impl Into<NoSkipLoginUrl> for LoginUrl {
    fn into(self) -> NoSkipLoginUrl {
        NoSkipLoginUrl {
            url: self.url,
            forward_text: self.forward_text,
            bot_username: self.bot_username,
            request_write_access: self.request_write_access,
        }
    }
}
impl NoSkipLoginUrl {
    pub fn skip(self) -> LoginUrl {
        self.into()
    }
}
impl LoginUrl {
    pub fn noskip(self) -> NoSkipLoginUrl {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a great replacement for the Telegram Login Widget when the user is coming from Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:Telegram apps support these buttons as of version 5.7."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct LoginUrlBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."]
    #[serde(rename = "url")]
    url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New text of the button in forwarded messages."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_text",
        default
    )]
    forward_text: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "bot_username",
        default
    )]
    bot_username: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request the permission for your bot to send messages to the user."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_write_access",
        default
    )]
    request_write_access: Option<bool>,
}
impl LoginUrlBuilder {
    pub fn new(url: String) -> Self {
        Self {
            url,
            forward_text: None,
            bot_username: None,
            request_write_access: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."]
    pub fn set_url(mut self, url: String) -> Self {
        self.url = url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New text of the button in forwarded messages."]
    pub fn set_forward_text(mut self, forward_text: String) -> Self {
        self.forward_text = Some(forward_text);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."]
    pub fn set_bot_username(mut self, bot_username: String) -> Self {
        self.bot_username = Some(bot_username);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request the permission for your bot to send messages to the user."]
    pub fn set_request_write_access(mut self, request_write_access: bool) -> Self {
        self.request_write_access = Some(request_write_access);
        self
    }
    pub fn build(self) -> LoginUrl {
        LoginUrl {
            url: self.url,
            forward_text: self.forward_text,
            bot_username: self.bot_username,
            request_write_access: self.request_write_access,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering a specific chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    #[serde(rename = "chat_id")]
    chat_id: ::ordered_float::OrderedFloat<f64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotCommandScopeChat that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotCommandScopeChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    #[serde(rename = "chat_id")]
    chat_id: ::ordered_float::OrderedFloat<f64>,
}
impl From<NoSkipBotCommandScopeChat> for BotCommandScopeChat {
    fn from(t: NoSkipBotCommandScopeChat) -> Self {
        Self {
            tg_type: t.tg_type,
            chat_id: t.chat_id,
        }
    }
}
impl Into<NoSkipBotCommandScopeChat> for BotCommandScopeChat {
    fn into(self) -> NoSkipBotCommandScopeChat {
        NoSkipBotCommandScopeChat {
            tg_type: self.tg_type,
            chat_id: self.chat_id,
        }
    }
}
impl NoSkipBotCommandScopeChat {
    pub fn skip(self) -> BotCommandScopeChat {
        self.into()
    }
}
impl BotCommandScopeChat {
    pub fn noskip(self) -> NoSkipBotCommandScopeChat {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering a specific chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeChatBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    #[serde(rename = "chat_id")]
    chat_id: ::ordered_float::OrderedFloat<f64>,
}
impl BotCommandScopeChatBuilder {
    pub fn new(chat_id: ::ordered_float::OrderedFloat<f64>) -> Self {
        Self {
            tg_type: "chat".to_owned(),
            chat_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn set_chat_id(mut self, chat_id: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.chat_id = chat_id;
        self
    }
    pub fn build(self) -> BotCommandScopeChat {
        BotCommandScopeChat {
            tg_type: self.tg_type,
            chat_id: self.chat_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes actions that a non-administrator user is allowed to take in a chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatPermissions {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_messages",
        default
    )]
    can_send_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send audios"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_audios",
        default
    )]
    can_send_audios: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send documents"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_documents",
        default
    )]
    can_send_documents: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send photos"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_photos",
        default
    )]
    can_send_photos: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send videos"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_videos",
        default
    )]
    can_send_videos: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send video notes"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_video_notes",
        default
    )]
    can_send_video_notes: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send voice notes"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_voice_notes",
        default
    )]
    can_send_voice_notes: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send polls"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_polls",
        default
    )]
    can_send_polls: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_other_messages",
        default
    )]
    can_send_other_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to add web page previews to their messages"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_add_web_page_previews",
        default
    )]
    can_add_web_page_previews: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_change_info",
        default
    )]
    can_change_info: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to invite new users to the chat"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_invite_users",
        default
    )]
    can_invite_users: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_pin_messages",
        default
    )]
    can_pin_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_manage_topics",
        default
    )]
    can_manage_topics: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatPermissions that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatPermissions {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    can_send_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send audios"]
    can_send_audios: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send documents"]
    can_send_documents: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send photos"]
    can_send_photos: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send videos"]
    can_send_videos: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send video notes"]
    can_send_video_notes: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send voice notes"]
    can_send_voice_notes: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send polls"]
    can_send_polls: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"]
    can_send_other_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to add web page previews to their messages"]
    can_add_web_page_previews: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"]
    can_change_info: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to invite new users to the chat"]
    can_invite_users: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"]
    can_pin_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"]
    can_manage_topics: Option<bool>,
}
impl From<NoSkipChatPermissions> for ChatPermissions {
    fn from(t: NoSkipChatPermissions) -> Self {
        Self {
            can_send_messages: t.can_send_messages,
            can_send_audios: t.can_send_audios,
            can_send_documents: t.can_send_documents,
            can_send_photos: t.can_send_photos,
            can_send_videos: t.can_send_videos,
            can_send_video_notes: t.can_send_video_notes,
            can_send_voice_notes: t.can_send_voice_notes,
            can_send_polls: t.can_send_polls,
            can_send_other_messages: t.can_send_other_messages,
            can_add_web_page_previews: t.can_add_web_page_previews,
            can_change_info: t.can_change_info,
            can_invite_users: t.can_invite_users,
            can_pin_messages: t.can_pin_messages,
            can_manage_topics: t.can_manage_topics,
        }
    }
}
impl Into<NoSkipChatPermissions> for ChatPermissions {
    fn into(self) -> NoSkipChatPermissions {
        NoSkipChatPermissions {
            can_send_messages: self.can_send_messages,
            can_send_audios: self.can_send_audios,
            can_send_documents: self.can_send_documents,
            can_send_photos: self.can_send_photos,
            can_send_videos: self.can_send_videos,
            can_send_video_notes: self.can_send_video_notes,
            can_send_voice_notes: self.can_send_voice_notes,
            can_send_polls: self.can_send_polls,
            can_send_other_messages: self.can_send_other_messages,
            can_add_web_page_previews: self.can_add_web_page_previews,
            can_change_info: self.can_change_info,
            can_invite_users: self.can_invite_users,
            can_pin_messages: self.can_pin_messages,
            can_manage_topics: self.can_manage_topics,
        }
    }
}
impl NoSkipChatPermissions {
    pub fn skip(self) -> ChatPermissions {
        self.into()
    }
}
impl ChatPermissions {
    pub fn noskip(self) -> NoSkipChatPermissions {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes actions that a non-administrator user is allowed to take in a chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatPermissionsBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_messages",
        default
    )]
    can_send_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send audios"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_audios",
        default
    )]
    can_send_audios: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send documents"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_documents",
        default
    )]
    can_send_documents: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send photos"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_photos",
        default
    )]
    can_send_photos: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send videos"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_videos",
        default
    )]
    can_send_videos: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send video notes"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_video_notes",
        default
    )]
    can_send_video_notes: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send voice notes"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_voice_notes",
        default
    )]
    can_send_voice_notes: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send polls"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_polls",
        default
    )]
    can_send_polls: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_send_other_messages",
        default
    )]
    can_send_other_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to add web page previews to their messages"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_add_web_page_previews",
        default
    )]
    can_add_web_page_previews: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_change_info",
        default
    )]
    can_change_info: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to invite new users to the chat"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_invite_users",
        default
    )]
    can_invite_users: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_pin_messages",
        default
    )]
    can_pin_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_manage_topics",
        default
    )]
    can_manage_topics: Option<bool>,
}
impl ChatPermissionsBuilder {
    pub fn new() -> Self {
        Self {
            can_send_messages: None,
            can_send_audios: None,
            can_send_documents: None,
            can_send_photos: None,
            can_send_videos: None,
            can_send_video_notes: None,
            can_send_voice_notes: None,
            can_send_polls: None,
            can_send_other_messages: None,
            can_add_web_page_previews: None,
            can_change_info: None,
            can_invite_users: None,
            can_pin_messages: None,
            can_manage_topics: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    pub fn set_can_send_messages(mut self, can_send_messages: bool) -> Self {
        self.can_send_messages = Some(can_send_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send audios"]
    pub fn set_can_send_audios(mut self, can_send_audios: bool) -> Self {
        self.can_send_audios = Some(can_send_audios);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send documents"]
    pub fn set_can_send_documents(mut self, can_send_documents: bool) -> Self {
        self.can_send_documents = Some(can_send_documents);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send photos"]
    pub fn set_can_send_photos(mut self, can_send_photos: bool) -> Self {
        self.can_send_photos = Some(can_send_photos);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send videos"]
    pub fn set_can_send_videos(mut self, can_send_videos: bool) -> Self {
        self.can_send_videos = Some(can_send_videos);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send video notes"]
    pub fn set_can_send_video_notes(mut self, can_send_video_notes: bool) -> Self {
        self.can_send_video_notes = Some(can_send_video_notes);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send voice notes"]
    pub fn set_can_send_voice_notes(mut self, can_send_voice_notes: bool) -> Self {
        self.can_send_voice_notes = Some(can_send_voice_notes);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send polls"]
    pub fn set_can_send_polls(mut self, can_send_polls: bool) -> Self {
        self.can_send_polls = Some(can_send_polls);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"]
    pub fn set_can_send_other_messages(mut self, can_send_other_messages: bool) -> Self {
        self.can_send_other_messages = Some(can_send_other_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to add web page previews to their messages"]
    pub fn set_can_add_web_page_previews(mut self, can_add_web_page_previews: bool) -> Self {
        self.can_add_web_page_previews = Some(can_add_web_page_previews);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"]
    pub fn set_can_change_info(mut self, can_change_info: bool) -> Self {
        self.can_change_info = Some(can_change_info);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to invite new users to the chat"]
    pub fn set_can_invite_users(mut self, can_invite_users: bool) -> Self {
        self.can_invite_users = Some(can_invite_users);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"]
    pub fn set_can_pin_messages(mut self, can_pin_messages: bool) -> Self {
        self.can_pin_messages = Some(can_pin_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"]
    pub fn set_can_manage_topics(mut self, can_manage_topics: bool) -> Self {
        self.can_manage_topics = Some(can_manage_topics);
        self
    }
    pub fn build(self) -> ChatPermissions {
        ChatPermissions {
            can_send_messages: self.can_send_messages,
            can_send_audios: self.can_send_audios,
            can_send_documents: self.can_send_documents,
            can_send_photos: self.can_send_photos,
            can_send_videos: self.can_send_videos,
            can_send_video_notes: self.can_send_video_notes,
            can_send_voice_notes: self.can_send_voice_notes,
            can_send_polls: self.can_send_polls,
            can_send_other_messages: self.can_send_other_messages,
            can_add_web_page_previews: self.can_add_web_page_previews,
            can_change_info: self.can_change_info,
            can_invite_users: self.can_invite_users,
            can_pin_messages: self.can_pin_messages,
            can_manage_topics: self.can_manage_topics,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an audio file to be treated as music by the Telegram clients."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Audio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio as defined by sender or by audio tags"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "performer", default)]
    performer: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio as defined by sender or by audio tags"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_name", default)]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "mime_type", default)]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the album cover to which the music file belongs"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Audio that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio as defined by sender or by audio tags"]
    performer: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio as defined by sender or by audio tags"]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    file_size: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the album cover to which the music file belongs"]
    thumbnail: Option<PhotoSize>,
}
impl From<NoSkipAudio> for Audio {
    fn from(t: NoSkipAudio) -> Self {
        Self {
            file_id: t.file_id,
            file_unique_id: t.file_unique_id,
            duration: t.duration,
            performer: t.performer,
            title: t.title,
            file_name: t.file_name,
            mime_type: t.mime_type,
            file_size: t.file_size,
            thumbnail: t.thumbnail,
        }
    }
}
impl Into<NoSkipAudio> for Audio {
    fn into(self) -> NoSkipAudio {
        NoSkipAudio {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            duration: self.duration,
            performer: self.performer,
            title: self.title,
            file_name: self.file_name,
            mime_type: self.mime_type,
            file_size: self.file_size,
            thumbnail: self.thumbnail,
        }
    }
}
impl NoSkipAudio {
    pub fn skip(self) -> Audio {
        self.into()
    }
}
impl Audio {
    pub fn noskip(self) -> NoSkipAudio {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an audio file to be treated as music by the Telegram clients."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct AudioBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio as defined by sender or by audio tags"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "performer", default)]
    performer: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio as defined by sender or by audio tags"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_name", default)]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "mime_type", default)]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the album cover to which the music file belongs"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
}
impl AudioBuilder {
    pub fn new(file_id: String, file_unique_id: String, duration: i64) -> Self {
        Self {
            file_id,
            file_unique_id,
            duration,
            performer: None,
            title: None,
            file_name: None,
            mime_type: None,
            file_size: None,
            thumbnail: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id(mut self, file_id: String) -> Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id(mut self, file_unique_id: String) -> Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    pub fn set_duration(mut self, duration: i64) -> Self {
        self.duration = duration;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio as defined by sender or by audio tags"]
    pub fn set_performer(mut self, performer: String) -> Self {
        self.performer = Some(performer);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio as defined by sender or by audio tags"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn set_file_name(mut self, file_name: String) -> Self {
        self.file_name = Some(file_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn set_mime_type(mut self, mime_type: String) -> Self {
        self.mime_type = Some(mime_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size(mut self, file_size: i64) -> Self {
        self.file_size = Some(file_size);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the album cover to which the music file belongs"]
    pub fn set_thumbnail(mut self, thumbnail: PhotoSize) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    pub fn build(self) -> Audio {
        Audio {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            duration: self.duration,
            performer: self.performer,
            title: self.title,
            file_name: self.file_name,
            mime_type: self.mime_type,
            file_size: self.file_size,
            thumbnail: self.thumbnail,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the content of a contact message to be sent as the result of an inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputContactMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    #[serde(rename = "phone_number")]
    phone_number: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "last_name", default)]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "vcard", default)]
    vcard: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputContactMessageContent that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputContactMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    #[serde(rename = "phone_number")]
    phone_number: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    vcard: Option<String>,
}
impl From<NoSkipInputContactMessageContent> for InputContactMessageContent {
    fn from(t: NoSkipInputContactMessageContent) -> Self {
        Self {
            phone_number: t.phone_number,
            first_name: t.first_name,
            last_name: t.last_name,
            vcard: t.vcard,
        }
    }
}
impl Into<NoSkipInputContactMessageContent> for InputContactMessageContent {
    fn into(self) -> NoSkipInputContactMessageContent {
        NoSkipInputContactMessageContent {
            phone_number: self.phone_number,
            first_name: self.first_name,
            last_name: self.last_name,
            vcard: self.vcard,
        }
    }
}
impl NoSkipInputContactMessageContent {
    pub fn skip(self) -> InputContactMessageContent {
        self.into()
    }
}
impl InputContactMessageContent {
    pub fn noskip(self) -> NoSkipInputContactMessageContent {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the content of a contact message to be sent as the result of an inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputContactMessageContentBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    #[serde(rename = "phone_number")]
    phone_number: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "last_name", default)]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "vcard", default)]
    vcard: Option<String>,
}
impl InputContactMessageContentBuilder {
    pub fn new(phone_number: String, first_name: String) -> Self {
        Self {
            phone_number,
            first_name,
            last_name: None,
            vcard: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn set_phone_number(mut self, phone_number: String) -> Self {
        self.phone_number = phone_number;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn set_first_name(mut self, first_name: String) -> Self {
        self.first_name = first_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn set_last_name(mut self, last_name: String) -> Self {
        self.last_name = Some(last_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    pub fn set_vcard(mut self, vcard: String) -> Self {
        self.vcard = Some(vcard);
        self
    }
    pub fn build(self) -> InputContactMessageContent {
        InputContactMessageContent {
            phone_number: self.phone_number,
            first_name: self.first_name,
            last_name: self.last_name,
            vcard: self.vcard,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a photo to be sent."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputMediaPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_spoiler",
        default
    )]
    has_spoiler: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputMediaPhoto that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputMediaPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    has_spoiler: Option<bool>,
}
impl From<NoSkipInputMediaPhoto> for InputMediaPhoto {
    fn from(t: NoSkipInputMediaPhoto) -> Self {
        Self {
            tg_type: t.tg_type,
            media: t.media,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            has_spoiler: t.has_spoiler,
        }
    }
}
impl Into<NoSkipInputMediaPhoto> for InputMediaPhoto {
    fn into(self) -> NoSkipInputMediaPhoto {
        NoSkipInputMediaPhoto {
            tg_type: self.tg_type,
            media: self.media,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            has_spoiler: self.has_spoiler,
        }
    }
}
impl NoSkipInputMediaPhoto {
    pub fn skip(self) -> InputMediaPhoto {
        self.into()
    }
}
impl InputMediaPhoto {
    pub fn noskip(self) -> NoSkipInputMediaPhoto {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a photo to be sent."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputMediaPhotoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_spoiler",
        default
    )]
    has_spoiler: Option<bool>,
}
impl InputMediaPhotoBuilder {
    pub fn new(media: Option<InputFile>) -> Self {
        Self {
            tg_type: "photo".to_owned(),
            media,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            has_spoiler: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_media(mut self, media: Option<InputFile>) -> Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    pub fn set_has_spoiler(mut self, has_spoiler: bool) -> Self {
        self.has_spoiler = Some(has_spoiler);
        self
    }
    pub fn build(self) -> InputMediaPhoto {
        InputMediaPhoto {
            tg_type: self.tg_type,
            media: self.media,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            has_spoiler: self.has_spoiler,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents information about an order."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct OrderInfo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "name", default)]
    name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's phone number"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "phone_number",
        default
    )]
    phone_number: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User email"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "email", default)]
    email: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User shipping address"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "shipping_address",
        default
    )]
    shipping_address: Option<ShippingAddress>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to OrderInfo that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipOrderInfo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User name"]
    name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's phone number"]
    phone_number: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User email"]
    email: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User shipping address"]
    shipping_address: Option<ShippingAddress>,
}
impl From<NoSkipOrderInfo> for OrderInfo {
    fn from(t: NoSkipOrderInfo) -> Self {
        Self {
            name: t.name,
            phone_number: t.phone_number,
            email: t.email,
            shipping_address: t.shipping_address,
        }
    }
}
impl Into<NoSkipOrderInfo> for OrderInfo {
    fn into(self) -> NoSkipOrderInfo {
        NoSkipOrderInfo {
            name: self.name,
            phone_number: self.phone_number,
            email: self.email,
            shipping_address: self.shipping_address,
        }
    }
}
impl NoSkipOrderInfo {
    pub fn skip(self) -> OrderInfo {
        self.into()
    }
}
impl OrderInfo {
    pub fn noskip(self) -> NoSkipOrderInfo {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents information about an order."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct OrderInfoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "name", default)]
    name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's phone number"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "phone_number",
        default
    )]
    phone_number: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User email"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "email", default)]
    email: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User shipping address"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "shipping_address",
        default
    )]
    shipping_address: Option<ShippingAddress>,
}
impl OrderInfoBuilder {
    pub fn new() -> Self {
        Self {
            name: None,
            phone_number: None,
            email: None,
            shipping_address: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User name"]
    pub fn set_name(mut self, name: String) -> Self {
        self.name = Some(name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's phone number"]
    pub fn set_phone_number(mut self, phone_number: String) -> Self {
        self.phone_number = Some(phone_number);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User email"]
    pub fn set_email(mut self, email: String) -> Self {
        self.email = Some(email);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User shipping address"]
    pub fn set_shipping_address(mut self, shipping_address: ShippingAddress) -> Self {
        self.shipping_address = Some(shipping_address);
        self
    }
    pub fn build(self) -> OrderInfo {
        OrderInfo {
            name: self.name,
            phone_number: self.phone_number,
            email: self.email,
            shipping_address: self.shipping_address,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a forum topic."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ForumTopic {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the forum topic"]
    #[serde(rename = "message_thread_id")]
    message_thread_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    #[serde(rename = "name")]
    name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    #[serde(rename = "icon_color")]
    icon_color: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "icon_custom_emoji_id",
        default
    )]
    icon_custom_emoji_id: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ForumTopic that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipForumTopic {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the forum topic"]
    #[serde(rename = "message_thread_id")]
    message_thread_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    #[serde(rename = "name")]
    name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    #[serde(rename = "icon_color")]
    icon_color: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    icon_custom_emoji_id: Option<String>,
}
impl From<NoSkipForumTopic> for ForumTopic {
    fn from(t: NoSkipForumTopic) -> Self {
        Self {
            message_thread_id: t.message_thread_id,
            name: t.name,
            icon_color: t.icon_color,
            icon_custom_emoji_id: t.icon_custom_emoji_id,
        }
    }
}
impl Into<NoSkipForumTopic> for ForumTopic {
    fn into(self) -> NoSkipForumTopic {
        NoSkipForumTopic {
            message_thread_id: self.message_thread_id,
            name: self.name,
            icon_color: self.icon_color,
            icon_custom_emoji_id: self.icon_custom_emoji_id,
        }
    }
}
impl NoSkipForumTopic {
    pub fn skip(self) -> ForumTopic {
        self.into()
    }
}
impl ForumTopic {
    pub fn noskip(self) -> NoSkipForumTopic {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a forum topic."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ForumTopicBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the forum topic"]
    #[serde(rename = "message_thread_id")]
    message_thread_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    #[serde(rename = "name")]
    name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    #[serde(rename = "icon_color")]
    icon_color: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "icon_custom_emoji_id",
        default
    )]
    icon_custom_emoji_id: Option<String>,
}
impl ForumTopicBuilder {
    pub fn new(message_thread_id: i64, name: String, icon_color: i64) -> Self {
        Self {
            message_thread_id,
            name,
            icon_color,
            icon_custom_emoji_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the forum topic"]
    pub fn set_message_thread_id(mut self, message_thread_id: i64) -> Self {
        self.message_thread_id = message_thread_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    pub fn set_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    pub fn set_icon_color(mut self, icon_color: i64) -> Self {
        self.icon_color = icon_color;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    pub fn set_icon_custom_emoji_id(mut self, icon_custom_emoji_id: String) -> Self {
        self.icon_custom_emoji_id = Some(icon_custom_emoji_id);
        self
    }
    pub fn build(self) -> ForumTopic {
        ForumTopic {
            message_thread_id: self.message_thread_id,
            name: self.name,
            icon_color: self.icon_color,
            icon_custom_emoji_id: self.icon_custom_emoji_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about a user allowing a bot to write messages after adding it to the attachment menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WriteAccessAllowed {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "from_request",
        default
    )]
    from_request: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "web_app_name",
        default
    )]
    web_app_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted when the bot was added to the attachment or side menu"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "from_attachment_menu",
        default
    )]
    from_attachment_menu: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to WriteAccessAllowed that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipWriteAccessAllowed {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"]
    from_request: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"]
    web_app_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted when the bot was added to the attachment or side menu"]
    from_attachment_menu: Option<bool>,
}
impl From<NoSkipWriteAccessAllowed> for WriteAccessAllowed {
    fn from(t: NoSkipWriteAccessAllowed) -> Self {
        Self {
            from_request: t.from_request,
            web_app_name: t.web_app_name,
            from_attachment_menu: t.from_attachment_menu,
        }
    }
}
impl Into<NoSkipWriteAccessAllowed> for WriteAccessAllowed {
    fn into(self) -> NoSkipWriteAccessAllowed {
        NoSkipWriteAccessAllowed {
            from_request: self.from_request,
            web_app_name: self.web_app_name,
            from_attachment_menu: self.from_attachment_menu,
        }
    }
}
impl NoSkipWriteAccessAllowed {
    pub fn skip(self) -> WriteAccessAllowed {
        self.into()
    }
}
impl WriteAccessAllowed {
    pub fn noskip(self) -> NoSkipWriteAccessAllowed {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about a user allowing a bot to write messages after adding it to the attachment menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WriteAccessAllowedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "from_request",
        default
    )]
    from_request: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "web_app_name",
        default
    )]
    web_app_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted when the bot was added to the attachment or side menu"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "from_attachment_menu",
        default
    )]
    from_attachment_menu: Option<bool>,
}
impl WriteAccessAllowedBuilder {
    pub fn new() -> Self {
        Self {
            from_request: None,
            web_app_name: None,
            from_attachment_menu: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"]
    pub fn set_from_request(mut self, from_request: bool) -> Self {
        self.from_request = Some(from_request);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"]
    pub fn set_web_app_name(mut self, web_app_name: String) -> Self {
        self.web_app_name = Some(web_app_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted when the bot was added to the attachment or side menu"]
    pub fn set_from_attachment_menu(mut self, from_attachment_menu: bool) -> Self {
        self.from_attachment_menu = Some(from_attachment_menu);
        self
    }
    pub fn build(self) -> WriteAccessAllowed {
        WriteAccessAllowed {
            from_request: self.from_request,
            web_app_name: self.web_app_name,
            from_attachment_menu: self.from_attachment_menu,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum BotCommandScope {
    BotCommandScopeDefault(BotCommandScopeDefault),
    BotCommandScopeAllPrivateChats(BotCommandScopeAllPrivateChats),
    BotCommandScopeAllGroupChats(BotCommandScopeAllGroupChats),
    BotCommandScopeAllChatAdministrators(BotCommandScopeAllChatAdministrators),
    BotCommandScopeChat(BotCommandScopeChat),
    BotCommandScopeChatAdministrators(BotCommandScopeChatAdministrators),
    BotCommandScopeChatMember(BotCommandScopeChatMember),
}
impl Default for BotCommandScope {
    fn default() -> Self {
        BotCommandScope::BotCommandScopeDefault(BotCommandScopeDefault::default())
    }
}
impl BotCommandScope {}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an audio file to be treated as music to be sent."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputMediaAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "duration", default)]
    duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "performer", default)]
    performer: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputMediaAudio that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputMediaAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    performer: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    title: Option<String>,
}
impl From<NoSkipInputMediaAudio> for InputMediaAudio {
    fn from(t: NoSkipInputMediaAudio) -> Self {
        Self {
            tg_type: t.tg_type,
            media: t.media,
            thumbnail: t.thumbnail,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            duration: t.duration,
            performer: t.performer,
            title: t.title,
        }
    }
}
impl Into<NoSkipInputMediaAudio> for InputMediaAudio {
    fn into(self) -> NoSkipInputMediaAudio {
        NoSkipInputMediaAudio {
            tg_type: self.tg_type,
            media: self.media,
            thumbnail: self.thumbnail,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            duration: self.duration,
            performer: self.performer,
            title: self.title,
        }
    }
}
impl NoSkipInputMediaAudio {
    pub fn skip(self) -> InputMediaAudio {
        self.into()
    }
}
impl InputMediaAudio {
    pub fn noskip(self) -> NoSkipInputMediaAudio {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an audio file to be treated as music to be sent."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputMediaAudioBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "duration", default)]
    duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "performer", default)]
    performer: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
}
impl InputMediaAudioBuilder {
    pub fn new(media: Option<InputFile>) -> Self {
        Self {
            tg_type: "audio".to_owned(),
            media,
            thumbnail: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            duration: None,
            performer: None,
            title: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_media(mut self, media: Option<InputFile>) -> Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_thumbnail(mut self, thumbnail: InputFile) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    pub fn set_duration(mut self, duration: i64) -> Self {
        self.duration = Some(duration);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    pub fn set_performer(mut self, performer: String) -> Self {
        self.performer = Some(performer);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
    pub fn build(self) -> InputMediaAudio {
        InputMediaAudio {
            tg_type: self.tg_type,
            media: self.media,
            thumbnail: self.thumbnail,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            duration: self.duration,
            performer: self.performer,
            title: self.title,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum InputMedia {
    InputMediaAnimation(InputMediaAnimation),
    InputMediaDocument(InputMediaDocument),
    InputMediaAudio(InputMediaAudio),
    InputMediaPhoto(InputMediaPhoto),
    InputMediaVideo(InputMediaVideo),
}
impl Default for InputMedia {
    fn default() -> Self {
        InputMedia::InputMediaAnimation(InputMediaAnimation::default())
    }
}
impl InputMedia {}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a result of an inline query that was chosen by the user and sent to their chat partner.Note: It is necessary to enable inline feedback via @BotFather in order to receive these objects in updates."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChosenInlineResult {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    #[serde(rename = "result_id")]
    result_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The user that chose the result"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "location", default)]
    location: Option<Location>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "inline_message_id",
        default
    )]
    inline_message_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    #[serde(rename = "query")]
    query: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChosenInlineResult that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChosenInlineResult {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    #[serde(rename = "result_id")]
    result_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The user that chose the result"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    location: Option<Location>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    inline_message_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    #[serde(rename = "query")]
    query: String,
}
impl From<NoSkipChosenInlineResult> for ChosenInlineResult {
    fn from(t: NoSkipChosenInlineResult) -> Self {
        Self {
            result_id: t.result_id,
            from: t.from,
            location: t.location,
            inline_message_id: t.inline_message_id,
            query: t.query,
        }
    }
}
impl Into<NoSkipChosenInlineResult> for ChosenInlineResult {
    fn into(self) -> NoSkipChosenInlineResult {
        NoSkipChosenInlineResult {
            result_id: self.result_id,
            from: self.from,
            location: self.location,
            inline_message_id: self.inline_message_id,
            query: self.query,
        }
    }
}
impl NoSkipChosenInlineResult {
    pub fn skip(self) -> ChosenInlineResult {
        self.into()
    }
}
impl ChosenInlineResult {
    pub fn noskip(self) -> NoSkipChosenInlineResult {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a result of an inline query that was chosen by the user and sent to their chat partner.Note: It is necessary to enable inline feedback via @BotFather in order to receive these objects in updates."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChosenInlineResultBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    #[serde(rename = "result_id")]
    result_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The user that chose the result"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "location", default)]
    location: Option<Location>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "inline_message_id",
        default
    )]
    inline_message_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    #[serde(rename = "query")]
    query: String,
}
impl ChosenInlineResultBuilder {
    pub fn new(result_id: String, from: User, query: String) -> Self {
        Self {
            result_id,
            from,
            query,
            location: None,
            inline_message_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    pub fn set_result_id(mut self, result_id: String) -> Self {
        self.result_id = result_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The user that chose the result"]
    pub fn set_from(mut self, from: User) -> Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    pub fn set_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    pub fn set_inline_message_id(mut self, inline_message_id: String) -> Self {
        self.inline_message_id = Some(inline_message_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    pub fn set_query(mut self, query: String) -> Self {
        self.query = query;
        self
    }
    pub fn build(self) -> ChosenInlineResult {
        ChosenInlineResult {
            result_id: self.result_id,
            from: self.from,
            location: self.location,
            inline_message_id: self.inline_message_id,
            query: self.query,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum GeneralForumTopicUnhidden {}
impl GeneralForumTopicUnhidden {}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an incoming callback query from a callback button in an inline keyboard. If the button that originated the query was attached to a message sent by the bot, the field message will be present. If the button was attached to a message sent via the bot (in inline mode), the field inline_message_id will be present. Exactly one of the fields data or game_short_name will be present."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct CallbackQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "message", default)]
    message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "inline_message_id",
        default
    )]
    inline_message_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    #[serde(rename = "chat_instance")]
    chat_instance: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "data", default)]
    data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "game_short_name",
        default
    )]
    game_short_name: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to CallbackQuery that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipCallbackQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."]
    inline_message_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    #[serde(rename = "chat_instance")]
    chat_instance: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    game_short_name: Option<String>,
}
impl From<NoSkipCallbackQuery> for CallbackQuery {
    fn from(t: NoSkipCallbackQuery) -> Self {
        Self {
            id: t.id,
            from: t.from,
            message: t.message,
            inline_message_id: t.inline_message_id,
            chat_instance: t.chat_instance,
            data: t.data,
            game_short_name: t.game_short_name,
        }
    }
}
impl Into<NoSkipCallbackQuery> for CallbackQuery {
    fn into(self) -> NoSkipCallbackQuery {
        NoSkipCallbackQuery {
            id: self.id,
            from: self.from,
            message: self.message,
            inline_message_id: self.inline_message_id,
            chat_instance: self.chat_instance,
            data: self.data,
            game_short_name: self.game_short_name,
        }
    }
}
impl NoSkipCallbackQuery {
    pub fn skip(self) -> CallbackQuery {
        self.into()
    }
}
impl CallbackQuery {
    pub fn noskip(self) -> NoSkipCallbackQuery {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an incoming callback query from a callback button in an inline keyboard. If the button that originated the query was attached to a message sent by the bot, the field message will be present. If the button was attached to a message sent via the bot (in inline mode), the field inline_message_id will be present. Exactly one of the fields data or game_short_name will be present."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct CallbackQueryBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "message", default)]
    message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "inline_message_id",
        default
    )]
    inline_message_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    #[serde(rename = "chat_instance")]
    chat_instance: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "data", default)]
    data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "game_short_name",
        default
    )]
    game_short_name: Option<String>,
}
impl CallbackQueryBuilder {
    pub fn new(id: String, from: User, chat_instance: String) -> Self {
        Self {
            id,
            from,
            chat_instance,
            message: None,
            inline_message_id: None,
            data: None,
            game_short_name: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    pub fn set_from(mut self, from: User) -> Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    pub fn set_message(mut self, message: Message) -> Self {
        self.message = Some(message);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."]
    pub fn set_inline_message_id(mut self, inline_message_id: String) -> Self {
        self.inline_message_id = Some(inline_message_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    pub fn set_chat_instance(mut self, chat_instance: String) -> Self {
        self.chat_instance = chat_instance;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    pub fn set_data(mut self, data: String) -> Self {
        self.data = Some(data);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    pub fn set_game_short_name(mut self, game_short_name: String) -> Self {
        self.game_short_name = Some(game_short_name);
        self
    }
    pub fn build(self) -> CallbackQuery {
        CallbackQuery {
            id: self.id,
            from: self.from,
            message: self.message,
            inline_message_id: self.inline_message_id,
            chat_instance: self.chat_instance,
            data: self.data,
            game_short_name: self.game_short_name,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Chat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(rename = "id")]
    id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of chat, can be either \"private\", \"group\", \"supergroup\" or \"channel\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title, for supergroups, channels and group chats"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username, for private chats, supergroups and channels if available"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "username", default)]
    username: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. First name of the other party in a private chat"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "first_name",
        default
    )]
    first_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Last name of the other party in a private chat"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "last_name", default)]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the supergroup chat is a forum (has topics enabled)"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "is_forum", default)]
    is_forum: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat photo. Returned only in getChat."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "photo", default)]
    photo: Option<ChatPhoto>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "active_usernames",
        default
    )]
    active_usernames: Option<Vec<String>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "emoji_status_custom_emoji_id",
        default
    )]
    emoji_status_custom_emoji_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "emoji_status_expiration_date",
        default
    )]
    emoji_status_expiration_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the other party in a private chat. Returned only in getChat."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "bio", default)]
    bio: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_private_forwards",
        default
    )]
    has_private_forwards: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_restricted_voice_and_video_messages",
        default
    )]
    has_restricted_voice_and_video_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "join_to_send_messages",
        default
    )]
    join_to_send_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "join_by_request",
        default
    )]
    join_by_request: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "invite_link",
        default
    )]
    invite_link: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The most recent pinned message (by sending date). Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "pinned_message",
        default
    )]
    pinned_message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "permissions",
        default
    )]
    permissions: Option<ChatPermissions>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "slow_mode_delay",
        default
    )]
    slow_mode_delay: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "message_auto_delete_time",
        default
    )]
    message_auto_delete_time: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_aggressive_anti_spam_enabled",
        default
    )]
    has_aggressive_anti_spam_enabled: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_hidden_members",
        default
    )]
    has_hidden_members: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_protected_content",
        default
    )]
    has_protected_content: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, name of group sticker set. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "sticker_set_name",
        default
    )]
    sticker_set_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can change the group sticker set. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_set_sticker_set",
        default
    )]
    can_set_sticker_set: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "linked_chat_id",
        default
    )]
    linked_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "location", default)]
    location: Option<ChatLocation>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Chat that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(rename = "id")]
    id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of chat, can be either \"private\", \"group\", \"supergroup\" or \"channel\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title, for supergroups, channels and group chats"]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username, for private chats, supergroups and channels if available"]
    username: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. First name of the other party in a private chat"]
    first_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Last name of the other party in a private chat"]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the supergroup chat is a forum (has topics enabled)"]
    is_forum: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat photo. Returned only in getChat."]
    photo: Option<ChatPhoto>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."]
    active_usernames: Option<Vec<String>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."]
    emoji_status_custom_emoji_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."]
    emoji_status_expiration_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the other party in a private chat. Returned only in getChat."]
    bio: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."]
    has_private_forwards: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."]
    has_restricted_voice_and_video_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."]
    join_to_send_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."]
    join_by_request: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."]
    invite_link: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The most recent pinned message (by sending date). Returned only in getChat."]
    pinned_message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."]
    permissions: Option<ChatPermissions>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."]
    slow_mode_delay: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."]
    message_auto_delete_time: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."]
    has_aggressive_anti_spam_enabled: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."]
    has_hidden_members: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."]
    has_protected_content: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, name of group sticker set. Returned only in getChat."]
    sticker_set_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can change the group sticker set. Returned only in getChat."]
    can_set_sticker_set: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."]
    linked_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."]
    location: Option<ChatLocation>,
}
impl From<NoSkipChat> for Chat {
    fn from(t: NoSkipChat) -> Self {
        Self {
            id: t.id,
            tg_type: t.tg_type,
            title: t.title,
            username: t.username,
            first_name: t.first_name,
            last_name: t.last_name,
            is_forum: t.is_forum,
            photo: t.photo,
            active_usernames: t.active_usernames,
            emoji_status_custom_emoji_id: t.emoji_status_custom_emoji_id,
            emoji_status_expiration_date: t.emoji_status_expiration_date,
            bio: t.bio,
            has_private_forwards: t.has_private_forwards,
            has_restricted_voice_and_video_messages: t.has_restricted_voice_and_video_messages,
            join_to_send_messages: t.join_to_send_messages,
            join_by_request: t.join_by_request,
            description: t.description,
            invite_link: t.invite_link,
            pinned_message: t.pinned_message,
            permissions: t.permissions,
            slow_mode_delay: t.slow_mode_delay,
            message_auto_delete_time: t.message_auto_delete_time,
            has_aggressive_anti_spam_enabled: t.has_aggressive_anti_spam_enabled,
            has_hidden_members: t.has_hidden_members,
            has_protected_content: t.has_protected_content,
            sticker_set_name: t.sticker_set_name,
            can_set_sticker_set: t.can_set_sticker_set,
            linked_chat_id: t.linked_chat_id,
            location: t.location,
        }
    }
}
impl Into<NoSkipChat> for Chat {
    fn into(self) -> NoSkipChat {
        NoSkipChat {
            id: self.id,
            tg_type: self.tg_type,
            title: self.title,
            username: self.username,
            first_name: self.first_name,
            last_name: self.last_name,
            is_forum: self.is_forum,
            photo: self.photo,
            active_usernames: self.active_usernames,
            emoji_status_custom_emoji_id: self.emoji_status_custom_emoji_id,
            emoji_status_expiration_date: self.emoji_status_expiration_date,
            bio: self.bio,
            has_private_forwards: self.has_private_forwards,
            has_restricted_voice_and_video_messages: self.has_restricted_voice_and_video_messages,
            join_to_send_messages: self.join_to_send_messages,
            join_by_request: self.join_by_request,
            description: self.description,
            invite_link: self.invite_link,
            pinned_message: self.pinned_message,
            permissions: self.permissions,
            slow_mode_delay: self.slow_mode_delay,
            message_auto_delete_time: self.message_auto_delete_time,
            has_aggressive_anti_spam_enabled: self.has_aggressive_anti_spam_enabled,
            has_hidden_members: self.has_hidden_members,
            has_protected_content: self.has_protected_content,
            sticker_set_name: self.sticker_set_name,
            can_set_sticker_set: self.can_set_sticker_set,
            linked_chat_id: self.linked_chat_id,
            location: self.location,
        }
    }
}
impl NoSkipChat {
    pub fn skip(self) -> Chat {
        self.into()
    }
}
impl Chat {
    pub fn noskip(self) -> NoSkipChat {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(rename = "id")]
    id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of chat, can be either \"private\", \"group\", \"supergroup\" or \"channel\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title, for supergroups, channels and group chats"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username, for private chats, supergroups and channels if available"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "username", default)]
    username: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. First name of the other party in a private chat"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "first_name",
        default
    )]
    first_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Last name of the other party in a private chat"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "last_name", default)]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the supergroup chat is a forum (has topics enabled)"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "is_forum", default)]
    is_forum: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat photo. Returned only in getChat."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "photo", default)]
    photo: Option<ChatPhoto>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "active_usernames",
        default
    )]
    active_usernames: Option<Vec<String>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "emoji_status_custom_emoji_id",
        default
    )]
    emoji_status_custom_emoji_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "emoji_status_expiration_date",
        default
    )]
    emoji_status_expiration_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the other party in a private chat. Returned only in getChat."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "bio", default)]
    bio: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_private_forwards",
        default
    )]
    has_private_forwards: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_restricted_voice_and_video_messages",
        default
    )]
    has_restricted_voice_and_video_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "join_to_send_messages",
        default
    )]
    join_to_send_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "join_by_request",
        default
    )]
    join_by_request: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "invite_link",
        default
    )]
    invite_link: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The most recent pinned message (by sending date). Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "pinned_message",
        default
    )]
    pinned_message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "permissions",
        default
    )]
    permissions: Option<ChatPermissions>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "slow_mode_delay",
        default
    )]
    slow_mode_delay: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "message_auto_delete_time",
        default
    )]
    message_auto_delete_time: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_aggressive_anti_spam_enabled",
        default
    )]
    has_aggressive_anti_spam_enabled: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_hidden_members",
        default
    )]
    has_hidden_members: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_protected_content",
        default
    )]
    has_protected_content: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, name of group sticker set. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "sticker_set_name",
        default
    )]
    sticker_set_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can change the group sticker set. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_set_sticker_set",
        default
    )]
    can_set_sticker_set: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "linked_chat_id",
        default
    )]
    linked_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "location", default)]
    location: Option<ChatLocation>,
}
impl ChatBuilder {
    pub fn new(id: i64) -> Self {
        Self {
            tg_type: "Chat".to_owned(),
            id,
            title: None,
            username: None,
            first_name: None,
            last_name: None,
            is_forum: None,
            photo: None,
            active_usernames: None,
            emoji_status_custom_emoji_id: None,
            emoji_status_expiration_date: None,
            bio: None,
            has_private_forwards: None,
            has_restricted_voice_and_video_messages: None,
            join_to_send_messages: None,
            join_by_request: None,
            description: None,
            invite_link: None,
            pinned_message: None,
            permissions: None,
            slow_mode_delay: None,
            message_auto_delete_time: None,
            has_aggressive_anti_spam_enabled: None,
            has_hidden_members: None,
            has_protected_content: None,
            sticker_set_name: None,
            can_set_sticker_set: None,
            linked_chat_id: None,
            location: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_id(mut self, id: i64) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of chat, can be either \"private\", \"group\", \"supergroup\" or \"channel\""]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title, for supergroups, channels and group chats"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username, for private chats, supergroups and channels if available"]
    pub fn set_username(mut self, username: String) -> Self {
        self.username = Some(username);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. First name of the other party in a private chat"]
    pub fn set_first_name(mut self, first_name: String) -> Self {
        self.first_name = Some(first_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Last name of the other party in a private chat"]
    pub fn set_last_name(mut self, last_name: String) -> Self {
        self.last_name = Some(last_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the supergroup chat is a forum (has topics enabled)"]
    pub fn set_is_forum(mut self, is_forum: bool) -> Self {
        self.is_forum = Some(is_forum);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat photo. Returned only in getChat."]
    pub fn set_photo(mut self, photo: ChatPhoto) -> Self {
        self.photo = Some(photo);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."]
    pub fn set_active_usernames(mut self, active_usernames: Vec<String>) -> Self {
        self.active_usernames = Some(active_usernames);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."]
    pub fn set_emoji_status_custom_emoji_id(
        mut self,
        emoji_status_custom_emoji_id: String,
    ) -> Self {
        self.emoji_status_custom_emoji_id = Some(emoji_status_custom_emoji_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."]
    pub fn set_emoji_status_expiration_date(mut self, emoji_status_expiration_date: i64) -> Self {
        self.emoji_status_expiration_date = Some(emoji_status_expiration_date);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the other party in a private chat. Returned only in getChat."]
    pub fn set_bio(mut self, bio: String) -> Self {
        self.bio = Some(bio);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."]
    pub fn set_has_private_forwards(mut self, has_private_forwards: bool) -> Self {
        self.has_private_forwards = Some(has_private_forwards);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."]
    pub fn set_has_restricted_voice_and_video_messages(
        mut self,
        has_restricted_voice_and_video_messages: bool,
    ) -> Self {
        self.has_restricted_voice_and_video_messages =
            Some(has_restricted_voice_and_video_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."]
    pub fn set_join_to_send_messages(mut self, join_to_send_messages: bool) -> Self {
        self.join_to_send_messages = Some(join_to_send_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."]
    pub fn set_join_by_request(mut self, join_by_request: bool) -> Self {
        self.join_by_request = Some(join_by_request);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."]
    pub fn set_invite_link(mut self, invite_link: String) -> Self {
        self.invite_link = Some(invite_link);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The most recent pinned message (by sending date). Returned only in getChat."]
    pub fn set_pinned_message(mut self, pinned_message: Message) -> Self {
        self.pinned_message = Some(pinned_message);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."]
    pub fn set_permissions(mut self, permissions: ChatPermissions) -> Self {
        self.permissions = Some(permissions);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."]
    pub fn set_slow_mode_delay(mut self, slow_mode_delay: i64) -> Self {
        self.slow_mode_delay = Some(slow_mode_delay);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."]
    pub fn set_message_auto_delete_time(mut self, message_auto_delete_time: i64) -> Self {
        self.message_auto_delete_time = Some(message_auto_delete_time);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."]
    pub fn set_has_aggressive_anti_spam_enabled(
        mut self,
        has_aggressive_anti_spam_enabled: bool,
    ) -> Self {
        self.has_aggressive_anti_spam_enabled = Some(has_aggressive_anti_spam_enabled);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."]
    pub fn set_has_hidden_members(mut self, has_hidden_members: bool) -> Self {
        self.has_hidden_members = Some(has_hidden_members);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."]
    pub fn set_has_protected_content(mut self, has_protected_content: bool) -> Self {
        self.has_protected_content = Some(has_protected_content);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, name of group sticker set. Returned only in getChat."]
    pub fn set_sticker_set_name(mut self, sticker_set_name: String) -> Self {
        self.sticker_set_name = Some(sticker_set_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can change the group sticker set. Returned only in getChat."]
    pub fn set_can_set_sticker_set(mut self, can_set_sticker_set: bool) -> Self {
        self.can_set_sticker_set = Some(can_set_sticker_set);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."]
    pub fn set_linked_chat_id(mut self, linked_chat_id: i64) -> Self {
        self.linked_chat_id = Some(linked_chat_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."]
    pub fn set_location(mut self, location: ChatLocation) -> Self {
        self.location = Some(location);
        self
    }
    pub fn build(self) -> Chat {
        Chat {
            id: self.id,
            tg_type: self.tg_type,
            title: self.title,
            username: self.username,
            first_name: self.first_name,
            last_name: self.last_name,
            is_forum: self.is_forum,
            photo: self.photo,
            active_usernames: self.active_usernames,
            emoji_status_custom_emoji_id: self.emoji_status_custom_emoji_id,
            emoji_status_expiration_date: self.emoji_status_expiration_date,
            bio: self.bio,
            has_private_forwards: self.has_private_forwards,
            has_restricted_voice_and_video_messages: self.has_restricted_voice_and_video_messages,
            join_to_send_messages: self.join_to_send_messages,
            join_by_request: self.join_by_request,
            description: self.description,
            invite_link: self.invite_link,
            pinned_message: self.pinned_message,
            permissions: self.permissions,
            slow_mode_delay: self.slow_mode_delay,
            message_auto_delete_time: self.message_auto_delete_time,
            has_aggressive_anti_spam_enabled: self.has_aggressive_anti_spam_enabled,
            has_hidden_members: self.has_hidden_members,
            has_protected_content: self.has_protected_content,
            sticker_set_name: self.sticker_set_name,
            can_set_sticker_set: self.can_set_sticker_set,
            linked_chat_id: self.linked_chat_id,
            location: self.location,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents changes in the status of a chat member."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberUpdated {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat the user belongs to"]
    #[serde(rename = "chat")]
    chat: Box<Chat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Performer of the action, which resulted in the change"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the change was done in Unix time"]
    #[serde(rename = "date")]
    date: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    #[serde(rename = "old_chat_member")]
    old_chat_member: ChatMember,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    #[serde(rename = "new_chat_member")]
    new_chat_member: ChatMember,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "invite_link",
        default
    )]
    invite_link: Option<ChatInviteLink>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "via_chat_folder_invite_link",
        default
    )]
    via_chat_folder_invite_link: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatMemberUpdated that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatMemberUpdated {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat the user belongs to"]
    #[serde(rename = "chat")]
    chat: Box<Chat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Performer of the action, which resulted in the change"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the change was done in Unix time"]
    #[serde(rename = "date")]
    date: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    #[serde(rename = "old_chat_member")]
    old_chat_member: ChatMember,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    #[serde(rename = "new_chat_member")]
    new_chat_member: ChatMember,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."]
    invite_link: Option<ChatInviteLink>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    via_chat_folder_invite_link: Option<bool>,
}
impl From<NoSkipChatMemberUpdated> for ChatMemberUpdated {
    fn from(t: NoSkipChatMemberUpdated) -> Self {
        Self {
            chat: t.chat,
            from: t.from,
            date: t.date,
            old_chat_member: t.old_chat_member,
            new_chat_member: t.new_chat_member,
            invite_link: t.invite_link,
            via_chat_folder_invite_link: t.via_chat_folder_invite_link,
        }
    }
}
impl Into<NoSkipChatMemberUpdated> for ChatMemberUpdated {
    fn into(self) -> NoSkipChatMemberUpdated {
        NoSkipChatMemberUpdated {
            chat: self.chat,
            from: self.from,
            date: self.date,
            old_chat_member: self.old_chat_member,
            new_chat_member: self.new_chat_member,
            invite_link: self.invite_link,
            via_chat_folder_invite_link: self.via_chat_folder_invite_link,
        }
    }
}
impl NoSkipChatMemberUpdated {
    pub fn skip(self) -> ChatMemberUpdated {
        self.into()
    }
}
impl ChatMemberUpdated {
    pub fn noskip(self) -> NoSkipChatMemberUpdated {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents changes in the status of a chat member."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberUpdatedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat the user belongs to"]
    #[serde(rename = "chat")]
    chat: Box<Chat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Performer of the action, which resulted in the change"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the change was done in Unix time"]
    #[serde(rename = "date")]
    date: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    #[serde(rename = "old_chat_member")]
    old_chat_member: ChatMember,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    #[serde(rename = "new_chat_member")]
    new_chat_member: ChatMember,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "invite_link",
        default
    )]
    invite_link: Option<ChatInviteLink>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "via_chat_folder_invite_link",
        default
    )]
    via_chat_folder_invite_link: Option<bool>,
}
impl ChatMemberUpdatedBuilder {
    pub fn new(
        chat: Box<Chat>,
        from: User,
        date: i64,
        old_chat_member: ChatMember,
        new_chat_member: ChatMember,
    ) -> Self {
        Self {
            chat,
            from,
            date,
            old_chat_member,
            new_chat_member,
            invite_link: None,
            via_chat_folder_invite_link: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat the user belongs to"]
    pub fn set_chat(mut self, chat: Box<Chat>) -> Self {
        self.chat = chat;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Performer of the action, which resulted in the change"]
    pub fn set_from(mut self, from: User) -> Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the change was done in Unix time"]
    pub fn set_date(mut self, date: i64) -> Self {
        self.date = date;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    pub fn set_old_chat_member(mut self, old_chat_member: ChatMember) -> Self {
        self.old_chat_member = old_chat_member;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    pub fn set_new_chat_member(mut self, new_chat_member: ChatMember) -> Self {
        self.new_chat_member = new_chat_member;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."]
    pub fn set_invite_link(mut self, invite_link: ChatInviteLink) -> Self {
        self.invite_link = Some(invite_link);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    pub fn set_via_chat_folder_invite_link(mut self, via_chat_folder_invite_link: bool) -> Self {
        self.via_chat_folder_invite_link = Some(via_chat_folder_invite_link);
        self
    }
    pub fn build(self) -> ChatMemberUpdated {
        ChatMemberUpdated {
            chat: self.chat,
            from: self.from,
            date: self.date,
            old_chat_member: self.old_chat_member,
            new_chat_member: self.new_chat_member,
            invite_link: self.invite_link,
            via_chat_folder_invite_link: self.via_chat_folder_invite_link,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents the bot's description."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotDescription {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's description"]
    #[serde(rename = "description")]
    description: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotDescription that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotDescription {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's description"]
    #[serde(rename = "description")]
    description: String,
}
impl From<NoSkipBotDescription> for BotDescription {
    fn from(t: NoSkipBotDescription) -> Self {
        Self {
            description: t.description,
        }
    }
}
impl Into<NoSkipBotDescription> for BotDescription {
    fn into(self) -> NoSkipBotDescription {
        NoSkipBotDescription {
            description: self.description,
        }
    }
}
impl NoSkipBotDescription {
    pub fn skip(self) -> BotDescription {
        self.into()
    }
}
impl BotDescription {
    pub fn noskip(self) -> NoSkipBotDescription {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents the bot's description."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotDescriptionBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's description"]
    #[serde(rename = "description")]
    description: String,
}
impl BotDescriptionBuilder {
    pub fn new(description: String) -> Self {
        Self { description }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's description"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = description;
        self
    }
    pub fn build(self) -> BotDescription {
        BotDescription {
            description: self.description,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the content of a location message to be sent as the result of an inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputLocationMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "horizontal_accuracy",
        default
    )]
    horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "live_period",
        default
    )]
    live_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "heading", default)]
    heading: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "proximity_alert_radius",
        default
    )]
    proximity_alert_radius: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputLocationMessageContent that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputLocationMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    live_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    heading: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    proximity_alert_radius: Option<i64>,
}
impl From<NoSkipInputLocationMessageContent> for InputLocationMessageContent {
    fn from(t: NoSkipInputLocationMessageContent) -> Self {
        Self {
            latitude: t.latitude,
            longitude: t.longitude,
            horizontal_accuracy: t.horizontal_accuracy,
            live_period: t.live_period,
            heading: t.heading,
            proximity_alert_radius: t.proximity_alert_radius,
        }
    }
}
impl Into<NoSkipInputLocationMessageContent> for InputLocationMessageContent {
    fn into(self) -> NoSkipInputLocationMessageContent {
        NoSkipInputLocationMessageContent {
            latitude: self.latitude,
            longitude: self.longitude,
            horizontal_accuracy: self.horizontal_accuracy,
            live_period: self.live_period,
            heading: self.heading,
            proximity_alert_radius: self.proximity_alert_radius,
        }
    }
}
impl NoSkipInputLocationMessageContent {
    pub fn skip(self) -> InputLocationMessageContent {
        self.into()
    }
}
impl InputLocationMessageContent {
    pub fn noskip(self) -> NoSkipInputLocationMessageContent {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the content of a location message to be sent as the result of an inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputLocationMessageContentBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "horizontal_accuracy",
        default
    )]
    horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "live_period",
        default
    )]
    live_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "heading", default)]
    heading: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "proximity_alert_radius",
        default
    )]
    proximity_alert_radius: Option<i64>,
}
impl InputLocationMessageContentBuilder {
    pub fn new(
        latitude: ::ordered_float::OrderedFloat<f64>,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> Self {
        Self {
            latitude,
            longitude,
            horizontal_accuracy: None,
            live_period: None,
            heading: None,
            proximity_alert_radius: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    pub fn set_latitude(mut self, latitude: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    pub fn set_longitude(mut self, longitude: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn set_horizontal_accuracy(
        mut self,
        horizontal_accuracy: ::ordered_float::OrderedFloat<f64>,
    ) -> Self {
        self.horizontal_accuracy = Some(horizontal_accuracy);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    pub fn set_live_period(mut self, live_period: i64) -> Self {
        self.live_period = Some(live_period);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    pub fn set_heading(mut self, heading: i64) -> Self {
        self.heading = Some(heading);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    pub fn set_proximity_alert_radius(mut self, proximity_alert_radius: i64) -> Self {
        self.proximity_alert_radius = Some(proximity_alert_radius);
        self
    }
    pub fn build(self) -> InputLocationMessageContent {
        InputLocationMessageContent {
            latitude: self.latitude,
            longitude: self.longitude,
            horizontal_accuracy: self.horizontal_accuracy,
            live_period: self.live_period,
            heading: self.heading,
            proximity_alert_radius: self.proximity_alert_radius,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a custom keyboard with reply options (see Introduction to bots for details and examples)."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ReplyKeyboardMarkup {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of KeyboardButton objects"]
    #[serde(rename = "keyboard")]
    keyboard: Vec<Vec<KeyboardButton>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "is_persistent",
        default
    )]
    is_persistent: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "resize_keyboard",
        default
    )]
    resize_keyboard: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "one_time_keyboard",
        default
    )]
    one_time_keyboard: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_field_placeholder",
        default
    )]
    input_field_placeholder: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "selective", default)]
    selective: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ReplyKeyboardMarkup that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipReplyKeyboardMarkup {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of KeyboardButton objects"]
    #[serde(rename = "keyboard")]
    keyboard: Vec<Vec<KeyboardButton>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."]
    is_persistent: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."]
    resize_keyboard: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."]
    one_time_keyboard: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"]
    input_field_placeholder: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."]
    selective: Option<bool>,
}
impl From<NoSkipReplyKeyboardMarkup> for ReplyKeyboardMarkup {
    fn from(t: NoSkipReplyKeyboardMarkup) -> Self {
        Self {
            keyboard: t.keyboard,
            is_persistent: t.is_persistent,
            resize_keyboard: t.resize_keyboard,
            one_time_keyboard: t.one_time_keyboard,
            input_field_placeholder: t.input_field_placeholder,
            selective: t.selective,
        }
    }
}
impl Into<NoSkipReplyKeyboardMarkup> for ReplyKeyboardMarkup {
    fn into(self) -> NoSkipReplyKeyboardMarkup {
        NoSkipReplyKeyboardMarkup {
            keyboard: self.keyboard,
            is_persistent: self.is_persistent,
            resize_keyboard: self.resize_keyboard,
            one_time_keyboard: self.one_time_keyboard,
            input_field_placeholder: self.input_field_placeholder,
            selective: self.selective,
        }
    }
}
impl NoSkipReplyKeyboardMarkup {
    pub fn skip(self) -> ReplyKeyboardMarkup {
        self.into()
    }
}
impl ReplyKeyboardMarkup {
    pub fn noskip(self) -> NoSkipReplyKeyboardMarkup {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a custom keyboard with reply options (see Introduction to bots for details and examples)."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ReplyKeyboardMarkupBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of KeyboardButton objects"]
    #[serde(rename = "keyboard")]
    keyboard: Vec<Vec<KeyboardButton>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "is_persistent",
        default
    )]
    is_persistent: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "resize_keyboard",
        default
    )]
    resize_keyboard: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "one_time_keyboard",
        default
    )]
    one_time_keyboard: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_field_placeholder",
        default
    )]
    input_field_placeholder: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "selective", default)]
    selective: Option<bool>,
}
impl ReplyKeyboardMarkupBuilder {
    pub fn new(keyboard: Vec<Vec<KeyboardButton>>) -> Self {
        Self {
            keyboard,
            is_persistent: None,
            resize_keyboard: None,
            one_time_keyboard: None,
            input_field_placeholder: None,
            selective: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of KeyboardButton objects"]
    pub fn set_keyboard(mut self, keyboard: Vec<Vec<KeyboardButton>>) -> Self {
        self.keyboard = keyboard;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."]
    pub fn set_is_persistent(mut self, is_persistent: bool) -> Self {
        self.is_persistent = Some(is_persistent);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."]
    pub fn set_resize_keyboard(mut self, resize_keyboard: bool) -> Self {
        self.resize_keyboard = Some(resize_keyboard);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."]
    pub fn set_one_time_keyboard(mut self, one_time_keyboard: bool) -> Self {
        self.one_time_keyboard = Some(one_time_keyboard);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"]
    pub fn set_input_field_placeholder(mut self, input_field_placeholder: String) -> Self {
        self.input_field_placeholder = Some(input_field_placeholder);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."]
    pub fn set_selective(mut self, selective: bool) -> Self {
        self.selective = Some(selective);
        self
    }
    pub fn build(self) -> ReplyKeyboardMarkup {
        ReplyKeyboardMarkup {
            keyboard: self.keyboard,
            is_persistent: self.is_persistent,
            resize_keyboard: self.resize_keyboard,
            one_time_keyboard: self.one_time_keyboard,
            input_field_placeholder: self.input_field_placeholder,
            selective: self.selective,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a unique message identifier."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MessageId {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier"]
    #[serde(rename = "message_id")]
    message_id: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to MessageId that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipMessageId {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier"]
    #[serde(rename = "message_id")]
    message_id: i64,
}
impl From<NoSkipMessageId> for MessageId {
    fn from(t: NoSkipMessageId) -> Self {
        Self {
            message_id: t.message_id,
        }
    }
}
impl Into<NoSkipMessageId> for MessageId {
    fn into(self) -> NoSkipMessageId {
        NoSkipMessageId {
            message_id: self.message_id,
        }
    }
}
impl NoSkipMessageId {
    pub fn skip(self) -> MessageId {
        self.into()
    }
}
impl MessageId {
    pub fn noskip(self) -> NoSkipMessageId {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a unique message identifier."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MessageIdBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier"]
    #[serde(rename = "message_id")]
    message_id: i64,
}
impl MessageIdBuilder {
    pub fn new(message_id: i64) -> Self {
        Self { message_id }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier"]
    pub fn set_message_id(mut self, message_id: i64) -> Self {
        self.message_id = message_id;
        self
    }
    pub fn build(self) -> MessageId {
        MessageId {
            message_id: self.message_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about one answer option in a poll."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PollOption {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option text, 1-100 characters"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of users that voted for this option"]
    #[serde(rename = "voter_count")]
    voter_count: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PollOption that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPollOption {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option text, 1-100 characters"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of users that voted for this option"]
    #[serde(rename = "voter_count")]
    voter_count: i64,
}
impl From<NoSkipPollOption> for PollOption {
    fn from(t: NoSkipPollOption) -> Self {
        Self {
            text: t.text,
            voter_count: t.voter_count,
        }
    }
}
impl Into<NoSkipPollOption> for PollOption {
    fn into(self) -> NoSkipPollOption {
        NoSkipPollOption {
            text: self.text,
            voter_count: self.voter_count,
        }
    }
}
impl NoSkipPollOption {
    pub fn skip(self) -> PollOption {
        self.into()
    }
}
impl PollOption {
    pub fn noskip(self) -> NoSkipPollOption {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about one answer option in a poll."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PollOptionBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option text, 1-100 characters"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of users that voted for this option"]
    #[serde(rename = "voter_count")]
    voter_count: i64,
}
impl PollOptionBuilder {
    pub fn new(text: String, voter_count: i64) -> Self {
        Self { text, voter_count }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option text, 1-100 characters"]
    pub fn set_text(mut self, text: String) -> Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of users that voted for this option"]
    pub fn set_voter_count(mut self, voter_count: i64) -> Self {
        self.voter_count = voter_count;
        self
    }
    pub fn build(self) -> PollOption {
        PollOption {
            text: self.text,
            voter_count: self.voter_count,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents the bot's short description."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotShortDescription {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's short description"]
    #[serde(rename = "short_description")]
    short_description: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotShortDescription that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotShortDescription {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's short description"]
    #[serde(rename = "short_description")]
    short_description: String,
}
impl From<NoSkipBotShortDescription> for BotShortDescription {
    fn from(t: NoSkipBotShortDescription) -> Self {
        Self {
            short_description: t.short_description,
        }
    }
}
impl Into<NoSkipBotShortDescription> for BotShortDescription {
    fn into(self) -> NoSkipBotShortDescription {
        NoSkipBotShortDescription {
            short_description: self.short_description,
        }
    }
}
impl NoSkipBotShortDescription {
    pub fn skip(self) -> BotShortDescription {
        self.into()
    }
}
impl BotShortDescription {
    pub fn noskip(self) -> NoSkipBotShortDescription {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents the bot's short description."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotShortDescriptionBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's short description"]
    #[serde(rename = "short_description")]
    short_description: String,
}
impl BotShortDescriptionBuilder {
    pub fn new(short_description: String) -> Self {
        Self { short_description }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's short description"]
    pub fn set_short_description(mut self, short_description: String) -> Self {
        self.short_description = short_description;
        self
    }
    pub fn build(self) -> BotShortDescription {
        BotShortDescription {
            short_description: self.short_description,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a video to be sent."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputMediaVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "width", default)]
    width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "height", default)]
    height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "duration", default)]
    duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "supports_streaming",
        default
    )]
    supports_streaming: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_spoiler",
        default
    )]
    has_spoiler: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputMediaVideo that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputMediaVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    supports_streaming: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    has_spoiler: Option<bool>,
}
impl From<NoSkipInputMediaVideo> for InputMediaVideo {
    fn from(t: NoSkipInputMediaVideo) -> Self {
        Self {
            tg_type: t.tg_type,
            media: t.media,
            thumbnail: t.thumbnail,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            width: t.width,
            height: t.height,
            duration: t.duration,
            supports_streaming: t.supports_streaming,
            has_spoiler: t.has_spoiler,
        }
    }
}
impl Into<NoSkipInputMediaVideo> for InputMediaVideo {
    fn into(self) -> NoSkipInputMediaVideo {
        NoSkipInputMediaVideo {
            tg_type: self.tg_type,
            media: self.media,
            thumbnail: self.thumbnail,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            width: self.width,
            height: self.height,
            duration: self.duration,
            supports_streaming: self.supports_streaming,
            has_spoiler: self.has_spoiler,
        }
    }
}
impl NoSkipInputMediaVideo {
    pub fn skip(self) -> InputMediaVideo {
        self.into()
    }
}
impl InputMediaVideo {
    pub fn noskip(self) -> NoSkipInputMediaVideo {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a video to be sent."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputMediaVideoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "width", default)]
    width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "height", default)]
    height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "duration", default)]
    duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "supports_streaming",
        default
    )]
    supports_streaming: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_spoiler",
        default
    )]
    has_spoiler: Option<bool>,
}
impl InputMediaVideoBuilder {
    pub fn new(media: Option<InputFile>) -> Self {
        Self {
            tg_type: "video".to_owned(),
            media,
            thumbnail: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            width: None,
            height: None,
            duration: None,
            supports_streaming: None,
            has_spoiler: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_media(mut self, media: Option<InputFile>) -> Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_thumbnail(mut self, thumbnail: InputFile) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn set_width(mut self, width: i64) -> Self {
        self.width = Some(width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn set_height(mut self, height: i64) -> Self {
        self.height = Some(height);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn set_duration(mut self, duration: i64) -> Self {
        self.duration = Some(duration);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    pub fn set_supports_streaming(mut self, supports_streaming: bool) -> Self {
        self.supports_streaming = Some(supports_streaming);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    pub fn set_has_spoiler(mut self, has_spoiler: bool) -> Self {
        self.has_spoiler = Some(has_spoiler);
        self
    }
    pub fn build(self) -> InputMediaVideo {
        InputMediaVideo {
            tg_type: self.tg_type,
            media: self.media,
            thumbnail: self.thumbnail,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            width: self.width,
            height: self.height,
            duration: self.duration,
            supports_streaming: self.supports_streaming,
            has_spoiler: self.has_spoiler,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with the front side of a document. The error is considered resolved when the file with the front side of the document changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorFrontSide {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportElementErrorFrontSide that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportElementErrorFrontSide {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl From<NoSkipPassportElementErrorFrontSide> for PassportElementErrorFrontSide {
    fn from(t: NoSkipPassportElementErrorFrontSide) -> Self {
        Self {
            source: t.source,
            tg_type: t.tg_type,
            file_hash: t.file_hash,
            message: t.message,
        }
    }
}
impl Into<NoSkipPassportElementErrorFrontSide> for PassportElementErrorFrontSide {
    fn into(self) -> NoSkipPassportElementErrorFrontSide {
        NoSkipPassportElementErrorFrontSide {
            source: self.source,
            tg_type: self.tg_type,
            file_hash: self.file_hash,
            message: self.message,
        }
    }
}
impl NoSkipPassportElementErrorFrontSide {
    pub fn skip(self) -> PassportElementErrorFrontSide {
        self.into()
    }
}
impl PassportElementErrorFrontSide {
    pub fn noskip(self) -> NoSkipPassportElementErrorFrontSide {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with the front side of a document. The error is considered resolved when the file with the front side of the document changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorFrontSideBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl PassportElementErrorFrontSideBuilder {
    pub fn new(source: String, file_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorFrontSide".to_owned(),
            source,
            file_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    pub fn set_source(mut self, source: String) -> Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    pub fn set_file_hash(mut self, file_hash: String) -> Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message(mut self, message: String) -> Self {
        self.message = message;
        self
    }
    pub fn build(self) -> PassportElementErrorFrontSide {
        PassportElementErrorFrontSide {
            source: self.source,
            tg_type: self.tg_type,
            file_hash: self.file_hash,
            message: self.message,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes that no specific value for the menu button was set."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MenuButtonDefault {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    #[serde(rename = "type")]
    tg_type: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to MenuButtonDefault that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipMenuButtonDefault {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl From<NoSkipMenuButtonDefault> for MenuButtonDefault {
    fn from(t: NoSkipMenuButtonDefault) -> Self {
        Self { tg_type: t.tg_type }
    }
}
impl Into<NoSkipMenuButtonDefault> for MenuButtonDefault {
    fn into(self) -> NoSkipMenuButtonDefault {
        NoSkipMenuButtonDefault {
            tg_type: self.tg_type,
        }
    }
}
impl NoSkipMenuButtonDefault {
    pub fn skip(self) -> MenuButtonDefault {
        self.into()
    }
}
impl MenuButtonDefault {
    pub fn noskip(self) -> NoSkipMenuButtonDefault {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes that no specific value for the menu button was set."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MenuButtonDefaultBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl MenuButtonDefaultBuilder {
    pub fn new() -> Self {
        Self {
            tg_type: "default".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    pub fn build(self) -> MenuButtonDefault {
        MenuButtonDefault {
            tg_type: self.tg_type,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes data required for decrypting and authenticating EncryptedPassportElement. See the Telegram Passport Documentation for a complete description of the data decryption and authentication processes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct EncryptedCredentials {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"]
    #[serde(rename = "data")]
    data: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash for data authentication"]
    #[serde(rename = "hash")]
    hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"]
    #[serde(rename = "secret")]
    secret: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to EncryptedCredentials that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipEncryptedCredentials {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"]
    #[serde(rename = "data")]
    data: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash for data authentication"]
    #[serde(rename = "hash")]
    hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"]
    #[serde(rename = "secret")]
    secret: String,
}
impl From<NoSkipEncryptedCredentials> for EncryptedCredentials {
    fn from(t: NoSkipEncryptedCredentials) -> Self {
        Self {
            data: t.data,
            hash: t.hash,
            secret: t.secret,
        }
    }
}
impl Into<NoSkipEncryptedCredentials> for EncryptedCredentials {
    fn into(self) -> NoSkipEncryptedCredentials {
        NoSkipEncryptedCredentials {
            data: self.data,
            hash: self.hash,
            secret: self.secret,
        }
    }
}
impl NoSkipEncryptedCredentials {
    pub fn skip(self) -> EncryptedCredentials {
        self.into()
    }
}
impl EncryptedCredentials {
    pub fn noskip(self) -> NoSkipEncryptedCredentials {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes data required for decrypting and authenticating EncryptedPassportElement. See the Telegram Passport Documentation for a complete description of the data decryption and authentication processes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct EncryptedCredentialsBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"]
    #[serde(rename = "data")]
    data: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash for data authentication"]
    #[serde(rename = "hash")]
    hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"]
    #[serde(rename = "secret")]
    secret: String,
}
impl EncryptedCredentialsBuilder {
    pub fn new(data: String, hash: String, secret: String) -> Self {
        Self { data, hash, secret }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"]
    pub fn set_data(mut self, data: String) -> Self {
        self.data = data;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash for data authentication"]
    pub fn set_hash(mut self, hash: String) -> Self {
        self.hash = hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"]
    pub fn set_secret(mut self, secret: String) -> Self {
        self.secret = secret;
        self
    }
    pub fn build(self) -> EncryptedCredentials {
        EncryptedCredentials {
            data: self.data,
            hash: self.hash,
            secret: self.secret,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with a document scan. The error is considered resolved when the file with the document scan changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportElementErrorFile that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportElementErrorFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl From<NoSkipPassportElementErrorFile> for PassportElementErrorFile {
    fn from(t: NoSkipPassportElementErrorFile) -> Self {
        Self {
            source: t.source,
            tg_type: t.tg_type,
            file_hash: t.file_hash,
            message: t.message,
        }
    }
}
impl Into<NoSkipPassportElementErrorFile> for PassportElementErrorFile {
    fn into(self) -> NoSkipPassportElementErrorFile {
        NoSkipPassportElementErrorFile {
            source: self.source,
            tg_type: self.tg_type,
            file_hash: self.file_hash,
            message: self.message,
        }
    }
}
impl NoSkipPassportElementErrorFile {
    pub fn skip(self) -> PassportElementErrorFile {
        self.into()
    }
}
impl PassportElementErrorFile {
    pub fn noskip(self) -> NoSkipPassportElementErrorFile {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with a document scan. The error is considered resolved when the file with the document scan changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorFileBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl PassportElementErrorFileBuilder {
    pub fn new(source: String, file_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorFile".to_owned(),
            source,
            file_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    pub fn set_source(mut self, source: String) -> Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    pub fn set_file_hash(mut self, file_hash: String) -> Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message(mut self, message: String) -> Self {
        self.message = message;
        self
    }
    pub fn build(self) -> PassportElementErrorFile {
        PassportElementErrorFile {
            source: self.source,
            tg_type: self.tg_type,
            file_hash: self.file_hash,
            message: self.message,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one row of the high scores table for a game."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct GameHighScore {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Position in high score table for the game"]
    #[serde(rename = "position")]
    position: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Score"]
    #[serde(rename = "score")]
    score: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to GameHighScore that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipGameHighScore {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Position in high score table for the game"]
    #[serde(rename = "position")]
    position: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Score"]
    #[serde(rename = "score")]
    score: i64,
}
impl From<NoSkipGameHighScore> for GameHighScore {
    fn from(t: NoSkipGameHighScore) -> Self {
        Self {
            position: t.position,
            user: t.user,
            score: t.score,
        }
    }
}
impl Into<NoSkipGameHighScore> for GameHighScore {
    fn into(self) -> NoSkipGameHighScore {
        NoSkipGameHighScore {
            position: self.position,
            user: self.user,
            score: self.score,
        }
    }
}
impl NoSkipGameHighScore {
    pub fn skip(self) -> GameHighScore {
        self.into()
    }
}
impl GameHighScore {
    pub fn noskip(self) -> NoSkipGameHighScore {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one row of the high scores table for a game."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct GameHighScoreBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Position in high score table for the game"]
    #[serde(rename = "position")]
    position: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Score"]
    #[serde(rename = "score")]
    score: i64,
}
impl GameHighScoreBuilder {
    pub fn new(position: i64, user: User, score: i64) -> Self {
        Self {
            position,
            user,
            score,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Position in high score table for the game"]
    pub fn set_position(mut self, position: i64) -> Self {
        self.position = position;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User"]
    pub fn set_user(mut self, user: User) -> Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Score"]
    pub fn set_score(mut self, score: i64) -> Self {
        self.score = score;
        self
    }
    pub fn build(self) -> GameHighScore {
        GameHighScore {
            position: self.position,
            user: self.user,
            score: self.score,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about an incoming shipping query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ShippingQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    #[serde(rename = "invoice_payload")]
    invoice_payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    #[serde(rename = "shipping_address")]
    shipping_address: ShippingAddress,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ShippingQuery that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipShippingQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    #[serde(rename = "invoice_payload")]
    invoice_payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    #[serde(rename = "shipping_address")]
    shipping_address: ShippingAddress,
}
impl From<NoSkipShippingQuery> for ShippingQuery {
    fn from(t: NoSkipShippingQuery) -> Self {
        Self {
            id: t.id,
            from: t.from,
            invoice_payload: t.invoice_payload,
            shipping_address: t.shipping_address,
        }
    }
}
impl Into<NoSkipShippingQuery> for ShippingQuery {
    fn into(self) -> NoSkipShippingQuery {
        NoSkipShippingQuery {
            id: self.id,
            from: self.from,
            invoice_payload: self.invoice_payload,
            shipping_address: self.shipping_address,
        }
    }
}
impl NoSkipShippingQuery {
    pub fn skip(self) -> ShippingQuery {
        self.into()
    }
}
impl ShippingQuery {
    pub fn noskip(self) -> NoSkipShippingQuery {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about an incoming shipping query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ShippingQueryBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    #[serde(rename = "invoice_payload")]
    invoice_payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    #[serde(rename = "shipping_address")]
    shipping_address: ShippingAddress,
}
impl ShippingQueryBuilder {
    pub fn new(
        id: String,
        from: User,
        invoice_payload: String,
        shipping_address: ShippingAddress,
    ) -> Self {
        Self {
            id,
            from,
            invoice_payload,
            shipping_address,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    pub fn set_from(mut self, from: User) -> Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn set_invoice_payload(mut self, invoice_payload: String) -> Self {
        self.invoice_payload = invoice_payload;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    pub fn set_shipping_address(mut self, shipping_address: ShippingAddress) -> Self {
        self.shipping_address = shipping_address;
        self
    }
    pub fn build(self) -> ShippingQuery {
        ShippingQuery {
            id: self.id,
            from: self.from,
            invoice_payload: self.invoice_payload,
            shipping_address: self.shipping_address,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a page containing an embedded video player or a video file. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the video."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    #[serde(rename = "video_url")]
    video_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    #[serde(rename = "mime_type")]
    mime_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_width",
        default
    )]
    video_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_height",
        default
    )]
    video_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_duration",
        default
    )]
    video_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultVideo that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    #[serde(rename = "video_url")]
    video_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    #[serde(rename = "mime_type")]
    mime_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    video_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    video_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    video_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultVideo> for InlineQueryResultVideo {
    fn from(t: NoSkipInlineQueryResultVideo) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            video_url: t.video_url,
            mime_type: t.mime_type,
            thumbnail_url: t.thumbnail_url,
            title: t.title,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            video_width: t.video_width,
            video_height: t.video_height,
            video_duration: t.video_duration,
            description: t.description,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultVideo> for InlineQueryResultVideo {
    fn into(self) -> NoSkipInlineQueryResultVideo {
        NoSkipInlineQueryResultVideo {
            tg_type: self.tg_type,
            id: self.id,
            video_url: self.video_url,
            mime_type: self.mime_type,
            thumbnail_url: self.thumbnail_url,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            video_width: self.video_width,
            video_height: self.video_height,
            video_duration: self.video_duration,
            description: self.description,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultVideo {
    pub fn skip(self) -> InlineQueryResultVideo {
        self.into()
    }
}
impl InlineQueryResultVideo {
    pub fn noskip(self) -> NoSkipInlineQueryResultVideo {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a page containing an embedded video player or a video file. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the video."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultVideoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    #[serde(rename = "video_url")]
    video_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    #[serde(rename = "mime_type")]
    mime_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_width",
        default
    )]
    video_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_height",
        default
    )]
    video_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_duration",
        default
    )]
    video_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultVideoBuilder {
    pub fn new(
        id: String,
        video_url: String,
        mime_type: String,
        thumbnail_url: String,
        title: String,
    ) -> Self {
        Self {
            tg_type: "video".to_owned(),
            id,
            video_url,
            mime_type,
            thumbnail_url,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            video_width: None,
            video_height: None,
            video_duration: None,
            description: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    pub fn set_video_url(mut self, video_url: String) -> Self {
        self.video_url = video_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    pub fn set_mime_type(mut self, mime_type: String) -> Self {
        self.mime_type = mime_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    pub fn set_thumbnail_url(mut self, thumbnail_url: String) -> Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn set_video_width(mut self, video_width: i64) -> Self {
        self.video_width = Some(video_width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn set_video_height(mut self, video_height: i64) -> Self {
        self.video_height = Some(video_height);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn set_video_duration(mut self, video_duration: i64) -> Self {
        self.video_duration = Some(video_duration);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultVideo {
        InlineQueryResultVideo {
            tg_type: self.tg_type,
            id: self.id,
            video_url: self.video_url,
            mime_type: self.mime_type,
            thumbnail_url: self.thumbnail_url,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            video_width: self.video_width,
            video_height: self.video_height,
            video_duration: self.video_duration,
            description: self.description,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an inline button that switches the current user to inline mode in a chosen chat, with an optional default inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SwitchInlineQueryChosenChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "query", default)]
    query: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with users can be chosen"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "allow_user_chats",
        default
    )]
    allow_user_chats: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with bots can be chosen"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "allow_bot_chats",
        default
    )]
    allow_bot_chats: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if group and supergroup chats can be chosen"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "allow_group_chats",
        default
    )]
    allow_group_chats: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if channel chats can be chosen"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "allow_channel_chats",
        default
    )]
    allow_channel_chats: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to SwitchInlineQueryChosenChat that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipSwitchInlineQueryChosenChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"]
    query: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with users can be chosen"]
    allow_user_chats: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with bots can be chosen"]
    allow_bot_chats: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if group and supergroup chats can be chosen"]
    allow_group_chats: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if channel chats can be chosen"]
    allow_channel_chats: Option<bool>,
}
impl From<NoSkipSwitchInlineQueryChosenChat> for SwitchInlineQueryChosenChat {
    fn from(t: NoSkipSwitchInlineQueryChosenChat) -> Self {
        Self {
            query: t.query,
            allow_user_chats: t.allow_user_chats,
            allow_bot_chats: t.allow_bot_chats,
            allow_group_chats: t.allow_group_chats,
            allow_channel_chats: t.allow_channel_chats,
        }
    }
}
impl Into<NoSkipSwitchInlineQueryChosenChat> for SwitchInlineQueryChosenChat {
    fn into(self) -> NoSkipSwitchInlineQueryChosenChat {
        NoSkipSwitchInlineQueryChosenChat {
            query: self.query,
            allow_user_chats: self.allow_user_chats,
            allow_bot_chats: self.allow_bot_chats,
            allow_group_chats: self.allow_group_chats,
            allow_channel_chats: self.allow_channel_chats,
        }
    }
}
impl NoSkipSwitchInlineQueryChosenChat {
    pub fn skip(self) -> SwitchInlineQueryChosenChat {
        self.into()
    }
}
impl SwitchInlineQueryChosenChat {
    pub fn noskip(self) -> NoSkipSwitchInlineQueryChosenChat {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an inline button that switches the current user to inline mode in a chosen chat, with an optional default inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SwitchInlineQueryChosenChatBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "query", default)]
    query: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with users can be chosen"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "allow_user_chats",
        default
    )]
    allow_user_chats: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with bots can be chosen"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "allow_bot_chats",
        default
    )]
    allow_bot_chats: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if group and supergroup chats can be chosen"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "allow_group_chats",
        default
    )]
    allow_group_chats: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if channel chats can be chosen"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "allow_channel_chats",
        default
    )]
    allow_channel_chats: Option<bool>,
}
impl SwitchInlineQueryChosenChatBuilder {
    pub fn new() -> Self {
        Self {
            query: None,
            allow_user_chats: None,
            allow_bot_chats: None,
            allow_group_chats: None,
            allow_channel_chats: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"]
    pub fn set_query(mut self, query: String) -> Self {
        self.query = Some(query);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with users can be chosen"]
    pub fn set_allow_user_chats(mut self, allow_user_chats: bool) -> Self {
        self.allow_user_chats = Some(allow_user_chats);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with bots can be chosen"]
    pub fn set_allow_bot_chats(mut self, allow_bot_chats: bool) -> Self {
        self.allow_bot_chats = Some(allow_bot_chats);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if group and supergroup chats can be chosen"]
    pub fn set_allow_group_chats(mut self, allow_group_chats: bool) -> Self {
        self.allow_group_chats = Some(allow_group_chats);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if channel chats can be chosen"]
    pub fn set_allow_channel_chats(mut self, allow_channel_chats: bool) -> Self {
        self.allow_channel_chats = Some(allow_channel_chats);
        self
    }
    pub fn build(self) -> SwitchInlineQueryChosenChat {
        SwitchInlineQueryChosenChat {
            query: self.query,
            allow_user_chats: self.allow_user_chats,
            allow_bot_chats: self.allow_bot_chats,
            allow_group_chats: self.allow_group_chats,
            allow_channel_chats: self.allow_channel_chats,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a general file (as opposed to photos, voice messages and audio files)."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Document {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Document thumbnail as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_name", default)]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "mime_type", default)]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Document that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Document thumbnail as defined by sender"]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    file_size: Option<i64>,
}
impl From<NoSkipDocument> for Document {
    fn from(t: NoSkipDocument) -> Self {
        Self {
            file_id: t.file_id,
            file_unique_id: t.file_unique_id,
            thumbnail: t.thumbnail,
            file_name: t.file_name,
            mime_type: t.mime_type,
            file_size: t.file_size,
        }
    }
}
impl Into<NoSkipDocument> for Document {
    fn into(self) -> NoSkipDocument {
        NoSkipDocument {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            thumbnail: self.thumbnail,
            file_name: self.file_name,
            mime_type: self.mime_type,
            file_size: self.file_size,
        }
    }
}
impl NoSkipDocument {
    pub fn skip(self) -> Document {
        self.into()
    }
}
impl Document {
    pub fn noskip(self) -> NoSkipDocument {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a general file (as opposed to photos, voice messages and audio files)."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct DocumentBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Document thumbnail as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_name", default)]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "mime_type", default)]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
impl DocumentBuilder {
    pub fn new(file_id: String, file_unique_id: String) -> Self {
        Self {
            file_id,
            file_unique_id,
            thumbnail: None,
            file_name: None,
            mime_type: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id(mut self, file_id: String) -> Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id(mut self, file_unique_id: String) -> Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Document thumbnail as defined by sender"]
    pub fn set_thumbnail(mut self, thumbnail: PhotoSize) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn set_file_name(mut self, file_name: String) -> Self {
        self.file_name = Some(file_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn set_mime_type(mut self, mime_type: String) -> Self {
        self.mime_type = Some(mime_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size(mut self, file_size: i64) -> Self {
        self.file_size = Some(file_size);
        self
    }
    pub fn build(self) -> Document {
        Document {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            thumbnail: self.thumbnail,
            file_name: self.file_name,
            mime_type: self.mime_type,
            file_size: self.file_size,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with the translated version of a document. The error is considered resolved when a file with the document translation change."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorTranslationFiles {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    #[serde(rename = "file_hashes")]
    file_hashes: Vec<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportElementErrorTranslationFiles that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportElementErrorTranslationFiles {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    #[serde(rename = "file_hashes")]
    file_hashes: Vec<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl From<NoSkipPassportElementErrorTranslationFiles> for PassportElementErrorTranslationFiles {
    fn from(t: NoSkipPassportElementErrorTranslationFiles) -> Self {
        Self {
            source: t.source,
            tg_type: t.tg_type,
            file_hashes: t.file_hashes,
            message: t.message,
        }
    }
}
impl Into<NoSkipPassportElementErrorTranslationFiles> for PassportElementErrorTranslationFiles {
    fn into(self) -> NoSkipPassportElementErrorTranslationFiles {
        NoSkipPassportElementErrorTranslationFiles {
            source: self.source,
            tg_type: self.tg_type,
            file_hashes: self.file_hashes,
            message: self.message,
        }
    }
}
impl NoSkipPassportElementErrorTranslationFiles {
    pub fn skip(self) -> PassportElementErrorTranslationFiles {
        self.into()
    }
}
impl PassportElementErrorTranslationFiles {
    pub fn noskip(self) -> NoSkipPassportElementErrorTranslationFiles {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with the translated version of a document. The error is considered resolved when a file with the document translation change."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorTranslationFilesBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    #[serde(rename = "file_hashes")]
    file_hashes: Vec<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl PassportElementErrorTranslationFilesBuilder {
    pub fn new(source: String, file_hashes: Vec<String>, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorTranslationFiles".to_owned(),
            source,
            file_hashes,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    pub fn set_source(mut self, source: String) -> Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    pub fn set_file_hashes(mut self, file_hashes: Vec<String>) -> Self {
        self.file_hashes = file_hashes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message(mut self, message: String) -> Self {
        self.message = message;
        self
    }
    pub fn build(self) -> PassportElementErrorTranslationFiles {
        PassportElementErrorTranslationFiles {
            source: self.source,
            tg_type: self.tg_type,
            file_hashes: self.file_hashes,
            message: self.message,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one special entity in a text message. For example, hashtags, usernames, URLs, etc."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MessageEntity {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the entity. Currently, can be \"mention\" (@username), \"hashtag\" (#hashtag), \"cashtag\" ($USD), \"bot_command\" (/start@jobs_bot), \"url\" (https://telegram.org), \"email\" (do-not-reply@telegram.org), \"phone_number\" (+1-212-555-0123), \"bold\" (bold text), \"italic\" (italic text), \"underline\" (underlined text), \"strikethrough\" (strikethrough text), \"spoiler\" (spoiler message), \"code\" (monowidth string), \"pre\" (monowidth block), \"text_link\" (for clickable text URLs), \"text_mention\" (for users without usernames), \"custom_emoji\" (for inline custom emoji stickers)"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset in UTF-16 code units to the start of the entity"]
    #[serde(rename = "offset")]
    offset: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Length of the entity in UTF-16 code units"]
    #[serde(rename = "length")]
    length: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_link\" only, URL that will be opened after user taps on the text"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "url", default)]
    url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_mention\" only, the mentioned user"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "user", default)]
    user: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"pre\" only, the programming language of the entity text"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "language", default)]
    language: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"custom_emoji\" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "custom_emoji_id",
        default
    )]
    custom_emoji_id: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to MessageEntity that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipMessageEntity {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the entity. Currently, can be \"mention\" (@username), \"hashtag\" (#hashtag), \"cashtag\" ($USD), \"bot_command\" (/start@jobs_bot), \"url\" (https://telegram.org), \"email\" (do-not-reply@telegram.org), \"phone_number\" (+1-212-555-0123), \"bold\" (bold text), \"italic\" (italic text), \"underline\" (underlined text), \"strikethrough\" (strikethrough text), \"spoiler\" (spoiler message), \"code\" (monowidth string), \"pre\" (monowidth block), \"text_link\" (for clickable text URLs), \"text_mention\" (for users without usernames), \"custom_emoji\" (for inline custom emoji stickers)"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset in UTF-16 code units to the start of the entity"]
    #[serde(rename = "offset")]
    offset: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Length of the entity in UTF-16 code units"]
    #[serde(rename = "length")]
    length: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_link\" only, URL that will be opened after user taps on the text"]
    url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_mention\" only, the mentioned user"]
    user: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"pre\" only, the programming language of the entity text"]
    language: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"custom_emoji\" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker"]
    custom_emoji_id: Option<String>,
}
impl From<NoSkipMessageEntity> for MessageEntity {
    fn from(t: NoSkipMessageEntity) -> Self {
        Self {
            tg_type: t.tg_type,
            offset: t.offset,
            length: t.length,
            url: t.url,
            user: t.user,
            language: t.language,
            custom_emoji_id: t.custom_emoji_id,
        }
    }
}
impl Into<NoSkipMessageEntity> for MessageEntity {
    fn into(self) -> NoSkipMessageEntity {
        NoSkipMessageEntity {
            tg_type: self.tg_type,
            offset: self.offset,
            length: self.length,
            url: self.url,
            user: self.user,
            language: self.language,
            custom_emoji_id: self.custom_emoji_id,
        }
    }
}
impl NoSkipMessageEntity {
    pub fn skip(self) -> MessageEntity {
        self.into()
    }
}
impl MessageEntity {
    pub fn noskip(self) -> NoSkipMessageEntity {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one special entity in a text message. For example, hashtags, usernames, URLs, etc."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MessageEntityBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the entity. Currently, can be \"mention\" (@username), \"hashtag\" (#hashtag), \"cashtag\" ($USD), \"bot_command\" (/start@jobs_bot), \"url\" (https://telegram.org), \"email\" (do-not-reply@telegram.org), \"phone_number\" (+1-212-555-0123), \"bold\" (bold text), \"italic\" (italic text), \"underline\" (underlined text), \"strikethrough\" (strikethrough text), \"spoiler\" (spoiler message), \"code\" (monowidth string), \"pre\" (monowidth block), \"text_link\" (for clickable text URLs), \"text_mention\" (for users without usernames), \"custom_emoji\" (for inline custom emoji stickers)"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset in UTF-16 code units to the start of the entity"]
    #[serde(rename = "offset")]
    offset: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Length of the entity in UTF-16 code units"]
    #[serde(rename = "length")]
    length: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_link\" only, URL that will be opened after user taps on the text"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "url", default)]
    url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_mention\" only, the mentioned user"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "user", default)]
    user: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"pre\" only, the programming language of the entity text"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "language", default)]
    language: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"custom_emoji\" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "custom_emoji_id",
        default
    )]
    custom_emoji_id: Option<String>,
}
impl MessageEntityBuilder {
    pub fn new(offset: i64, length: i64) -> Self {
        Self {
            tg_type: "MessageEntity".to_owned(),
            offset,
            length,
            url: None,
            user: None,
            language: None,
            custom_emoji_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the entity. Currently, can be \"mention\" (@username), \"hashtag\" (#hashtag), \"cashtag\" ($USD), \"bot_command\" (/start@jobs_bot), \"url\" (https://telegram.org), \"email\" (do-not-reply@telegram.org), \"phone_number\" (+1-212-555-0123), \"bold\" (bold text), \"italic\" (italic text), \"underline\" (underlined text), \"strikethrough\" (strikethrough text), \"spoiler\" (spoiler message), \"code\" (monowidth string), \"pre\" (monowidth block), \"text_link\" (for clickable text URLs), \"text_mention\" (for users without usernames), \"custom_emoji\" (for inline custom emoji stickers)"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset in UTF-16 code units to the start of the entity"]
    pub fn set_offset(mut self, offset: i64) -> Self {
        self.offset = offset;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Length of the entity in UTF-16 code units"]
    pub fn set_length(mut self, length: i64) -> Self {
        self.length = length;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_link\" only, URL that will be opened after user taps on the text"]
    pub fn set_url(mut self, url: String) -> Self {
        self.url = Some(url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_mention\" only, the mentioned user"]
    pub fn set_user(mut self, user: User) -> Self {
        self.user = Some(user);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"pre\" only, the programming language of the entity text"]
    pub fn set_language(mut self, language: String) -> Self {
        self.language = Some(language);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"custom_emoji\" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker"]
    pub fn set_custom_emoji_id(mut self, custom_emoji_id: String) -> Self {
        self.custom_emoji_id = Some(custom_emoji_id);
        self
    }
    pub fn build(self) -> MessageEntity {
        MessageEntity {
            tg_type: self.tg_type,
            offset: self.offset,
            length: self.length,
            url: self.url,
            user: self.user,
            language: self.language,
            custom_emoji_id: self.custom_emoji_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that has some additional privileges."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberAdministrator {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    #[serde(rename = "can_be_edited")]
    can_be_edited: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    #[serde(rename = "can_manage_chat")]
    can_manage_chat: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    #[serde(rename = "can_delete_messages")]
    can_delete_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    #[serde(rename = "can_manage_video_chats")]
    can_manage_video_chats: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    #[serde(rename = "can_restrict_members")]
    can_restrict_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    #[serde(rename = "can_promote_members")]
    can_promote_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    #[serde(rename = "can_change_info")]
    can_change_info: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    #[serde(rename = "can_invite_users")]
    can_invite_users: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_post_messages",
        default
    )]
    can_post_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_edit_messages",
        default
    )]
    can_edit_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_pin_messages",
        default
    )]
    can_pin_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_post_stories",
        default
    )]
    can_post_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_edit_stories",
        default
    )]
    can_edit_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_delete_stories",
        default
    )]
    can_delete_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_manage_topics",
        default
    )]
    can_manage_topics: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "custom_title",
        default
    )]
    custom_title: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatMemberAdministrator that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatMemberAdministrator {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    #[serde(rename = "can_be_edited")]
    can_be_edited: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    #[serde(rename = "can_manage_chat")]
    can_manage_chat: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    #[serde(rename = "can_delete_messages")]
    can_delete_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    #[serde(rename = "can_manage_video_chats")]
    can_manage_video_chats: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    #[serde(rename = "can_restrict_members")]
    can_restrict_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    #[serde(rename = "can_promote_members")]
    can_promote_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    #[serde(rename = "can_change_info")]
    can_change_info: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    #[serde(rename = "can_invite_users")]
    can_invite_users: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    can_post_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    can_edit_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    can_pin_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    can_post_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    can_edit_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    can_delete_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    can_manage_topics: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    custom_title: Option<String>,
}
impl From<NoSkipChatMemberAdministrator> for ChatMemberAdministrator {
    fn from(t: NoSkipChatMemberAdministrator) -> Self {
        Self {
            user: t.user,
            can_be_edited: t.can_be_edited,
            is_anonymous: t.is_anonymous,
            can_manage_chat: t.can_manage_chat,
            can_delete_messages: t.can_delete_messages,
            can_manage_video_chats: t.can_manage_video_chats,
            can_restrict_members: t.can_restrict_members,
            can_promote_members: t.can_promote_members,
            can_change_info: t.can_change_info,
            can_invite_users: t.can_invite_users,
            can_post_messages: t.can_post_messages,
            can_edit_messages: t.can_edit_messages,
            can_pin_messages: t.can_pin_messages,
            can_post_stories: t.can_post_stories,
            can_edit_stories: t.can_edit_stories,
            can_delete_stories: t.can_delete_stories,
            can_manage_topics: t.can_manage_topics,
            custom_title: t.custom_title,
        }
    }
}
impl Into<NoSkipChatMemberAdministrator> for ChatMemberAdministrator {
    fn into(self) -> NoSkipChatMemberAdministrator {
        NoSkipChatMemberAdministrator {
            user: self.user,
            can_be_edited: self.can_be_edited,
            is_anonymous: self.is_anonymous,
            can_manage_chat: self.can_manage_chat,
            can_delete_messages: self.can_delete_messages,
            can_manage_video_chats: self.can_manage_video_chats,
            can_restrict_members: self.can_restrict_members,
            can_promote_members: self.can_promote_members,
            can_change_info: self.can_change_info,
            can_invite_users: self.can_invite_users,
            can_post_messages: self.can_post_messages,
            can_edit_messages: self.can_edit_messages,
            can_pin_messages: self.can_pin_messages,
            can_post_stories: self.can_post_stories,
            can_edit_stories: self.can_edit_stories,
            can_delete_stories: self.can_delete_stories,
            can_manage_topics: self.can_manage_topics,
            custom_title: self.custom_title,
        }
    }
}
impl NoSkipChatMemberAdministrator {
    pub fn skip(self) -> ChatMemberAdministrator {
        self.into()
    }
}
impl ChatMemberAdministrator {
    pub fn noskip(self) -> NoSkipChatMemberAdministrator {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that has some additional privileges."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberAdministratorBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    #[serde(rename = "can_be_edited")]
    can_be_edited: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    #[serde(rename = "can_manage_chat")]
    can_manage_chat: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    #[serde(rename = "can_delete_messages")]
    can_delete_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    #[serde(rename = "can_manage_video_chats")]
    can_manage_video_chats: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    #[serde(rename = "can_restrict_members")]
    can_restrict_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    #[serde(rename = "can_promote_members")]
    can_promote_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    #[serde(rename = "can_change_info")]
    can_change_info: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    #[serde(rename = "can_invite_users")]
    can_invite_users: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_post_messages",
        default
    )]
    can_post_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_edit_messages",
        default
    )]
    can_edit_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_pin_messages",
        default
    )]
    can_pin_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_post_stories",
        default
    )]
    can_post_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_edit_stories",
        default
    )]
    can_edit_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_delete_stories",
        default
    )]
    can_delete_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_manage_topics",
        default
    )]
    can_manage_topics: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "custom_title",
        default
    )]
    custom_title: Option<String>,
}
impl ChatMemberAdministratorBuilder {
    pub fn new(
        user: User,
        can_be_edited: bool,
        is_anonymous: bool,
        can_manage_chat: bool,
        can_delete_messages: bool,
        can_manage_video_chats: bool,
        can_restrict_members: bool,
        can_promote_members: bool,
        can_change_info: bool,
        can_invite_users: bool,
    ) -> Self {
        Self {
            user,
            can_be_edited,
            is_anonymous,
            can_manage_chat,
            can_delete_messages,
            can_manage_video_chats,
            can_restrict_members,
            can_promote_members,
            can_change_info,
            can_invite_users,
            can_post_messages: None,
            can_edit_messages: None,
            can_pin_messages: None,
            can_post_stories: None,
            can_edit_stories: None,
            can_delete_stories: None,
            can_manage_topics: None,
            custom_title: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user(mut self, user: User) -> Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    pub fn set_can_be_edited(mut self, can_be_edited: bool) -> Self {
        self.can_be_edited = can_be_edited;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn set_is_anonymous(mut self, is_anonymous: bool) -> Self {
        self.is_anonymous = is_anonymous;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    pub fn set_can_manage_chat(mut self, can_manage_chat: bool) -> Self {
        self.can_manage_chat = can_manage_chat;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    pub fn set_can_delete_messages(mut self, can_delete_messages: bool) -> Self {
        self.can_delete_messages = can_delete_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    pub fn set_can_manage_video_chats(mut self, can_manage_video_chats: bool) -> Self {
        self.can_manage_video_chats = can_manage_video_chats;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    pub fn set_can_restrict_members(mut self, can_restrict_members: bool) -> Self {
        self.can_restrict_members = can_restrict_members;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    pub fn set_can_promote_members(mut self, can_promote_members: bool) -> Self {
        self.can_promote_members = can_promote_members;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn set_can_change_info(mut self, can_change_info: bool) -> Self {
        self.can_change_info = can_change_info;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn set_can_invite_users(mut self, can_invite_users: bool) -> Self {
        self.can_invite_users = can_invite_users;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    pub fn set_can_post_messages(mut self, can_post_messages: bool) -> Self {
        self.can_post_messages = Some(can_post_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    pub fn set_can_edit_messages(mut self, can_edit_messages: bool) -> Self {
        self.can_edit_messages = Some(can_edit_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    pub fn set_can_pin_messages(mut self, can_pin_messages: bool) -> Self {
        self.can_pin_messages = Some(can_pin_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    pub fn set_can_post_stories(mut self, can_post_stories: bool) -> Self {
        self.can_post_stories = Some(can_post_stories);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    pub fn set_can_edit_stories(mut self, can_edit_stories: bool) -> Self {
        self.can_edit_stories = Some(can_edit_stories);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    pub fn set_can_delete_stories(mut self, can_delete_stories: bool) -> Self {
        self.can_delete_stories = Some(can_delete_stories);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    pub fn set_can_manage_topics(mut self, can_manage_topics: bool) -> Self {
        self.can_manage_topics = Some(can_manage_topics);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    pub fn set_custom_title(mut self, custom_title: String) -> Self {
        self.custom_title = Some(custom_title);
        self
    }
    pub fn build(self) -> ChatMemberAdministrator {
        ChatMemberAdministrator {
            user: self.user,
            can_be_edited: self.can_be_edited,
            is_anonymous: self.is_anonymous,
            can_manage_chat: self.can_manage_chat,
            can_delete_messages: self.can_delete_messages,
            can_manage_video_chats: self.can_manage_video_chats,
            can_restrict_members: self.can_restrict_members,
            can_promote_members: self.can_promote_members,
            can_change_info: self.can_change_info,
            can_invite_users: self.can_invite_users,
            can_post_messages: self.can_post_messages,
            can_edit_messages: self.can_edit_messages,
            can_pin_messages: self.can_pin_messages,
            can_post_stories: self.can_post_stories,
            can_edit_stories: self.can_edit_stories,
            can_delete_stories: self.can_delete_stories,
            can_manage_topics: self.can_manage_topics,
            custom_title: self.custom_title,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a venue. By default, the venue will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the venue.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultVenue {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    #[serde(rename = "address")]
    address: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_id",
        default
    )]
    foursquare_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_type",
        default
    )]
    foursquare_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_id",
        default
    )]
    google_place_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_type",
        default
    )]
    google_place_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_url",
        default
    )]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_width",
        default
    )]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_height",
        default
    )]
    thumbnail_height: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultVenue that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultVenue {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    #[serde(rename = "address")]
    address: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    foursquare_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    foursquare_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    google_place_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    google_place_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    thumbnail_height: Option<i64>,
}
impl From<NoSkipInlineQueryResultVenue> for InlineQueryResultVenue {
    fn from(t: NoSkipInlineQueryResultVenue) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            latitude: t.latitude,
            longitude: t.longitude,
            title: t.title,
            address: t.address,
            foursquare_id: t.foursquare_id,
            foursquare_type: t.foursquare_type,
            google_place_id: t.google_place_id,
            google_place_type: t.google_place_type,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
            thumbnail_url: t.thumbnail_url,
            thumbnail_width: t.thumbnail_width,
            thumbnail_height: t.thumbnail_height,
        }
    }
}
impl Into<NoSkipInlineQueryResultVenue> for InlineQueryResultVenue {
    fn into(self) -> NoSkipInlineQueryResultVenue {
        NoSkipInlineQueryResultVenue {
            tg_type: self.tg_type,
            id: self.id,
            latitude: self.latitude,
            longitude: self.longitude,
            title: self.title,
            address: self.address,
            foursquare_id: self.foursquare_id,
            foursquare_type: self.foursquare_type,
            google_place_id: self.google_place_id,
            google_place_type: self.google_place_type,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
            thumbnail_url: self.thumbnail_url,
            thumbnail_width: self.thumbnail_width,
            thumbnail_height: self.thumbnail_height,
        }
    }
}
impl NoSkipInlineQueryResultVenue {
    pub fn skip(self) -> InlineQueryResultVenue {
        self.into()
    }
}
impl InlineQueryResultVenue {
    pub fn noskip(self) -> NoSkipInlineQueryResultVenue {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a venue. By default, the venue will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the venue.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultVenueBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    #[serde(rename = "address")]
    address: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_id",
        default
    )]
    foursquare_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_type",
        default
    )]
    foursquare_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_id",
        default
    )]
    google_place_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_type",
        default
    )]
    google_place_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_url",
        default
    )]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_width",
        default
    )]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_height",
        default
    )]
    thumbnail_height: Option<i64>,
}
impl InlineQueryResultVenueBuilder {
    pub fn new(
        id: String,
        latitude: ::ordered_float::OrderedFloat<f64>,
        longitude: ::ordered_float::OrderedFloat<f64>,
        title: String,
        address: String,
    ) -> Self {
        Self {
            tg_type: "venue".to_owned(),
            id,
            latitude,
            longitude,
            title,
            address,
            foursquare_id: None,
            foursquare_type: None,
            google_place_id: None,
            google_place_type: None,
            reply_markup: None,
            input_message_content: None,
            thumbnail_url: None,
            thumbnail_width: None,
            thumbnail_height: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    pub fn set_latitude(mut self, latitude: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    pub fn set_longitude(mut self, longitude: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn set_address(mut self, address: String) -> Self {
        self.address = address;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    pub fn set_foursquare_id(mut self, foursquare_id: String) -> Self {
        self.foursquare_id = Some(foursquare_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn set_foursquare_type(mut self, foursquare_type: String) -> Self {
        self.foursquare_type = Some(foursquare_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn set_google_place_id(mut self, google_place_id: String) -> Self {
        self.google_place_id = Some(google_place_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn set_google_place_type(mut self, google_place_type: String) -> Self {
        self.google_place_type = Some(google_place_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn set_thumbnail_url(mut self, thumbnail_url: String) -> Self {
        self.thumbnail_url = Some(thumbnail_url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn set_thumbnail_width(mut self, thumbnail_width: i64) -> Self {
        self.thumbnail_width = Some(thumbnail_width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn set_thumbnail_height(mut self, thumbnail_height: i64) -> Self {
        self.thumbnail_height = Some(thumbnail_height);
        self
    }
    pub fn build(self) -> InlineQueryResultVenue {
        InlineQueryResultVenue {
            tg_type: self.tg_type,
            id: self.id,
            latitude: self.latitude,
            longitude: self.longitude,
            title: self.title,
            address: self.address,
            foursquare_id: self.foursquare_id,
            foursquare_type: self.foursquare_type,
            google_place_id: self.google_place_id,
            google_place_type: self.google_place_type,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
            thumbnail_url: self.thumbnail_url,
            thumbnail_width: self.thumbnail_width,
            thumbnail_height: self.thumbnail_height,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a phone contact."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Contact {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    #[serde(rename = "phone_number")]
    phone_number: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "last_name", default)]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "user_id", default)]
    user_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "vcard", default)]
    vcard: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Contact that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipContact {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    #[serde(rename = "phone_number")]
    phone_number: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    user_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard"]
    vcard: Option<String>,
}
impl From<NoSkipContact> for Contact {
    fn from(t: NoSkipContact) -> Self {
        Self {
            phone_number: t.phone_number,
            first_name: t.first_name,
            last_name: t.last_name,
            user_id: t.user_id,
            vcard: t.vcard,
        }
    }
}
impl Into<NoSkipContact> for Contact {
    fn into(self) -> NoSkipContact {
        NoSkipContact {
            phone_number: self.phone_number,
            first_name: self.first_name,
            last_name: self.last_name,
            user_id: self.user_id,
            vcard: self.vcard,
        }
    }
}
impl NoSkipContact {
    pub fn skip(self) -> Contact {
        self.into()
    }
}
impl Contact {
    pub fn noskip(self) -> NoSkipContact {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a phone contact."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ContactBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    #[serde(rename = "phone_number")]
    phone_number: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "last_name", default)]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "user_id", default)]
    user_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "vcard", default)]
    vcard: Option<String>,
}
impl ContactBuilder {
    pub fn new(phone_number: String, first_name: String) -> Self {
        Self {
            phone_number,
            first_name,
            last_name: None,
            user_id: None,
            vcard: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn set_phone_number(mut self, phone_number: String) -> Self {
        self.phone_number = phone_number;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn set_first_name(mut self, first_name: String) -> Self {
        self.first_name = first_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn set_last_name(mut self, last_name: String) -> Self {
        self.last_name = Some(last_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_user_id(mut self, user_id: i64) -> Self {
        self.user_id = Some(user_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard"]
    pub fn set_vcard(mut self, vcard: String) -> Self {
        self.vcard = Some(vcard);
        self
    }
    pub fn build(self) -> Contact {
        Contact {
            phone_number: self.phone_number,
            first_name: self.first_name,
            last_name: self.last_name,
            user_id: self.user_id,
            vcard: self.vcard,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a Game.Note: This will only work in Telegram versions released after October 1, 2016. Older clients will not display any inline results if a game result is among them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultGame {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    #[serde(rename = "game_short_name")]
    game_short_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultGame that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultGame {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    #[serde(rename = "game_short_name")]
    game_short_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
}
impl From<NoSkipInlineQueryResultGame> for InlineQueryResultGame {
    fn from(t: NoSkipInlineQueryResultGame) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            game_short_name: t.game_short_name,
            reply_markup: t.reply_markup,
        }
    }
}
impl Into<NoSkipInlineQueryResultGame> for InlineQueryResultGame {
    fn into(self) -> NoSkipInlineQueryResultGame {
        NoSkipInlineQueryResultGame {
            tg_type: self.tg_type,
            id: self.id,
            game_short_name: self.game_short_name,
            reply_markup: self.reply_markup,
        }
    }
}
impl NoSkipInlineQueryResultGame {
    pub fn skip(self) -> InlineQueryResultGame {
        self.into()
    }
}
impl InlineQueryResultGame {
    pub fn noskip(self) -> NoSkipInlineQueryResultGame {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a Game.Note: This will only work in Telegram versions released after October 1, 2016. Older clients will not display any inline results if a game result is among them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultGameBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    #[serde(rename = "game_short_name")]
    game_short_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
}
impl InlineQueryResultGameBuilder {
    pub fn new(id: String, game_short_name: String) -> Self {
        Self {
            tg_type: "game".to_owned(),
            id,
            game_short_name,
            reply_markup: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    pub fn set_game_short_name(mut self, game_short_name: String) -> Self {
        self.game_short_name = game_short_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    pub fn build(self) -> InlineQueryResultGame {
        InlineQueryResultGame {
            tg_type: self.tg_type,
            id: self.id,
            game_short_name: self.game_short_name,
            reply_markup: self.reply_markup,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering all private chats."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeAllPrivateChats {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    #[serde(rename = "type")]
    tg_type: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotCommandScopeAllPrivateChats that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotCommandScopeAllPrivateChats {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl From<NoSkipBotCommandScopeAllPrivateChats> for BotCommandScopeAllPrivateChats {
    fn from(t: NoSkipBotCommandScopeAllPrivateChats) -> Self {
        Self { tg_type: t.tg_type }
    }
}
impl Into<NoSkipBotCommandScopeAllPrivateChats> for BotCommandScopeAllPrivateChats {
    fn into(self) -> NoSkipBotCommandScopeAllPrivateChats {
        NoSkipBotCommandScopeAllPrivateChats {
            tg_type: self.tg_type,
        }
    }
}
impl NoSkipBotCommandScopeAllPrivateChats {
    pub fn skip(self) -> BotCommandScopeAllPrivateChats {
        self.into()
    }
}
impl BotCommandScopeAllPrivateChats {
    pub fn noskip(self) -> NoSkipBotCommandScopeAllPrivateChats {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering all private chats."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeAllPrivateChatsBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl BotCommandScopeAllPrivateChatsBuilder {
    pub fn new() -> Self {
        Self {
            tg_type: "all_private_chats".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    pub fn build(self) -> BotCommandScopeAllPrivateChats {
        BotCommandScopeAllPrivateChats {
            tg_type: self.tg_type,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum ForumTopicReopened {}
impl ForumTopicReopened {}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represent a user's profile pictures."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct UserProfilePhotos {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of profile pictures the target user has"]
    #[serde(rename = "total_count")]
    total_count: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requested profile pictures (in up to 4 sizes each)"]
    #[serde(rename = "photos")]
    photos: Vec<Vec<PhotoSize>>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to UserProfilePhotos that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipUserProfilePhotos {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of profile pictures the target user has"]
    #[serde(rename = "total_count")]
    total_count: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requested profile pictures (in up to 4 sizes each)"]
    #[serde(rename = "photos")]
    photos: Vec<Vec<PhotoSize>>,
}
impl From<NoSkipUserProfilePhotos> for UserProfilePhotos {
    fn from(t: NoSkipUserProfilePhotos) -> Self {
        Self {
            total_count: t.total_count,
            photos: t.photos,
        }
    }
}
impl Into<NoSkipUserProfilePhotos> for UserProfilePhotos {
    fn into(self) -> NoSkipUserProfilePhotos {
        NoSkipUserProfilePhotos {
            total_count: self.total_count,
            photos: self.photos,
        }
    }
}
impl NoSkipUserProfilePhotos {
    pub fn skip(self) -> UserProfilePhotos {
        self.into()
    }
}
impl UserProfilePhotos {
    pub fn noskip(self) -> NoSkipUserProfilePhotos {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represent a user's profile pictures."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct UserProfilePhotosBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of profile pictures the target user has"]
    #[serde(rename = "total_count")]
    total_count: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requested profile pictures (in up to 4 sizes each)"]
    #[serde(rename = "photos")]
    photos: Vec<Vec<PhotoSize>>,
}
impl UserProfilePhotosBuilder {
    pub fn new(total_count: i64, photos: Vec<Vec<PhotoSize>>) -> Self {
        Self {
            total_count,
            photos,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of profile pictures the target user has"]
    pub fn set_total_count(mut self, total_count: i64) -> Self {
        self.total_count = total_count;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requested profile pictures (in up to 4 sizes each)"]
    pub fn set_photos(mut self, photos: Vec<Vec<PhotoSize>>) -> Self {
        self.photos = photos;
        self
    }
    pub fn build(self) -> UserProfilePhotos {
        UserProfilePhotos {
            total_count: self.total_count,
            photos: self.photos,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a button to be shown above inline query results. You must use exactly one of the optional fields."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultsButton {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "web_app", default)]
    web_app: Option<WebAppInfo>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "start_parameter",
        default
    )]
    start_parameter: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultsButton that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultsButton {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."]
    web_app: Option<WebAppInfo>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."]
    start_parameter: Option<String>,
}
impl From<NoSkipInlineQueryResultsButton> for InlineQueryResultsButton {
    fn from(t: NoSkipInlineQueryResultsButton) -> Self {
        Self {
            text: t.text,
            web_app: t.web_app,
            start_parameter: t.start_parameter,
        }
    }
}
impl Into<NoSkipInlineQueryResultsButton> for InlineQueryResultsButton {
    fn into(self) -> NoSkipInlineQueryResultsButton {
        NoSkipInlineQueryResultsButton {
            text: self.text,
            web_app: self.web_app,
            start_parameter: self.start_parameter,
        }
    }
}
impl NoSkipInlineQueryResultsButton {
    pub fn skip(self) -> InlineQueryResultsButton {
        self.into()
    }
}
impl InlineQueryResultsButton {
    pub fn noskip(self) -> NoSkipInlineQueryResultsButton {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a button to be shown above inline query results. You must use exactly one of the optional fields."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultsButtonBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "web_app", default)]
    web_app: Option<WebAppInfo>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "start_parameter",
        default
    )]
    start_parameter: Option<String>,
}
impl InlineQueryResultsButtonBuilder {
    pub fn new(text: String) -> Self {
        Self {
            text,
            web_app: None,
            start_parameter: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    pub fn set_text(mut self, text: String) -> Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."]
    pub fn set_web_app(mut self, web_app: WebAppInfo) -> Self {
        self.web_app = Some(web_app);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."]
    pub fn set_start_parameter(mut self, start_parameter: String) -> Self {
        self.start_parameter = Some(start_parameter);
        self
    }
    pub fn build(self) -> InlineQueryResultsButton {
        InlineQueryResultsButton {
            text: self.text,
            web_app: self.web_app,
            start_parameter: self.start_parameter,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a message."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Message {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    #[serde(rename = "message_id")]
    message_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "message_thread_id",
        default
    )]
    message_thread_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "from", default)]
    from: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "sender_chat",
        default
    )]
    sender_chat: Option<Box<Chat>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    #[serde(rename = "date")]
    date: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    #[serde(rename = "chat")]
    chat: Box<Chat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_from",
        default
    )]
    forward_from: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_from_chat",
        default
    )]
    forward_from_chat: Option<Box<Chat>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_from_message_id",
        default
    )]
    forward_from_message_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_signature",
        default
    )]
    forward_signature: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_sender_name",
        default
    )]
    forward_sender_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_date",
        default
    )]
    forward_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "is_topic_message",
        default
    )]
    is_topic_message: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "is_automatic_forward",
        default
    )]
    is_automatic_forward: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_to_message",
        default
    )]
    reply_to_message: Option<Box<Message>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "via_bot", default)]
    via_bot: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "edit_date", default)]
    edit_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_protected_content",
        default
    )]
    has_protected_content: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "media_group_id",
        default
    )]
    media_group_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "author_signature",
        default
    )]
    author_signature: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "text", default)]
    text: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "entities", default)]
    entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "animation", default)]
    animation: Option<Animation>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "audio", default)]
    audio: Option<Audio>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "document", default)]
    document: Option<Document>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "photo", default)]
    photo: Option<Vec<PhotoSize>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "sticker", default)]
    sticker: Option<Sticker>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "story", default)]
    story: Option<Story>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "video", default)]
    video: Option<Video>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_note",
        default
    )]
    video_note: Option<VideoNote>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "voice", default)]
    voice: Option<Voice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_media_spoiler",
        default
    )]
    has_media_spoiler: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "contact", default)]
    contact: Option<Contact>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "dice", default)]
    dice: Option<Dice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "game", default)]
    game: Option<Game>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "poll", default)]
    poll: Option<Poll>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "venue", default)]
    venue: Option<Venue>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared location, information about the location"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "location", default)]
    location: Option<Location>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "new_chat_members",
        default
    )]
    new_chat_members: Option<Vec<User>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "left_chat_member",
        default
    )]
    left_chat_member: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "new_chat_title",
        default
    )]
    new_chat_title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "new_chat_photo",
        default
    )]
    new_chat_photo: Option<Vec<PhotoSize>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "delete_chat_photo",
        default
    )]
    delete_chat_photo: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "group_chat_created",
        default
    )]
    group_chat_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "supergroup_chat_created",
        default
    )]
    supergroup_chat_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "channel_chat_created",
        default
    )]
    channel_chat_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "message_auto_delete_timer_changed",
        default
    )]
    message_auto_delete_timer_changed: Option<MessageAutoDeleteTimerChanged>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "migrate_to_chat_id",
        default
    )]
    migrate_to_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "migrate_from_chat_id",
        default
    )]
    migrate_from_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "pinned_message",
        default
    )]
    pinned_message: Option<Box<Message>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "invoice", default)]
    invoice: Option<Invoice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "successful_payment",
        default
    )]
    successful_payment: Option<SuccessfulPayment>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "user_shared",
        default
    )]
    user_shared: Option<UserShared>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_shared",
        default
    )]
    chat_shared: Option<ChatShared>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "connected_website",
        default
    )]
    connected_website: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "write_access_allowed",
        default
    )]
    write_access_allowed: Option<WriteAccessAllowed>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "passport_data",
        default
    )]
    passport_data: Option<PassportData>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "proximity_alert_triggered",
        default
    )]
    proximity_alert_triggered: Option<ProximityAlertTriggered>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forum_topic_created",
        default
    )]
    forum_topic_created: Option<ForumTopicCreated>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forum_topic_edited",
        default
    )]
    forum_topic_edited: Option<ForumTopicEdited>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forum_topic_closed",
        default
    )]
    forum_topic_closed: Option<ForumTopicClosed>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forum_topic_reopened",
        default
    )]
    forum_topic_reopened: Option<ForumTopicReopened>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "general_forum_topic_hidden",
        default
    )]
    general_forum_topic_hidden: Option<GeneralForumTopicHidden>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "general_forum_topic_unhidden",
        default
    )]
    general_forum_topic_unhidden: Option<GeneralForumTopicUnhidden>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_chat_scheduled",
        default
    )]
    video_chat_scheduled: Option<VideoChatScheduled>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_chat_started",
        default
    )]
    video_chat_started: Option<VideoChatStarted>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_chat_ended",
        default
    )]
    video_chat_ended: Option<VideoChatEnded>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_chat_participants_invited",
        default
    )]
    video_chat_participants_invited: Option<VideoChatParticipantsInvited>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "web_app_data",
        default
    )]
    web_app_data: Option<WebAppData>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Message that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipMessage {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    #[serde(rename = "message_id")]
    message_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    message_thread_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    from: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    sender_chat: Option<Box<Chat>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    #[serde(rename = "date")]
    date: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    #[serde(rename = "chat")]
    chat: Box<Chat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    forward_from: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    forward_from_chat: Option<Box<Chat>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    forward_from_message_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    forward_signature: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    forward_sender_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    forward_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    is_topic_message: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    is_automatic_forward: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    reply_to_message: Option<Box<Message>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    via_bot: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    edit_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    has_protected_content: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    media_group_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    author_signature: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    text: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    animation: Option<Animation>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    audio: Option<Audio>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    document: Option<Document>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    photo: Option<Vec<PhotoSize>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    sticker: Option<Sticker>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    story: Option<Story>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    video: Option<Video>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    video_note: Option<VideoNote>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    voice: Option<Voice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    has_media_spoiler: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    contact: Option<Contact>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    dice: Option<Dice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    game: Option<Game>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    poll: Option<Poll>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    venue: Option<Venue>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared location, information about the location"]
    location: Option<Location>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    new_chat_members: Option<Vec<User>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    left_chat_member: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    new_chat_title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    new_chat_photo: Option<Vec<PhotoSize>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    delete_chat_photo: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    group_chat_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    supergroup_chat_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    channel_chat_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    message_auto_delete_timer_changed: Option<MessageAutoDeleteTimerChanged>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    migrate_to_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    migrate_from_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    pinned_message: Option<Box<Message>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    invoice: Option<Invoice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    successful_payment: Option<SuccessfulPayment>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    user_shared: Option<UserShared>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    chat_shared: Option<ChatShared>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    connected_website: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    write_access_allowed: Option<WriteAccessAllowed>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    passport_data: Option<PassportData>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    proximity_alert_triggered: Option<ProximityAlertTriggered>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    forum_topic_created: Option<ForumTopicCreated>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    forum_topic_edited: Option<ForumTopicEdited>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    forum_topic_closed: Option<ForumTopicClosed>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    forum_topic_reopened: Option<ForumTopicReopened>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    general_forum_topic_hidden: Option<GeneralForumTopicHidden>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    general_forum_topic_unhidden: Option<GeneralForumTopicUnhidden>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    video_chat_scheduled: Option<VideoChatScheduled>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    video_chat_started: Option<VideoChatStarted>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    video_chat_ended: Option<VideoChatEnded>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    video_chat_participants_invited: Option<VideoChatParticipantsInvited>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    web_app_data: Option<WebAppData>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    reply_markup: Option<InlineKeyboardMarkup>,
}
impl From<NoSkipMessage> for Message {
    fn from(t: NoSkipMessage) -> Self {
        Self {
            message_id: t.message_id,
            message_thread_id: t.message_thread_id,
            from: t.from,
            sender_chat: t.sender_chat,
            date: t.date,
            chat: t.chat,
            forward_from: t.forward_from,
            forward_from_chat: t.forward_from_chat,
            forward_from_message_id: t.forward_from_message_id,
            forward_signature: t.forward_signature,
            forward_sender_name: t.forward_sender_name,
            forward_date: t.forward_date,
            is_topic_message: t.is_topic_message,
            is_automatic_forward: t.is_automatic_forward,
            reply_to_message: t.reply_to_message,
            via_bot: t.via_bot,
            edit_date: t.edit_date,
            has_protected_content: t.has_protected_content,
            media_group_id: t.media_group_id,
            author_signature: t.author_signature,
            text: t.text,
            entities: t.entities,
            animation: t.animation,
            audio: t.audio,
            document: t.document,
            photo: t.photo,
            sticker: t.sticker,
            story: t.story,
            video: t.video,
            video_note: t.video_note,
            voice: t.voice,
            caption: t.caption,
            caption_entities: t.caption_entities,
            has_media_spoiler: t.has_media_spoiler,
            contact: t.contact,
            dice: t.dice,
            game: t.game,
            poll: t.poll,
            venue: t.venue,
            location: t.location,
            new_chat_members: t.new_chat_members,
            left_chat_member: t.left_chat_member,
            new_chat_title: t.new_chat_title,
            new_chat_photo: t.new_chat_photo,
            delete_chat_photo: t.delete_chat_photo,
            group_chat_created: t.group_chat_created,
            supergroup_chat_created: t.supergroup_chat_created,
            channel_chat_created: t.channel_chat_created,
            message_auto_delete_timer_changed: t.message_auto_delete_timer_changed,
            migrate_to_chat_id: t.migrate_to_chat_id,
            migrate_from_chat_id: t.migrate_from_chat_id,
            pinned_message: t.pinned_message,
            invoice: t.invoice,
            successful_payment: t.successful_payment,
            user_shared: t.user_shared,
            chat_shared: t.chat_shared,
            connected_website: t.connected_website,
            write_access_allowed: t.write_access_allowed,
            passport_data: t.passport_data,
            proximity_alert_triggered: t.proximity_alert_triggered,
            forum_topic_created: t.forum_topic_created,
            forum_topic_edited: t.forum_topic_edited,
            forum_topic_closed: t.forum_topic_closed,
            forum_topic_reopened: t.forum_topic_reopened,
            general_forum_topic_hidden: t.general_forum_topic_hidden,
            general_forum_topic_unhidden: t.general_forum_topic_unhidden,
            video_chat_scheduled: t.video_chat_scheduled,
            video_chat_started: t.video_chat_started,
            video_chat_ended: t.video_chat_ended,
            video_chat_participants_invited: t.video_chat_participants_invited,
            web_app_data: t.web_app_data,
            reply_markup: t.reply_markup,
        }
    }
}
impl Into<NoSkipMessage> for Message {
    fn into(self) -> NoSkipMessage {
        NoSkipMessage {
            message_id: self.message_id,
            message_thread_id: self.message_thread_id,
            from: self.from,
            sender_chat: self.sender_chat,
            date: self.date,
            chat: self.chat,
            forward_from: self.forward_from,
            forward_from_chat: self.forward_from_chat,
            forward_from_message_id: self.forward_from_message_id,
            forward_signature: self.forward_signature,
            forward_sender_name: self.forward_sender_name,
            forward_date: self.forward_date,
            is_topic_message: self.is_topic_message,
            is_automatic_forward: self.is_automatic_forward,
            reply_to_message: self.reply_to_message,
            via_bot: self.via_bot,
            edit_date: self.edit_date,
            has_protected_content: self.has_protected_content,
            media_group_id: self.media_group_id,
            author_signature: self.author_signature,
            text: self.text,
            entities: self.entities,
            animation: self.animation,
            audio: self.audio,
            document: self.document,
            photo: self.photo,
            sticker: self.sticker,
            story: self.story,
            video: self.video,
            video_note: self.video_note,
            voice: self.voice,
            caption: self.caption,
            caption_entities: self.caption_entities,
            has_media_spoiler: self.has_media_spoiler,
            contact: self.contact,
            dice: self.dice,
            game: self.game,
            poll: self.poll,
            venue: self.venue,
            location: self.location,
            new_chat_members: self.new_chat_members,
            left_chat_member: self.left_chat_member,
            new_chat_title: self.new_chat_title,
            new_chat_photo: self.new_chat_photo,
            delete_chat_photo: self.delete_chat_photo,
            group_chat_created: self.group_chat_created,
            supergroup_chat_created: self.supergroup_chat_created,
            channel_chat_created: self.channel_chat_created,
            message_auto_delete_timer_changed: self.message_auto_delete_timer_changed,
            migrate_to_chat_id: self.migrate_to_chat_id,
            migrate_from_chat_id: self.migrate_from_chat_id,
            pinned_message: self.pinned_message,
            invoice: self.invoice,
            successful_payment: self.successful_payment,
            user_shared: self.user_shared,
            chat_shared: self.chat_shared,
            connected_website: self.connected_website,
            write_access_allowed: self.write_access_allowed,
            passport_data: self.passport_data,
            proximity_alert_triggered: self.proximity_alert_triggered,
            forum_topic_created: self.forum_topic_created,
            forum_topic_edited: self.forum_topic_edited,
            forum_topic_closed: self.forum_topic_closed,
            forum_topic_reopened: self.forum_topic_reopened,
            general_forum_topic_hidden: self.general_forum_topic_hidden,
            general_forum_topic_unhidden: self.general_forum_topic_unhidden,
            video_chat_scheduled: self.video_chat_scheduled,
            video_chat_started: self.video_chat_started,
            video_chat_ended: self.video_chat_ended,
            video_chat_participants_invited: self.video_chat_participants_invited,
            web_app_data: self.web_app_data,
            reply_markup: self.reply_markup,
        }
    }
}
impl NoSkipMessage {
    pub fn skip(self) -> Message {
        self.into()
    }
}
impl Message {
    pub fn noskip(self) -> NoSkipMessage {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a message."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MessageBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    #[serde(rename = "message_id")]
    message_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "message_thread_id",
        default
    )]
    message_thread_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "from", default)]
    from: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "sender_chat",
        default
    )]
    sender_chat: Option<Box<Chat>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    #[serde(rename = "date")]
    date: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    #[serde(rename = "chat")]
    chat: Box<Chat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_from",
        default
    )]
    forward_from: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_from_chat",
        default
    )]
    forward_from_chat: Option<Box<Chat>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_from_message_id",
        default
    )]
    forward_from_message_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_signature",
        default
    )]
    forward_signature: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_sender_name",
        default
    )]
    forward_sender_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forward_date",
        default
    )]
    forward_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "is_topic_message",
        default
    )]
    is_topic_message: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "is_automatic_forward",
        default
    )]
    is_automatic_forward: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_to_message",
        default
    )]
    reply_to_message: Option<Box<Message>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "via_bot", default)]
    via_bot: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "edit_date", default)]
    edit_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_protected_content",
        default
    )]
    has_protected_content: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "media_group_id",
        default
    )]
    media_group_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "author_signature",
        default
    )]
    author_signature: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "text", default)]
    text: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "entities", default)]
    entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "animation", default)]
    animation: Option<Animation>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "audio", default)]
    audio: Option<Audio>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "document", default)]
    document: Option<Document>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "photo", default)]
    photo: Option<Vec<PhotoSize>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "sticker", default)]
    sticker: Option<Sticker>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "story", default)]
    story: Option<Story>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "video", default)]
    video: Option<Video>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_note",
        default
    )]
    video_note: Option<VideoNote>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "voice", default)]
    voice: Option<Voice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_media_spoiler",
        default
    )]
    has_media_spoiler: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "contact", default)]
    contact: Option<Contact>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "dice", default)]
    dice: Option<Dice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "game", default)]
    game: Option<Game>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "poll", default)]
    poll: Option<Poll>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "venue", default)]
    venue: Option<Venue>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared location, information about the location"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "location", default)]
    location: Option<Location>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "new_chat_members",
        default
    )]
    new_chat_members: Option<Vec<User>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "left_chat_member",
        default
    )]
    left_chat_member: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "new_chat_title",
        default
    )]
    new_chat_title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "new_chat_photo",
        default
    )]
    new_chat_photo: Option<Vec<PhotoSize>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "delete_chat_photo",
        default
    )]
    delete_chat_photo: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "group_chat_created",
        default
    )]
    group_chat_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "supergroup_chat_created",
        default
    )]
    supergroup_chat_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "channel_chat_created",
        default
    )]
    channel_chat_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "message_auto_delete_timer_changed",
        default
    )]
    message_auto_delete_timer_changed: Option<MessageAutoDeleteTimerChanged>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "migrate_to_chat_id",
        default
    )]
    migrate_to_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "migrate_from_chat_id",
        default
    )]
    migrate_from_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "pinned_message",
        default
    )]
    pinned_message: Option<Box<Message>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "invoice", default)]
    invoice: Option<Invoice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "successful_payment",
        default
    )]
    successful_payment: Option<SuccessfulPayment>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "user_shared",
        default
    )]
    user_shared: Option<UserShared>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_shared",
        default
    )]
    chat_shared: Option<ChatShared>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "connected_website",
        default
    )]
    connected_website: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "write_access_allowed",
        default
    )]
    write_access_allowed: Option<WriteAccessAllowed>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "passport_data",
        default
    )]
    passport_data: Option<PassportData>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "proximity_alert_triggered",
        default
    )]
    proximity_alert_triggered: Option<ProximityAlertTriggered>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forum_topic_created",
        default
    )]
    forum_topic_created: Option<ForumTopicCreated>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forum_topic_edited",
        default
    )]
    forum_topic_edited: Option<ForumTopicEdited>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forum_topic_closed",
        default
    )]
    forum_topic_closed: Option<ForumTopicClosed>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "forum_topic_reopened",
        default
    )]
    forum_topic_reopened: Option<ForumTopicReopened>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "general_forum_topic_hidden",
        default
    )]
    general_forum_topic_hidden: Option<GeneralForumTopicHidden>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "general_forum_topic_unhidden",
        default
    )]
    general_forum_topic_unhidden: Option<GeneralForumTopicUnhidden>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_chat_scheduled",
        default
    )]
    video_chat_scheduled: Option<VideoChatScheduled>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_chat_started",
        default
    )]
    video_chat_started: Option<VideoChatStarted>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_chat_ended",
        default
    )]
    video_chat_ended: Option<VideoChatEnded>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "video_chat_participants_invited",
        default
    )]
    video_chat_participants_invited: Option<VideoChatParticipantsInvited>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "web_app_data",
        default
    )]
    web_app_data: Option<WebAppData>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
}
impl MessageBuilder {
    pub fn new(message_id: i64, date: i64, chat: Box<Chat>) -> Self {
        Self {
            message_id,
            date,
            chat,
            message_thread_id: None,
            from: None,
            sender_chat: None,
            forward_from: None,
            forward_from_chat: None,
            forward_from_message_id: None,
            forward_signature: None,
            forward_sender_name: None,
            forward_date: None,
            is_topic_message: None,
            is_automatic_forward: None,
            reply_to_message: None,
            via_bot: None,
            edit_date: None,
            has_protected_content: None,
            media_group_id: None,
            author_signature: None,
            text: None,
            entities: None,
            animation: None,
            audio: None,
            document: None,
            photo: None,
            sticker: None,
            story: None,
            video: None,
            video_note: None,
            voice: None,
            caption: None,
            caption_entities: None,
            has_media_spoiler: None,
            contact: None,
            dice: None,
            game: None,
            poll: None,
            venue: None,
            location: None,
            new_chat_members: None,
            left_chat_member: None,
            new_chat_title: None,
            new_chat_photo: None,
            delete_chat_photo: None,
            group_chat_created: None,
            supergroup_chat_created: None,
            channel_chat_created: None,
            message_auto_delete_timer_changed: None,
            migrate_to_chat_id: None,
            migrate_from_chat_id: None,
            pinned_message: None,
            invoice: None,
            successful_payment: None,
            user_shared: None,
            chat_shared: None,
            connected_website: None,
            write_access_allowed: None,
            passport_data: None,
            proximity_alert_triggered: None,
            forum_topic_created: None,
            forum_topic_edited: None,
            forum_topic_closed: None,
            forum_topic_reopened: None,
            general_forum_topic_hidden: None,
            general_forum_topic_unhidden: None,
            video_chat_scheduled: None,
            video_chat_started: None,
            video_chat_ended: None,
            video_chat_participants_invited: None,
            web_app_data: None,
            reply_markup: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    pub fn set_message_id(mut self, message_id: i64) -> Self {
        self.message_id = message_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    pub fn set_message_thread_id(mut self, message_thread_id: i64) -> Self {
        self.message_thread_id = Some(message_thread_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    pub fn set_from(mut self, from: User) -> Self {
        self.from = Some(from);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    pub fn set_sender_chat(mut self, sender_chat: Box<Chat>) -> Self {
        self.sender_chat = Some(sender_chat);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    pub fn set_date(mut self, date: i64) -> Self {
        self.date = date;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    pub fn set_chat(mut self, chat: Box<Chat>) -> Self {
        self.chat = chat;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    pub fn set_forward_from(mut self, forward_from: User) -> Self {
        self.forward_from = Some(forward_from);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    pub fn set_forward_from_chat(mut self, forward_from_chat: Box<Chat>) -> Self {
        self.forward_from_chat = Some(forward_from_chat);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    pub fn set_forward_from_message_id(mut self, forward_from_message_id: i64) -> Self {
        self.forward_from_message_id = Some(forward_from_message_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    pub fn set_forward_signature(mut self, forward_signature: String) -> Self {
        self.forward_signature = Some(forward_signature);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    pub fn set_forward_sender_name(mut self, forward_sender_name: String) -> Self {
        self.forward_sender_name = Some(forward_sender_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    pub fn set_forward_date(mut self, forward_date: i64) -> Self {
        self.forward_date = Some(forward_date);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    pub fn set_is_topic_message(mut self, is_topic_message: bool) -> Self {
        self.is_topic_message = Some(is_topic_message);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    pub fn set_is_automatic_forward(mut self, is_automatic_forward: bool) -> Self {
        self.is_automatic_forward = Some(is_automatic_forward);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    pub fn set_reply_to_message(mut self, reply_to_message: Box<Message>) -> Self {
        self.reply_to_message = Some(reply_to_message);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    pub fn set_via_bot(mut self, via_bot: User) -> Self {
        self.via_bot = Some(via_bot);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    pub fn set_edit_date(mut self, edit_date: i64) -> Self {
        self.edit_date = Some(edit_date);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    pub fn set_has_protected_content(mut self, has_protected_content: bool) -> Self {
        self.has_protected_content = Some(has_protected_content);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    pub fn set_media_group_id(mut self, media_group_id: String) -> Self {
        self.media_group_id = Some(media_group_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    pub fn set_author_signature(mut self, author_signature: String) -> Self {
        self.author_signature = Some(author_signature);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    pub fn set_text(mut self, text: String) -> Self {
        self.text = Some(text);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    pub fn set_entities(mut self, entities: Vec<MessageEntity>) -> Self {
        self.entities = Some(entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    pub fn set_animation(mut self, animation: Animation) -> Self {
        self.animation = Some(animation);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    pub fn set_audio(mut self, audio: Audio) -> Self {
        self.audio = Some(audio);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    pub fn set_document(mut self, document: Document) -> Self {
        self.document = Some(document);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    pub fn set_photo(mut self, photo: Vec<PhotoSize>) -> Self {
        self.photo = Some(photo);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    pub fn set_sticker(mut self, sticker: Sticker) -> Self {
        self.sticker = Some(sticker);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    pub fn set_story(mut self, story: Story) -> Self {
        self.story = Some(story);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    pub fn set_video(mut self, video: Video) -> Self {
        self.video = Some(video);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    pub fn set_video_note(mut self, video_note: VideoNote) -> Self {
        self.video_note = Some(video_note);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    pub fn set_voice(mut self, voice: Voice) -> Self {
        self.voice = Some(voice);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    pub fn set_has_media_spoiler(mut self, has_media_spoiler: bool) -> Self {
        self.has_media_spoiler = Some(has_media_spoiler);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    pub fn set_contact(mut self, contact: Contact) -> Self {
        self.contact = Some(contact);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    pub fn set_dice(mut self, dice: Dice) -> Self {
        self.dice = Some(dice);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    pub fn set_game(mut self, game: Game) -> Self {
        self.game = Some(game);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    pub fn set_poll(mut self, poll: Poll) -> Self {
        self.poll = Some(poll);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    pub fn set_venue(mut self, venue: Venue) -> Self {
        self.venue = Some(venue);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared location, information about the location"]
    pub fn set_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    pub fn set_new_chat_members(mut self, new_chat_members: Vec<User>) -> Self {
        self.new_chat_members = Some(new_chat_members);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    pub fn set_left_chat_member(mut self, left_chat_member: User) -> Self {
        self.left_chat_member = Some(left_chat_member);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    pub fn set_new_chat_title(mut self, new_chat_title: String) -> Self {
        self.new_chat_title = Some(new_chat_title);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    pub fn set_new_chat_photo(mut self, new_chat_photo: Vec<PhotoSize>) -> Self {
        self.new_chat_photo = Some(new_chat_photo);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    pub fn set_delete_chat_photo(mut self, delete_chat_photo: bool) -> Self {
        self.delete_chat_photo = Some(delete_chat_photo);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    pub fn set_group_chat_created(mut self, group_chat_created: bool) -> Self {
        self.group_chat_created = Some(group_chat_created);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    pub fn set_supergroup_chat_created(mut self, supergroup_chat_created: bool) -> Self {
        self.supergroup_chat_created = Some(supergroup_chat_created);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    pub fn set_channel_chat_created(mut self, channel_chat_created: bool) -> Self {
        self.channel_chat_created = Some(channel_chat_created);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    pub fn set_message_auto_delete_timer_changed(
        mut self,
        message_auto_delete_timer_changed: MessageAutoDeleteTimerChanged,
    ) -> Self {
        self.message_auto_delete_timer_changed = Some(message_auto_delete_timer_changed);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_migrate_to_chat_id(mut self, migrate_to_chat_id: i64) -> Self {
        self.migrate_to_chat_id = Some(migrate_to_chat_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_migrate_from_chat_id(mut self, migrate_from_chat_id: i64) -> Self {
        self.migrate_from_chat_id = Some(migrate_from_chat_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    pub fn set_pinned_message(mut self, pinned_message: Box<Message>) -> Self {
        self.pinned_message = Some(pinned_message);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    pub fn set_invoice(mut self, invoice: Invoice) -> Self {
        self.invoice = Some(invoice);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    pub fn set_successful_payment(mut self, successful_payment: SuccessfulPayment) -> Self {
        self.successful_payment = Some(successful_payment);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    pub fn set_user_shared(mut self, user_shared: UserShared) -> Self {
        self.user_shared = Some(user_shared);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    pub fn set_chat_shared(mut self, chat_shared: ChatShared) -> Self {
        self.chat_shared = Some(chat_shared);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    pub fn set_connected_website(mut self, connected_website: String) -> Self {
        self.connected_website = Some(connected_website);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    pub fn set_write_access_allowed(mut self, write_access_allowed: WriteAccessAllowed) -> Self {
        self.write_access_allowed = Some(write_access_allowed);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    pub fn set_passport_data(mut self, passport_data: PassportData) -> Self {
        self.passport_data = Some(passport_data);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    pub fn set_proximity_alert_triggered(
        mut self,
        proximity_alert_triggered: ProximityAlertTriggered,
    ) -> Self {
        self.proximity_alert_triggered = Some(proximity_alert_triggered);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    pub fn set_forum_topic_created(mut self, forum_topic_created: ForumTopicCreated) -> Self {
        self.forum_topic_created = Some(forum_topic_created);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    pub fn set_forum_topic_edited(mut self, forum_topic_edited: ForumTopicEdited) -> Self {
        self.forum_topic_edited = Some(forum_topic_edited);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    pub fn set_forum_topic_closed(mut self, forum_topic_closed: ForumTopicClosed) -> Self {
        self.forum_topic_closed = Some(forum_topic_closed);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    pub fn set_forum_topic_reopened(mut self, forum_topic_reopened: ForumTopicReopened) -> Self {
        self.forum_topic_reopened = Some(forum_topic_reopened);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    pub fn set_general_forum_topic_hidden(
        mut self,
        general_forum_topic_hidden: GeneralForumTopicHidden,
    ) -> Self {
        self.general_forum_topic_hidden = Some(general_forum_topic_hidden);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    pub fn set_general_forum_topic_unhidden(
        mut self,
        general_forum_topic_unhidden: GeneralForumTopicUnhidden,
    ) -> Self {
        self.general_forum_topic_unhidden = Some(general_forum_topic_unhidden);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    pub fn set_video_chat_scheduled(mut self, video_chat_scheduled: VideoChatScheduled) -> Self {
        self.video_chat_scheduled = Some(video_chat_scheduled);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    pub fn set_video_chat_started(mut self, video_chat_started: VideoChatStarted) -> Self {
        self.video_chat_started = Some(video_chat_started);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    pub fn set_video_chat_ended(mut self, video_chat_ended: VideoChatEnded) -> Self {
        self.video_chat_ended = Some(video_chat_ended);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    pub fn set_video_chat_participants_invited(
        mut self,
        video_chat_participants_invited: VideoChatParticipantsInvited,
    ) -> Self {
        self.video_chat_participants_invited = Some(video_chat_participants_invited);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    pub fn set_web_app_data(mut self, web_app_data: WebAppData) -> Self {
        self.web_app_data = Some(web_app_data);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    pub fn build(self) -> Message {
        Message {
            message_id: self.message_id,
            message_thread_id: self.message_thread_id,
            from: self.from,
            sender_chat: self.sender_chat,
            date: self.date,
            chat: self.chat,
            forward_from: self.forward_from,
            forward_from_chat: self.forward_from_chat,
            forward_from_message_id: self.forward_from_message_id,
            forward_signature: self.forward_signature,
            forward_sender_name: self.forward_sender_name,
            forward_date: self.forward_date,
            is_topic_message: self.is_topic_message,
            is_automatic_forward: self.is_automatic_forward,
            reply_to_message: self.reply_to_message,
            via_bot: self.via_bot,
            edit_date: self.edit_date,
            has_protected_content: self.has_protected_content,
            media_group_id: self.media_group_id,
            author_signature: self.author_signature,
            text: self.text,
            entities: self.entities,
            animation: self.animation,
            audio: self.audio,
            document: self.document,
            photo: self.photo,
            sticker: self.sticker,
            story: self.story,
            video: self.video,
            video_note: self.video_note,
            voice: self.voice,
            caption: self.caption,
            caption_entities: self.caption_entities,
            has_media_spoiler: self.has_media_spoiler,
            contact: self.contact,
            dice: self.dice,
            game: self.game,
            poll: self.poll,
            venue: self.venue,
            location: self.location,
            new_chat_members: self.new_chat_members,
            left_chat_member: self.left_chat_member,
            new_chat_title: self.new_chat_title,
            new_chat_photo: self.new_chat_photo,
            delete_chat_photo: self.delete_chat_photo,
            group_chat_created: self.group_chat_created,
            supergroup_chat_created: self.supergroup_chat_created,
            channel_chat_created: self.channel_chat_created,
            message_auto_delete_timer_changed: self.message_auto_delete_timer_changed,
            migrate_to_chat_id: self.migrate_to_chat_id,
            migrate_from_chat_id: self.migrate_from_chat_id,
            pinned_message: self.pinned_message,
            invoice: self.invoice,
            successful_payment: self.successful_payment,
            user_shared: self.user_shared,
            chat_shared: self.chat_shared,
            connected_website: self.connected_website,
            write_access_allowed: self.write_access_allowed,
            passport_data: self.passport_data,
            proximity_alert_triggered: self.proximity_alert_triggered,
            forum_topic_created: self.forum_topic_created,
            forum_topic_edited: self.forum_topic_edited,
            forum_topic_closed: self.forum_topic_closed,
            forum_topic_reopened: self.forum_topic_reopened,
            general_forum_topic_hidden: self.general_forum_topic_hidden,
            general_forum_topic_unhidden: self.general_forum_topic_unhidden,
            video_chat_scheduled: self.video_chat_scheduled,
            video_chat_started: self.video_chat_started,
            video_chat_ended: self.video_chat_ended,
            video_chat_participants_invited: self.video_chat_participants_invited,
            web_app_data: self.web_app_data,
            reply_markup: self.reply_markup,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about an incoming pre-checkout query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PreCheckoutQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "total_amount")]
    total_amount: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    #[serde(rename = "invoice_payload")]
    invoice_payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "shipping_option_id",
        default
    )]
    shipping_option_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "order_info",
        default
    )]
    order_info: Option<OrderInfo>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PreCheckoutQuery that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPreCheckoutQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "total_amount")]
    total_amount: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    #[serde(rename = "invoice_payload")]
    invoice_payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    shipping_option_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    order_info: Option<OrderInfo>,
}
impl From<NoSkipPreCheckoutQuery> for PreCheckoutQuery {
    fn from(t: NoSkipPreCheckoutQuery) -> Self {
        Self {
            id: t.id,
            from: t.from,
            currency: t.currency,
            total_amount: t.total_amount,
            invoice_payload: t.invoice_payload,
            shipping_option_id: t.shipping_option_id,
            order_info: t.order_info,
        }
    }
}
impl Into<NoSkipPreCheckoutQuery> for PreCheckoutQuery {
    fn into(self) -> NoSkipPreCheckoutQuery {
        NoSkipPreCheckoutQuery {
            id: self.id,
            from: self.from,
            currency: self.currency,
            total_amount: self.total_amount,
            invoice_payload: self.invoice_payload,
            shipping_option_id: self.shipping_option_id,
            order_info: self.order_info,
        }
    }
}
impl NoSkipPreCheckoutQuery {
    pub fn skip(self) -> PreCheckoutQuery {
        self.into()
    }
}
impl PreCheckoutQuery {
    pub fn noskip(self) -> NoSkipPreCheckoutQuery {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about an incoming pre-checkout query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PreCheckoutQueryBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "total_amount")]
    total_amount: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    #[serde(rename = "invoice_payload")]
    invoice_payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "shipping_option_id",
        default
    )]
    shipping_option_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "order_info",
        default
    )]
    order_info: Option<OrderInfo>,
}
impl PreCheckoutQueryBuilder {
    pub fn new(
        id: String,
        from: User,
        currency: String,
        total_amount: i64,
        invoice_payload: String,
    ) -> Self {
        Self {
            id,
            from,
            currency,
            total_amount,
            invoice_payload,
            shipping_option_id: None,
            order_info: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    pub fn set_from(mut self, from: User) -> Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn set_currency(mut self, currency: String) -> Self {
        self.currency = currency;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn set_total_amount(mut self, total_amount: i64) -> Self {
        self.total_amount = total_amount;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn set_invoice_payload(mut self, invoice_payload: String) -> Self {
        self.invoice_payload = invoice_payload;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    pub fn set_shipping_option_id(mut self, shipping_option_id: String) -> Self {
        self.shipping_option_id = Some(shipping_option_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    pub fn set_order_info(mut self, order_info: OrderInfo) -> Self {
        self.order_info = Some(order_info);
        self
    }
    pub fn build(self) -> PreCheckoutQuery {
        PreCheckoutQuery {
            id: self.id,
            from: self.from,
            currency: self.currency,
            total_amount: self.total_amount,
            invoice_payload: self.invoice_payload,
            shipping_option_id: self.shipping_option_id,
            order_info: self.order_info,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about an edited forum topic."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ForumTopicEdited {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New name of the topic, if it was edited"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "name", default)]
    name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "icon_custom_emoji_id",
        default
    )]
    icon_custom_emoji_id: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ForumTopicEdited that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipForumTopicEdited {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New name of the topic, if it was edited"]
    name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"]
    icon_custom_emoji_id: Option<String>,
}
impl From<NoSkipForumTopicEdited> for ForumTopicEdited {
    fn from(t: NoSkipForumTopicEdited) -> Self {
        Self {
            name: t.name,
            icon_custom_emoji_id: t.icon_custom_emoji_id,
        }
    }
}
impl Into<NoSkipForumTopicEdited> for ForumTopicEdited {
    fn into(self) -> NoSkipForumTopicEdited {
        NoSkipForumTopicEdited {
            name: self.name,
            icon_custom_emoji_id: self.icon_custom_emoji_id,
        }
    }
}
impl NoSkipForumTopicEdited {
    pub fn skip(self) -> ForumTopicEdited {
        self.into()
    }
}
impl ForumTopicEdited {
    pub fn noskip(self) -> NoSkipForumTopicEdited {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about an edited forum topic."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ForumTopicEditedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New name of the topic, if it was edited"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "name", default)]
    name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "icon_custom_emoji_id",
        default
    )]
    icon_custom_emoji_id: Option<String>,
}
impl ForumTopicEditedBuilder {
    pub fn new() -> Self {
        Self {
            name: None,
            icon_custom_emoji_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New name of the topic, if it was edited"]
    pub fn set_name(mut self, name: String) -> Self {
        self.name = Some(name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"]
    pub fn set_icon_custom_emoji_id(mut self, icon_custom_emoji_id: String) -> Self {
        self.icon_custom_emoji_id = Some(icon_custom_emoji_id);
        self
    }
    pub fn build(self) -> ForumTopicEdited {
        ForumTopicEdited {
            name: self.name,
            icon_custom_emoji_id: self.icon_custom_emoji_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a file ready to be downloaded. The file can be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct File {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_path", default)]
    file_path: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to File that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    file_size: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."]
    file_path: Option<String>,
}
impl From<NoSkipFile> for File {
    fn from(t: NoSkipFile) -> Self {
        Self {
            file_id: t.file_id,
            file_unique_id: t.file_unique_id,
            file_size: t.file_size,
            file_path: t.file_path,
        }
    }
}
impl Into<NoSkipFile> for File {
    fn into(self) -> NoSkipFile {
        NoSkipFile {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            file_size: self.file_size,
            file_path: self.file_path,
        }
    }
}
impl NoSkipFile {
    pub fn skip(self) -> File {
        self.into()
    }
}
impl File {
    pub fn noskip(self) -> NoSkipFile {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a file ready to be downloaded. The file can be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct FileBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_path", default)]
    file_path: Option<String>,
}
impl FileBuilder {
    pub fn new(file_id: String, file_unique_id: String) -> Self {
        Self {
            file_id,
            file_unique_id,
            file_size: None,
            file_path: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id(mut self, file_id: String) -> Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id(mut self, file_unique_id: String) -> Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size(mut self, file_size: i64) -> Self {
        self.file_size = Some(file_size);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."]
    pub fn set_file_path(mut self, file_path: String) -> Self {
        self.file_path = Some(file_path);
        self
    }
    pub fn build(self) -> File {
        File {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            file_size: self.file_size,
            file_path: self.file_path,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(tag = "status")]
pub enum ChatMember {
    #[serde(rename = "creator")]
    ChatMemberOwner(ChatMemberOwner),
    #[serde(rename = "restricted")]
    ChatMemberRestricted(ChatMemberRestricted),
    #[serde(rename = "left")]
    ChatMemberLeft(ChatMemberLeft),
    #[serde(rename = "kicked")]
    ChatMemberBanned(ChatMemberBanned),
    #[serde(rename = "administrator")]
    ChatMemberAdministrator(ChatMemberAdministrator),
    #[serde(rename = "member")]
    ChatMemberMember(ChatMemberMember),
}
impl Default for ChatMember {
    fn default() -> Self {
        ChatMember::ChatMemberOwner(ChatMemberOwner::default())
    }
}
impl ChatMember {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user<'a>(&'a self) -> Cow<'a, User> {
        match self {
            Self::ChatMemberOwner(ref v) => v.get_user(),
            Self::ChatMemberAdministrator(ref v) => v.get_user(),
            Self::ChatMemberMember(ref v) => v.get_user(),
            Self::ChatMemberRestricted(ref v) => v.get_user(),
            Self::ChatMemberLeft(ref v) => v.get_user(),
            Self::ChatMemberBanned(ref v) => v.get_user(),
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about a poll."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Poll {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    #[serde(rename = "question")]
    question: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    #[serde(rename = "options")]
    options: Vec<PollOption>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    #[serde(rename = "total_voter_count")]
    total_voter_count: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    #[serde(rename = "is_closed")]
    is_closed: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    #[serde(rename = "allows_multiple_answers")]
    allows_multiple_answers: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "correct_option_id",
        default
    )]
    correct_option_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "explanation",
        default
    )]
    explanation: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "explanation_entities",
        default
    )]
    explanation_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "open_period",
        default
    )]
    open_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "close_date",
        default
    )]
    close_date: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Poll that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPoll {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    #[serde(rename = "question")]
    question: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    #[serde(rename = "options")]
    options: Vec<PollOption>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    #[serde(rename = "total_voter_count")]
    total_voter_count: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    #[serde(rename = "is_closed")]
    is_closed: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    #[serde(rename = "allows_multiple_answers")]
    allows_multiple_answers: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    correct_option_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    explanation: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    explanation_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    open_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    close_date: Option<i64>,
}
impl From<NoSkipPoll> for Poll {
    fn from(t: NoSkipPoll) -> Self {
        Self {
            id: t.id,
            question: t.question,
            options: t.options,
            total_voter_count: t.total_voter_count,
            is_closed: t.is_closed,
            is_anonymous: t.is_anonymous,
            tg_type: t.tg_type,
            allows_multiple_answers: t.allows_multiple_answers,
            correct_option_id: t.correct_option_id,
            explanation: t.explanation,
            explanation_entities: t.explanation_entities,
            open_period: t.open_period,
            close_date: t.close_date,
        }
    }
}
impl Into<NoSkipPoll> for Poll {
    fn into(self) -> NoSkipPoll {
        NoSkipPoll {
            id: self.id,
            question: self.question,
            options: self.options,
            total_voter_count: self.total_voter_count,
            is_closed: self.is_closed,
            is_anonymous: self.is_anonymous,
            tg_type: self.tg_type,
            allows_multiple_answers: self.allows_multiple_answers,
            correct_option_id: self.correct_option_id,
            explanation: self.explanation,
            explanation_entities: self.explanation_entities,
            open_period: self.open_period,
            close_date: self.close_date,
        }
    }
}
impl NoSkipPoll {
    pub fn skip(self) -> Poll {
        self.into()
    }
}
impl Poll {
    pub fn noskip(self) -> NoSkipPoll {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about a poll."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PollBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    #[serde(rename = "question")]
    question: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    #[serde(rename = "options")]
    options: Vec<PollOption>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    #[serde(rename = "total_voter_count")]
    total_voter_count: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    #[serde(rename = "is_closed")]
    is_closed: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    #[serde(rename = "allows_multiple_answers")]
    allows_multiple_answers: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "correct_option_id",
        default
    )]
    correct_option_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "explanation",
        default
    )]
    explanation: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "explanation_entities",
        default
    )]
    explanation_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "open_period",
        default
    )]
    open_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "close_date",
        default
    )]
    close_date: Option<i64>,
}
impl PollBuilder {
    pub fn new(
        id: String,
        question: String,
        options: Vec<PollOption>,
        total_voter_count: i64,
        is_closed: bool,
        is_anonymous: bool,
        allows_multiple_answers: bool,
    ) -> Self {
        Self {
            tg_type: "Poll".to_owned(),
            id,
            question,
            options,
            total_voter_count,
            is_closed,
            is_anonymous,
            allows_multiple_answers,
            correct_option_id: None,
            explanation: None,
            explanation_entities: None,
            open_period: None,
            close_date: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    pub fn set_question(mut self, question: String) -> Self {
        self.question = question;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    pub fn set_options(mut self, options: Vec<PollOption>) -> Self {
        self.options = options;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    pub fn set_total_voter_count(mut self, total_voter_count: i64) -> Self {
        self.total_voter_count = total_voter_count;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    pub fn set_is_closed(mut self, is_closed: bool) -> Self {
        self.is_closed = is_closed;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    pub fn set_is_anonymous(mut self, is_anonymous: bool) -> Self {
        self.is_anonymous = is_anonymous;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    pub fn set_allows_multiple_answers(mut self, allows_multiple_answers: bool) -> Self {
        self.allows_multiple_answers = allows_multiple_answers;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    pub fn set_correct_option_id(mut self, correct_option_id: i64) -> Self {
        self.correct_option_id = Some(correct_option_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    pub fn set_explanation(mut self, explanation: String) -> Self {
        self.explanation = Some(explanation);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    pub fn set_explanation_entities(mut self, explanation_entities: Vec<MessageEntity>) -> Self {
        self.explanation_entities = Some(explanation_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    pub fn set_open_period(mut self, open_period: i64) -> Self {
        self.open_period = Some(open_period);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    pub fn set_close_date(mut self, close_date: i64) -> Self {
        self.close_date = Some(close_date);
        self
    }
    pub fn build(self) -> Poll {
        Poll {
            id: self.id,
            question: self.question,
            options: self.options,
            total_voter_count: self.total_voter_count,
            is_closed: self.is_closed,
            is_anonymous: self.is_anonymous,
            tg_type: self.tg_type,
            allows_multiple_answers: self.allows_multiple_answers,
            correct_option_id: self.correct_option_id,
            explanation: self.explanation,
            explanation_entities: self.explanation_entities,
            open_period: self.open_period,
            close_date: self.close_date,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a voice message stored on the Telegram servers. By default, this voice message will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the voice message.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedVoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    #[serde(rename = "voice_file_id")]
    voice_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultCachedVoice that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultCachedVoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    #[serde(rename = "voice_file_id")]
    voice_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultCachedVoice> for InlineQueryResultCachedVoice {
    fn from(t: NoSkipInlineQueryResultCachedVoice) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            voice_file_id: t.voice_file_id,
            title: t.title,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultCachedVoice> for InlineQueryResultCachedVoice {
    fn into(self) -> NoSkipInlineQueryResultCachedVoice {
        NoSkipInlineQueryResultCachedVoice {
            tg_type: self.tg_type,
            id: self.id,
            voice_file_id: self.voice_file_id,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultCachedVoice {
    pub fn skip(self) -> InlineQueryResultCachedVoice {
        self.into()
    }
}
impl InlineQueryResultCachedVoice {
    pub fn noskip(self) -> NoSkipInlineQueryResultCachedVoice {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a voice message stored on the Telegram servers. By default, this voice message will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the voice message.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedVoiceBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    #[serde(rename = "voice_file_id")]
    voice_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultCachedVoiceBuilder {
    pub fn new(id: String, voice_file_id: String, title: String) -> Self {
        Self {
            tg_type: "voice".to_owned(),
            id,
            voice_file_id,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    pub fn set_voice_file_id(mut self, voice_file_id: String) -> Self {
        self.voice_file_id = voice_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultCachedVoice {
        InlineQueryResultCachedVoice {
            tg_type: self.tg_type,
            id: self.id,
            voice_file_id: self.voice_file_id,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains basic information about a successful payment."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SuccessfulPayment {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "total_amount")]
    total_amount: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    #[serde(rename = "invoice_payload")]
    invoice_payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "shipping_option_id",
        default
    )]
    shipping_option_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "order_info",
        default
    )]
    order_info: Option<Box<OrderInfo>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Telegram payment identifier"]
    #[serde(rename = "telegram_payment_charge_id")]
    telegram_payment_charge_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Provider payment identifier"]
    #[serde(rename = "provider_payment_charge_id")]
    provider_payment_charge_id: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to SuccessfulPayment that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipSuccessfulPayment {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "total_amount")]
    total_amount: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    #[serde(rename = "invoice_payload")]
    invoice_payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    shipping_option_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    order_info: Option<Box<OrderInfo>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Telegram payment identifier"]
    #[serde(rename = "telegram_payment_charge_id")]
    telegram_payment_charge_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Provider payment identifier"]
    #[serde(rename = "provider_payment_charge_id")]
    provider_payment_charge_id: String,
}
impl From<NoSkipSuccessfulPayment> for SuccessfulPayment {
    fn from(t: NoSkipSuccessfulPayment) -> Self {
        Self {
            currency: t.currency,
            total_amount: t.total_amount,
            invoice_payload: t.invoice_payload,
            shipping_option_id: t.shipping_option_id,
            order_info: t.order_info,
            telegram_payment_charge_id: t.telegram_payment_charge_id,
            provider_payment_charge_id: t.provider_payment_charge_id,
        }
    }
}
impl Into<NoSkipSuccessfulPayment> for SuccessfulPayment {
    fn into(self) -> NoSkipSuccessfulPayment {
        NoSkipSuccessfulPayment {
            currency: self.currency,
            total_amount: self.total_amount,
            invoice_payload: self.invoice_payload,
            shipping_option_id: self.shipping_option_id,
            order_info: self.order_info,
            telegram_payment_charge_id: self.telegram_payment_charge_id,
            provider_payment_charge_id: self.provider_payment_charge_id,
        }
    }
}
impl NoSkipSuccessfulPayment {
    pub fn skip(self) -> SuccessfulPayment {
        self.into()
    }
}
impl SuccessfulPayment {
    pub fn noskip(self) -> NoSkipSuccessfulPayment {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains basic information about a successful payment."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SuccessfulPaymentBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "total_amount")]
    total_amount: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    #[serde(rename = "invoice_payload")]
    invoice_payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "shipping_option_id",
        default
    )]
    shipping_option_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "order_info",
        default
    )]
    order_info: Option<Box<OrderInfo>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Telegram payment identifier"]
    #[serde(rename = "telegram_payment_charge_id")]
    telegram_payment_charge_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Provider payment identifier"]
    #[serde(rename = "provider_payment_charge_id")]
    provider_payment_charge_id: String,
}
impl SuccessfulPaymentBuilder {
    pub fn new(
        currency: String,
        total_amount: i64,
        invoice_payload: String,
        telegram_payment_charge_id: String,
        provider_payment_charge_id: String,
    ) -> Self {
        Self {
            currency,
            total_amount,
            invoice_payload,
            telegram_payment_charge_id,
            provider_payment_charge_id,
            shipping_option_id: None,
            order_info: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn set_currency(mut self, currency: String) -> Self {
        self.currency = currency;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn set_total_amount(mut self, total_amount: i64) -> Self {
        self.total_amount = total_amount;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn set_invoice_payload(mut self, invoice_payload: String) -> Self {
        self.invoice_payload = invoice_payload;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    pub fn set_shipping_option_id(mut self, shipping_option_id: String) -> Self {
        self.shipping_option_id = Some(shipping_option_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    pub fn set_order_info(mut self, order_info: Box<OrderInfo>) -> Self {
        self.order_info = Some(order_info);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Telegram payment identifier"]
    pub fn set_telegram_payment_charge_id(mut self, telegram_payment_charge_id: String) -> Self {
        self.telegram_payment_charge_id = telegram_payment_charge_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Provider payment identifier"]
    pub fn set_provider_payment_charge_id(mut self, provider_payment_charge_id: String) -> Self {
        self.provider_payment_charge_id = provider_payment_charge_id;
        self
    }
    pub fn build(self) -> SuccessfulPayment {
        SuccessfulPayment {
            currency: self.currency,
            total_amount: self.total_amount,
            invoice_payload: self.invoice_payload,
            shipping_option_id: self.shipping_option_id,
            order_info: self.order_info,
            telegram_payment_charge_id: self.telegram_payment_charge_id,
            provider_payment_charge_id: self.provider_payment_charge_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a general file to be sent."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputMediaDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "disable_content_type_detection",
        default
    )]
    disable_content_type_detection: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputMediaDocument that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputMediaDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    disable_content_type_detection: Option<bool>,
}
impl From<NoSkipInputMediaDocument> for InputMediaDocument {
    fn from(t: NoSkipInputMediaDocument) -> Self {
        Self {
            tg_type: t.tg_type,
            media: t.media,
            thumbnail: t.thumbnail,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            disable_content_type_detection: t.disable_content_type_detection,
        }
    }
}
impl Into<NoSkipInputMediaDocument> for InputMediaDocument {
    fn into(self) -> NoSkipInputMediaDocument {
        NoSkipInputMediaDocument {
            tg_type: self.tg_type,
            media: self.media,
            thumbnail: self.thumbnail,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            disable_content_type_detection: self.disable_content_type_detection,
        }
    }
}
impl NoSkipInputMediaDocument {
    pub fn skip(self) -> InputMediaDocument {
        self.into()
    }
}
impl InputMediaDocument {
    pub fn noskip(self) -> NoSkipInputMediaDocument {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a general file to be sent."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputMediaDocumentBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "disable_content_type_detection",
        default
    )]
    disable_content_type_detection: Option<bool>,
}
impl InputMediaDocumentBuilder {
    pub fn new(media: Option<InputFile>) -> Self {
        Self {
            tg_type: "document".to_owned(),
            media,
            thumbnail: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            disable_content_type_detection: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_media(mut self, media: Option<InputFile>) -> Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_thumbnail(mut self, thumbnail: InputFile) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    pub fn set_disable_content_type_detection(
        mut self,
        disable_content_type_detection: bool,
    ) -> Self {
        self.disable_content_type_detection = Some(disable_content_type_detection);
        self
    }
    pub fn build(self) -> InputMediaDocument {
        InputMediaDocument {
            tg_type: self.tg_type,
            media: self.media,
            thumbnail: self.thumbnail,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            disable_content_type_detection: self.disable_content_type_detection,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a point on the map."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Location {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude as defined by sender"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude as defined by sender"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "horizontal_accuracy",
        default
    )]
    horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "live_period",
        default
    )]
    live_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "heading", default)]
    heading: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "proximity_alert_radius",
        default
    )]
    proximity_alert_radius: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Location that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipLocation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude as defined by sender"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude as defined by sender"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."]
    live_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."]
    heading: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."]
    proximity_alert_radius: Option<i64>,
}
impl From<NoSkipLocation> for Location {
    fn from(t: NoSkipLocation) -> Self {
        Self {
            longitude: t.longitude,
            latitude: t.latitude,
            horizontal_accuracy: t.horizontal_accuracy,
            live_period: t.live_period,
            heading: t.heading,
            proximity_alert_radius: t.proximity_alert_radius,
        }
    }
}
impl Into<NoSkipLocation> for Location {
    fn into(self) -> NoSkipLocation {
        NoSkipLocation {
            longitude: self.longitude,
            latitude: self.latitude,
            horizontal_accuracy: self.horizontal_accuracy,
            live_period: self.live_period,
            heading: self.heading,
            proximity_alert_radius: self.proximity_alert_radius,
        }
    }
}
impl NoSkipLocation {
    pub fn skip(self) -> Location {
        self.into()
    }
}
impl Location {
    pub fn noskip(self) -> NoSkipLocation {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a point on the map."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct LocationBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude as defined by sender"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude as defined by sender"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "horizontal_accuracy",
        default
    )]
    horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "live_period",
        default
    )]
    live_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "heading", default)]
    heading: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "proximity_alert_radius",
        default
    )]
    proximity_alert_radius: Option<i64>,
}
impl LocationBuilder {
    pub fn new(
        longitude: ::ordered_float::OrderedFloat<f64>,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> Self {
        Self {
            longitude,
            latitude,
            horizontal_accuracy: None,
            live_period: None,
            heading: None,
            proximity_alert_radius: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude as defined by sender"]
    pub fn set_longitude(mut self, longitude: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude as defined by sender"]
    pub fn set_latitude(mut self, latitude: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn set_horizontal_accuracy(
        mut self,
        horizontal_accuracy: ::ordered_float::OrderedFloat<f64>,
    ) -> Self {
        self.horizontal_accuracy = Some(horizontal_accuracy);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."]
    pub fn set_live_period(mut self, live_period: i64) -> Self {
        self.live_period = Some(live_period);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."]
    pub fn set_heading(mut self, heading: i64) -> Self {
        self.heading = Some(heading);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."]
    pub fn set_proximity_alert_radius(mut self, proximity_alert_radius: i64) -> Self {
        self.proximity_alert_radius = Some(proximity_alert_radius);
        self
    }
    pub fn build(self) -> Location {
        Location {
            longitude: self.longitude,
            latitude: self.latitude,
            horizontal_accuracy: self.horizontal_accuracy,
            live_period: self.live_period,
            heading: self.heading,
            proximity_alert_radius: self.proximity_alert_radius,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one button of the reply keyboard. For simple text buttons, String can be used instead of this object to specify the button text. The optional fields web_app, request_user, request_chat, request_contact, request_location, and request_poll are mutually exclusive.Note: request_contact and request_location options will only work in Telegram versions released after 9 April, 2016. Older clients will display unsupported message.Note: request_poll option will only work in Telegram versions released after 23 January, 2020. Older clients will display unsupported message.Note: web_app option will only work in Telegram versions released after 16 April, 2022. Older clients will display unsupported message.Note: request_user and request_chat options will only work in Telegram versions released after 3 February, 2023. Older clients will display unsupported message."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct KeyboardButton {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a \"user_shared\" service message. Available in private chats only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_user",
        default
    )]
    request_user: Option<KeyboardButtonRequestUser>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a \"chat_shared\" service message. Available in private chats only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_chat",
        default
    )]
    request_chat: Option<KeyboardButtonRequestChat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_contact",
        default
    )]
    request_contact: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_location",
        default
    )]
    request_location: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_poll",
        default
    )]
    request_poll: Option<KeyboardButtonPollType>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a \"web_app_data\" service message. Available in private chats only."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "web_app", default)]
    web_app: Option<WebAppInfo>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to KeyboardButton that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipKeyboardButton {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a \"user_shared\" service message. Available in private chats only."]
    request_user: Option<KeyboardButtonRequestUser>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a \"chat_shared\" service message. Available in private chats only."]
    request_chat: Option<KeyboardButtonRequestChat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."]
    request_contact: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."]
    request_location: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."]
    request_poll: Option<KeyboardButtonPollType>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a \"web_app_data\" service message. Available in private chats only."]
    web_app: Option<WebAppInfo>,
}
impl From<NoSkipKeyboardButton> for KeyboardButton {
    fn from(t: NoSkipKeyboardButton) -> Self {
        Self {
            text: t.text,
            request_user: t.request_user,
            request_chat: t.request_chat,
            request_contact: t.request_contact,
            request_location: t.request_location,
            request_poll: t.request_poll,
            web_app: t.web_app,
        }
    }
}
impl Into<NoSkipKeyboardButton> for KeyboardButton {
    fn into(self) -> NoSkipKeyboardButton {
        NoSkipKeyboardButton {
            text: self.text,
            request_user: self.request_user,
            request_chat: self.request_chat,
            request_contact: self.request_contact,
            request_location: self.request_location,
            request_poll: self.request_poll,
            web_app: self.web_app,
        }
    }
}
impl NoSkipKeyboardButton {
    pub fn skip(self) -> KeyboardButton {
        self.into()
    }
}
impl KeyboardButton {
    pub fn noskip(self) -> NoSkipKeyboardButton {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one button of the reply keyboard. For simple text buttons, String can be used instead of this object to specify the button text. The optional fields web_app, request_user, request_chat, request_contact, request_location, and request_poll are mutually exclusive.Note: request_contact and request_location options will only work in Telegram versions released after 9 April, 2016. Older clients will display unsupported message.Note: request_poll option will only work in Telegram versions released after 23 January, 2020. Older clients will display unsupported message.Note: web_app option will only work in Telegram versions released after 16 April, 2022. Older clients will display unsupported message.Note: request_user and request_chat options will only work in Telegram versions released after 3 February, 2023. Older clients will display unsupported message."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct KeyboardButtonBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a \"user_shared\" service message. Available in private chats only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_user",
        default
    )]
    request_user: Option<KeyboardButtonRequestUser>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a \"chat_shared\" service message. Available in private chats only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_chat",
        default
    )]
    request_chat: Option<KeyboardButtonRequestChat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_contact",
        default
    )]
    request_contact: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_location",
        default
    )]
    request_location: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "request_poll",
        default
    )]
    request_poll: Option<KeyboardButtonPollType>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a \"web_app_data\" service message. Available in private chats only."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "web_app", default)]
    web_app: Option<WebAppInfo>,
}
impl KeyboardButtonBuilder {
    pub fn new(text: String) -> Self {
        Self {
            text,
            request_user: None,
            request_chat: None,
            request_contact: None,
            request_location: None,
            request_poll: None,
            web_app: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"]
    pub fn set_text(mut self, text: String) -> Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a \"user_shared\" service message. Available in private chats only."]
    pub fn set_request_user(mut self, request_user: KeyboardButtonRequestUser) -> Self {
        self.request_user = Some(request_user);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a \"chat_shared\" service message. Available in private chats only."]
    pub fn set_request_chat(mut self, request_chat: KeyboardButtonRequestChat) -> Self {
        self.request_chat = Some(request_chat);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."]
    pub fn set_request_contact(mut self, request_contact: bool) -> Self {
        self.request_contact = Some(request_contact);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."]
    pub fn set_request_location(mut self, request_location: bool) -> Self {
        self.request_location = Some(request_location);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."]
    pub fn set_request_poll(mut self, request_poll: KeyboardButtonPollType) -> Self {
        self.request_poll = Some(request_poll);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a \"web_app_data\" service message. Available in private chats only."]
    pub fn set_web_app(mut self, web_app: WebAppInfo) -> Self {
        self.web_app = Some(web_app);
        self
    }
    pub fn build(self) -> KeyboardButton {
        KeyboardButton {
            text: self.text,
            request_user: self.request_user,
            request_chat: self.request_chat,
            request_contact: self.request_contact,
            request_location: self.request_location,
            request_poll: self.request_poll,
            web_app: self.web_app,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that isn't currently a member of the chat, but may join it themselves."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberLeft {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatMemberLeft that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatMemberLeft {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
}
impl From<NoSkipChatMemberLeft> for ChatMemberLeft {
    fn from(t: NoSkipChatMemberLeft) -> Self {
        Self { user: t.user }
    }
}
impl Into<NoSkipChatMemberLeft> for ChatMemberLeft {
    fn into(self) -> NoSkipChatMemberLeft {
        NoSkipChatMemberLeft { user: self.user }
    }
}
impl NoSkipChatMemberLeft {
    pub fn skip(self) -> ChatMemberLeft {
        self.into()
    }
}
impl ChatMemberLeft {
    pub fn noskip(self) -> NoSkipChatMemberLeft {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that isn't currently a member of the chat, but may join it themselves."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberLeftBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
}
impl ChatMemberLeftBuilder {
    pub fn new(user: User) -> Self {
        Self { user }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user(mut self, user: User) -> Self {
        self.user = user;
        self
    }
    pub fn build(self) -> ChatMemberLeft {
        ChatMemberLeft { user: self.user }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a bot command."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommand {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."]
    #[serde(rename = "command")]
    command: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the command; 1-256 characters."]
    #[serde(rename = "description")]
    description: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotCommand that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotCommand {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."]
    #[serde(rename = "command")]
    command: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the command; 1-256 characters."]
    #[serde(rename = "description")]
    description: String,
}
impl From<NoSkipBotCommand> for BotCommand {
    fn from(t: NoSkipBotCommand) -> Self {
        Self {
            command: t.command,
            description: t.description,
        }
    }
}
impl Into<NoSkipBotCommand> for BotCommand {
    fn into(self) -> NoSkipBotCommand {
        NoSkipBotCommand {
            command: self.command,
            description: self.description,
        }
    }
}
impl NoSkipBotCommand {
    pub fn skip(self) -> BotCommand {
        self.into()
    }
}
impl BotCommand {
    pub fn noskip(self) -> NoSkipBotCommand {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a bot command."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."]
    #[serde(rename = "command")]
    command: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the command; 1-256 characters."]
    #[serde(rename = "description")]
    description: String,
}
impl BotCommandBuilder {
    pub fn new(command: String, description: String) -> Self {
        Self {
            command,
            description,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."]
    pub fn set_command(mut self, command: String) -> Self {
        self.command = command;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the command; 1-256 characters."]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = description;
        self
    }
    pub fn build(self) -> BotCommand {
        BotCommand {
            command: self.command,
            description: self.description,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a venue."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Venue {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Venue location. Can't be a live location"]
    #[serde(rename = "location")]
    location: Location,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    #[serde(rename = "address")]
    address: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_id",
        default
    )]
    foursquare_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_type",
        default
    )]
    foursquare_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_id",
        default
    )]
    google_place_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_type",
        default
    )]
    google_place_type: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Venue that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipVenue {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Venue location. Can't be a live location"]
    #[serde(rename = "location")]
    location: Location,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    #[serde(rename = "address")]
    address: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue"]
    foursquare_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    foursquare_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    google_place_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    google_place_type: Option<String>,
}
impl From<NoSkipVenue> for Venue {
    fn from(t: NoSkipVenue) -> Self {
        Self {
            location: t.location,
            title: t.title,
            address: t.address,
            foursquare_id: t.foursquare_id,
            foursquare_type: t.foursquare_type,
            google_place_id: t.google_place_id,
            google_place_type: t.google_place_type,
        }
    }
}
impl Into<NoSkipVenue> for Venue {
    fn into(self) -> NoSkipVenue {
        NoSkipVenue {
            location: self.location,
            title: self.title,
            address: self.address,
            foursquare_id: self.foursquare_id,
            foursquare_type: self.foursquare_type,
            google_place_id: self.google_place_id,
            google_place_type: self.google_place_type,
        }
    }
}
impl NoSkipVenue {
    pub fn skip(self) -> Venue {
        self.into()
    }
}
impl Venue {
    pub fn noskip(self) -> NoSkipVenue {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a venue."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VenueBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Venue location. Can't be a live location"]
    #[serde(rename = "location")]
    location: Location,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    #[serde(rename = "address")]
    address: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_id",
        default
    )]
    foursquare_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_type",
        default
    )]
    foursquare_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_id",
        default
    )]
    google_place_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_type",
        default
    )]
    google_place_type: Option<String>,
}
impl VenueBuilder {
    pub fn new(location: Location, title: String, address: String) -> Self {
        Self {
            location,
            title,
            address,
            foursquare_id: None,
            foursquare_type: None,
            google_place_id: None,
            google_place_type: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Venue location. Can't be a live location"]
    pub fn set_location(mut self, location: Location) -> Self {
        self.location = location;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn set_address(mut self, address: String) -> Self {
        self.address = address;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue"]
    pub fn set_foursquare_id(mut self, foursquare_id: String) -> Self {
        self.foursquare_id = Some(foursquare_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn set_foursquare_type(mut self, foursquare_type: String) -> Self {
        self.foursquare_type = Some(foursquare_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn set_google_place_id(mut self, google_place_id: String) -> Self {
        self.google_place_id = Some(google_place_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn set_google_place_type(mut self, google_place_type: String) -> Self {
        self.google_place_type = Some(google_place_type);
        self
    }
    pub fn build(self) -> Venue {
        Venue {
            location: self.location,
            title: self.title,
            address: self.address,
            foursquare_id: self.foursquare_id,
            foursquare_type: self.foursquare_type,
            google_place_id: self.google_place_id,
            google_place_type: self.google_place_type,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with the selfie with a document. The error is considered resolved when the file with the selfie changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorSelfie {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportElementErrorSelfie that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportElementErrorSelfie {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl From<NoSkipPassportElementErrorSelfie> for PassportElementErrorSelfie {
    fn from(t: NoSkipPassportElementErrorSelfie) -> Self {
        Self {
            source: t.source,
            tg_type: t.tg_type,
            file_hash: t.file_hash,
            message: t.message,
        }
    }
}
impl Into<NoSkipPassportElementErrorSelfie> for PassportElementErrorSelfie {
    fn into(self) -> NoSkipPassportElementErrorSelfie {
        NoSkipPassportElementErrorSelfie {
            source: self.source,
            tg_type: self.tg_type,
            file_hash: self.file_hash,
            message: self.message,
        }
    }
}
impl NoSkipPassportElementErrorSelfie {
    pub fn skip(self) -> PassportElementErrorSelfie {
        self.into()
    }
}
impl PassportElementErrorSelfie {
    pub fn noskip(self) -> NoSkipPassportElementErrorSelfie {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with the selfie with a document. The error is considered resolved when the file with the selfie changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorSelfieBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl PassportElementErrorSelfieBuilder {
    pub fn new(source: String, file_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorSelfie".to_owned(),
            source,
            file_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    pub fn set_source(mut self, source: String) -> Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    pub fn set_file_hash(mut self, file_hash: String) -> Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message(mut self, message: String) -> Self {
        self.message = message;
        self
    }
    pub fn build(self) -> PassportElementErrorSelfie {
        PassportElementErrorSelfie {
            source: self.source,
            tg_type: self.tg_type,
            file_hash: self.file_hash,
            message: self.message,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum ForumTopicClosed {}
impl ForumTopicClosed {}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a video message (available in Telegram apps as of v.4.0)."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VideoNote {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width and height (diameter of the video message) as defined by sender"]
    #[serde(rename = "length")]
    length: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to VideoNote that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipVideoNote {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width and height (diameter of the video message) as defined by sender"]
    #[serde(rename = "length")]
    length: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    file_size: Option<i64>,
}
impl From<NoSkipVideoNote> for VideoNote {
    fn from(t: NoSkipVideoNote) -> Self {
        Self {
            file_id: t.file_id,
            file_unique_id: t.file_unique_id,
            length: t.length,
            duration: t.duration,
            thumbnail: t.thumbnail,
            file_size: t.file_size,
        }
    }
}
impl Into<NoSkipVideoNote> for VideoNote {
    fn into(self) -> NoSkipVideoNote {
        NoSkipVideoNote {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            length: self.length,
            duration: self.duration,
            thumbnail: self.thumbnail,
            file_size: self.file_size,
        }
    }
}
impl NoSkipVideoNote {
    pub fn skip(self) -> VideoNote {
        self.into()
    }
}
impl VideoNote {
    pub fn noskip(self) -> NoSkipVideoNote {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a video message (available in Telegram apps as of v.4.0)."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VideoNoteBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width and height (diameter of the video message) as defined by sender"]
    #[serde(rename = "length")]
    length: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
impl VideoNoteBuilder {
    pub fn new(file_id: String, file_unique_id: String, length: i64, duration: i64) -> Self {
        Self {
            file_id,
            file_unique_id,
            length,
            duration,
            thumbnail: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id(mut self, file_id: String) -> Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id(mut self, file_unique_id: String) -> Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width and height (diameter of the video message) as defined by sender"]
    pub fn set_length(mut self, length: i64) -> Self {
        self.length = length;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn set_duration(mut self, duration: i64) -> Self {
        self.duration = duration;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    pub fn set_thumbnail(mut self, thumbnail: PhotoSize) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn set_file_size(mut self, file_size: i64) -> Self {
        self.file_size = Some(file_size);
        self
    }
    pub fn build(self) -> VideoNote {
        VideoNote {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            length: self.length,
            duration: self.duration,
            thumbnail: self.thumbnail,
            file_size: self.file_size,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an inline keyboard that appears right next to the message it belongs to.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will display unsupported message."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineKeyboardMarkup {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of InlineKeyboardButton objects"]
    #[serde(rename = "inline_keyboard")]
    inline_keyboard: Vec<Vec<InlineKeyboardButton>>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineKeyboardMarkup that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineKeyboardMarkup {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of InlineKeyboardButton objects"]
    #[serde(rename = "inline_keyboard")]
    inline_keyboard: Vec<Vec<InlineKeyboardButton>>,
}
impl From<NoSkipInlineKeyboardMarkup> for InlineKeyboardMarkup {
    fn from(t: NoSkipInlineKeyboardMarkup) -> Self {
        Self {
            inline_keyboard: t.inline_keyboard,
        }
    }
}
impl Into<NoSkipInlineKeyboardMarkup> for InlineKeyboardMarkup {
    fn into(self) -> NoSkipInlineKeyboardMarkup {
        NoSkipInlineKeyboardMarkup {
            inline_keyboard: self.inline_keyboard,
        }
    }
}
impl NoSkipInlineKeyboardMarkup {
    pub fn skip(self) -> InlineKeyboardMarkup {
        self.into()
    }
}
impl InlineKeyboardMarkup {
    pub fn noskip(self) -> NoSkipInlineKeyboardMarkup {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an inline keyboard that appears right next to the message it belongs to.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will display unsupported message."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineKeyboardMarkupBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of InlineKeyboardButton objects"]
    #[serde(rename = "inline_keyboard")]
    inline_keyboard: Vec<Vec<InlineKeyboardButton>>,
}
impl InlineKeyboardMarkupBuilder {
    pub fn new(inline_keyboard: Vec<Vec<InlineKeyboardButton>>) -> Self {
        Self { inline_keyboard }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of InlineKeyboardButton objects"]
    pub fn set_inline_keyboard(mut self, inline_keyboard: Vec<Vec<InlineKeyboardButton>>) -> Self {
        self.inline_keyboard = inline_keyboard;
        self
    }
    pub fn build(self) -> InlineKeyboardMarkup {
        InlineKeyboardMarkup {
            inline_keyboard: self.inline_keyboard,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents the content of a service message, sent whenever a user in the chat triggers a proximity alert set by another user."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ProximityAlertTriggered {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that triggered the alert"]
    #[serde(rename = "traveler")]
    traveler: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that set the alert"]
    #[serde(rename = "watcher")]
    watcher: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The distance between the users"]
    #[serde(rename = "distance")]
    distance: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ProximityAlertTriggered that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipProximityAlertTriggered {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that triggered the alert"]
    #[serde(rename = "traveler")]
    traveler: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that set the alert"]
    #[serde(rename = "watcher")]
    watcher: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The distance between the users"]
    #[serde(rename = "distance")]
    distance: i64,
}
impl From<NoSkipProximityAlertTriggered> for ProximityAlertTriggered {
    fn from(t: NoSkipProximityAlertTriggered) -> Self {
        Self {
            traveler: t.traveler,
            watcher: t.watcher,
            distance: t.distance,
        }
    }
}
impl Into<NoSkipProximityAlertTriggered> for ProximityAlertTriggered {
    fn into(self) -> NoSkipProximityAlertTriggered {
        NoSkipProximityAlertTriggered {
            traveler: self.traveler,
            watcher: self.watcher,
            distance: self.distance,
        }
    }
}
impl NoSkipProximityAlertTriggered {
    pub fn skip(self) -> ProximityAlertTriggered {
        self.into()
    }
}
impl ProximityAlertTriggered {
    pub fn noskip(self) -> NoSkipProximityAlertTriggered {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents the content of a service message, sent whenever a user in the chat triggers a proximity alert set by another user."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ProximityAlertTriggeredBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that triggered the alert"]
    #[serde(rename = "traveler")]
    traveler: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that set the alert"]
    #[serde(rename = "watcher")]
    watcher: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The distance between the users"]
    #[serde(rename = "distance")]
    distance: i64,
}
impl ProximityAlertTriggeredBuilder {
    pub fn new(traveler: User, watcher: User, distance: i64) -> Self {
        Self {
            traveler,
            watcher,
            distance,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that triggered the alert"]
    pub fn set_traveler(mut self, traveler: User) -> Self {
        self.traveler = traveler;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that set the alert"]
    pub fn set_watcher(mut self, watcher: User) -> Self {
        self.watcher = watcher;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The distance between the users"]
    pub fn set_distance(mut self, distance: i64) -> Self {
        self.distance = distance;
        self
    }
    pub fn build(self) -> ProximityAlertTriggered {
        ProximityAlertTriggered {
            traveler: self.traveler,
            watcher: self.watcher,
            distance: self.distance,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about a new forum topic created in the chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ForumTopicCreated {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    #[serde(rename = "name")]
    name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    #[serde(rename = "icon_color")]
    icon_color: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "icon_custom_emoji_id",
        default
    )]
    icon_custom_emoji_id: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ForumTopicCreated that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipForumTopicCreated {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    #[serde(rename = "name")]
    name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    #[serde(rename = "icon_color")]
    icon_color: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    icon_custom_emoji_id: Option<String>,
}
impl From<NoSkipForumTopicCreated> for ForumTopicCreated {
    fn from(t: NoSkipForumTopicCreated) -> Self {
        Self {
            name: t.name,
            icon_color: t.icon_color,
            icon_custom_emoji_id: t.icon_custom_emoji_id,
        }
    }
}
impl Into<NoSkipForumTopicCreated> for ForumTopicCreated {
    fn into(self) -> NoSkipForumTopicCreated {
        NoSkipForumTopicCreated {
            name: self.name,
            icon_color: self.icon_color,
            icon_custom_emoji_id: self.icon_custom_emoji_id,
        }
    }
}
impl NoSkipForumTopicCreated {
    pub fn skip(self) -> ForumTopicCreated {
        self.into()
    }
}
impl ForumTopicCreated {
    pub fn noskip(self) -> NoSkipForumTopicCreated {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about a new forum topic created in the chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ForumTopicCreatedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    #[serde(rename = "name")]
    name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    #[serde(rename = "icon_color")]
    icon_color: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "icon_custom_emoji_id",
        default
    )]
    icon_custom_emoji_id: Option<String>,
}
impl ForumTopicCreatedBuilder {
    pub fn new(name: String, icon_color: i64) -> Self {
        Self {
            name,
            icon_color,
            icon_custom_emoji_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    pub fn set_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    pub fn set_icon_color(mut self, icon_color: i64) -> Self {
        self.icon_color = icon_color;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    pub fn set_icon_custom_emoji_id(mut self, icon_custom_emoji_id: String) -> Self {
        self.icon_custom_emoji_id = Some(icon_custom_emoji_id);
        self
    }
    pub fn build(self) -> ForumTopicCreated {
        ForumTopicCreated {
            name: self.name,
            icon_color: self.icon_color,
            icon_custom_emoji_id: self.icon_custom_emoji_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a sticker."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Sticker {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the sticker, currently one of \"regular\", \"mask\", \"custom_emoji\". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video."]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker width"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker height"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is animated"]
    #[serde(rename = "is_animated")]
    is_animated: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is a video sticker"]
    #[serde(rename = "is_video")]
    is_video: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker thumbnail in the .WEBP or .JPG format"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Emoji associated with the sticker"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "emoji", default)]
    emoji: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the sticker set to which the sticker belongs"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "set_name", default)]
    set_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For premium regular stickers, premium animation for the sticker"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "premium_animation",
        default
    )]
    premium_animation: Option<File>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For mask stickers, the position where the mask should be placed"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "mask_position",
        default
    )]
    mask_position: Option<MaskPosition>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For custom emoji stickers, unique identifier of the custom emoji"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "custom_emoji_id",
        default
    )]
    custom_emoji_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "needs_repainting",
        default
    )]
    needs_repainting: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Sticker that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipSticker {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the sticker, currently one of \"regular\", \"mask\", \"custom_emoji\". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video."]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker width"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker height"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is animated"]
    #[serde(rename = "is_animated")]
    is_animated: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is a video sticker"]
    #[serde(rename = "is_video")]
    is_video: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker thumbnail in the .WEBP or .JPG format"]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Emoji associated with the sticker"]
    emoji: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the sticker set to which the sticker belongs"]
    set_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For premium regular stickers, premium animation for the sticker"]
    premium_animation: Option<File>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For mask stickers, the position where the mask should be placed"]
    mask_position: Option<MaskPosition>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For custom emoji stickers, unique identifier of the custom emoji"]
    custom_emoji_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"]
    needs_repainting: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    file_size: Option<i64>,
}
impl From<NoSkipSticker> for Sticker {
    fn from(t: NoSkipSticker) -> Self {
        Self {
            file_id: t.file_id,
            file_unique_id: t.file_unique_id,
            tg_type: t.tg_type,
            width: t.width,
            height: t.height,
            is_animated: t.is_animated,
            is_video: t.is_video,
            thumbnail: t.thumbnail,
            emoji: t.emoji,
            set_name: t.set_name,
            premium_animation: t.premium_animation,
            mask_position: t.mask_position,
            custom_emoji_id: t.custom_emoji_id,
            needs_repainting: t.needs_repainting,
            file_size: t.file_size,
        }
    }
}
impl Into<NoSkipSticker> for Sticker {
    fn into(self) -> NoSkipSticker {
        NoSkipSticker {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            tg_type: self.tg_type,
            width: self.width,
            height: self.height,
            is_animated: self.is_animated,
            is_video: self.is_video,
            thumbnail: self.thumbnail,
            emoji: self.emoji,
            set_name: self.set_name,
            premium_animation: self.premium_animation,
            mask_position: self.mask_position,
            custom_emoji_id: self.custom_emoji_id,
            needs_repainting: self.needs_repainting,
            file_size: self.file_size,
        }
    }
}
impl NoSkipSticker {
    pub fn skip(self) -> Sticker {
        self.into()
    }
}
impl Sticker {
    pub fn noskip(self) -> NoSkipSticker {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a sticker."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct StickerBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the sticker, currently one of \"regular\", \"mask\", \"custom_emoji\". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video."]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker width"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker height"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is animated"]
    #[serde(rename = "is_animated")]
    is_animated: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is a video sticker"]
    #[serde(rename = "is_video")]
    is_video: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker thumbnail in the .WEBP or .JPG format"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Emoji associated with the sticker"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "emoji", default)]
    emoji: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the sticker set to which the sticker belongs"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "set_name", default)]
    set_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For premium regular stickers, premium animation for the sticker"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "premium_animation",
        default
    )]
    premium_animation: Option<File>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For mask stickers, the position where the mask should be placed"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "mask_position",
        default
    )]
    mask_position: Option<MaskPosition>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For custom emoji stickers, unique identifier of the custom emoji"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "custom_emoji_id",
        default
    )]
    custom_emoji_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "needs_repainting",
        default
    )]
    needs_repainting: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
impl StickerBuilder {
    pub fn new(
        file_id: String,
        file_unique_id: String,
        width: i64,
        height: i64,
        is_animated: bool,
        is_video: bool,
    ) -> Self {
        Self {
            tg_type: "Sticker".to_owned(),
            file_id,
            file_unique_id,
            width,
            height,
            is_animated,
            is_video,
            thumbnail: None,
            emoji: None,
            set_name: None,
            premium_animation: None,
            mask_position: None,
            custom_emoji_id: None,
            needs_repainting: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id(mut self, file_id: String) -> Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id(mut self, file_unique_id: String) -> Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the sticker, currently one of \"regular\", \"mask\", \"custom_emoji\". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video."]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker width"]
    pub fn set_width(mut self, width: i64) -> Self {
        self.width = width;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker height"]
    pub fn set_height(mut self, height: i64) -> Self {
        self.height = height;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is animated"]
    pub fn set_is_animated(mut self, is_animated: bool) -> Self {
        self.is_animated = is_animated;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is a video sticker"]
    pub fn set_is_video(mut self, is_video: bool) -> Self {
        self.is_video = is_video;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker thumbnail in the .WEBP or .JPG format"]
    pub fn set_thumbnail(mut self, thumbnail: PhotoSize) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Emoji associated with the sticker"]
    pub fn set_emoji(mut self, emoji: String) -> Self {
        self.emoji = Some(emoji);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the sticker set to which the sticker belongs"]
    pub fn set_set_name(mut self, set_name: String) -> Self {
        self.set_name = Some(set_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For premium regular stickers, premium animation for the sticker"]
    pub fn set_premium_animation(mut self, premium_animation: File) -> Self {
        self.premium_animation = Some(premium_animation);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For mask stickers, the position where the mask should be placed"]
    pub fn set_mask_position(mut self, mask_position: MaskPosition) -> Self {
        self.mask_position = Some(mask_position);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For custom emoji stickers, unique identifier of the custom emoji"]
    pub fn set_custom_emoji_id(mut self, custom_emoji_id: String) -> Self {
        self.custom_emoji_id = Some(custom_emoji_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"]
    pub fn set_needs_repainting(mut self, needs_repainting: bool) -> Self {
        self.needs_repainting = Some(needs_repainting);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn set_file_size(mut self, file_size: i64) -> Self {
        self.file_size = Some(file_size);
        self
    }
    pub fn build(self) -> Sticker {
        Sticker {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            tg_type: self.tg_type,
            width: self.width,
            height: self.height,
            is_animated: self.is_animated,
            is_video: self.is_video,
            thumbnail: self.thumbnail,
            emoji: self.emoji,
            set_name: self.set_name,
            premium_animation: self.premium_animation,
            mask_position: self.mask_position,
            custom_emoji_id: self.custom_emoji_id,
            needs_repainting: self.needs_repainting,
            file_size: self.file_size,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a contact with a phone number. By default, this contact will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the contact.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultContact {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    #[serde(rename = "phone_number")]
    phone_number: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "last_name", default)]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "vcard", default)]
    vcard: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_url",
        default
    )]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_width",
        default
    )]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_height",
        default
    )]
    thumbnail_height: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultContact that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultContact {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    #[serde(rename = "phone_number")]
    phone_number: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    vcard: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    thumbnail_height: Option<i64>,
}
impl From<NoSkipInlineQueryResultContact> for InlineQueryResultContact {
    fn from(t: NoSkipInlineQueryResultContact) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            phone_number: t.phone_number,
            first_name: t.first_name,
            last_name: t.last_name,
            vcard: t.vcard,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
            thumbnail_url: t.thumbnail_url,
            thumbnail_width: t.thumbnail_width,
            thumbnail_height: t.thumbnail_height,
        }
    }
}
impl Into<NoSkipInlineQueryResultContact> for InlineQueryResultContact {
    fn into(self) -> NoSkipInlineQueryResultContact {
        NoSkipInlineQueryResultContact {
            tg_type: self.tg_type,
            id: self.id,
            phone_number: self.phone_number,
            first_name: self.first_name,
            last_name: self.last_name,
            vcard: self.vcard,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
            thumbnail_url: self.thumbnail_url,
            thumbnail_width: self.thumbnail_width,
            thumbnail_height: self.thumbnail_height,
        }
    }
}
impl NoSkipInlineQueryResultContact {
    pub fn skip(self) -> InlineQueryResultContact {
        self.into()
    }
}
impl InlineQueryResultContact {
    pub fn noskip(self) -> NoSkipInlineQueryResultContact {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a contact with a phone number. By default, this contact will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the contact.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultContactBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    #[serde(rename = "phone_number")]
    phone_number: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "last_name", default)]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "vcard", default)]
    vcard: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_url",
        default
    )]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_width",
        default
    )]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_height",
        default
    )]
    thumbnail_height: Option<i64>,
}
impl InlineQueryResultContactBuilder {
    pub fn new(id: String, phone_number: String, first_name: String) -> Self {
        Self {
            tg_type: "contact".to_owned(),
            id,
            phone_number,
            first_name,
            last_name: None,
            vcard: None,
            reply_markup: None,
            input_message_content: None,
            thumbnail_url: None,
            thumbnail_width: None,
            thumbnail_height: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn set_phone_number(mut self, phone_number: String) -> Self {
        self.phone_number = phone_number;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn set_first_name(mut self, first_name: String) -> Self {
        self.first_name = first_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn set_last_name(mut self, last_name: String) -> Self {
        self.last_name = Some(last_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    pub fn set_vcard(mut self, vcard: String) -> Self {
        self.vcard = Some(vcard);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn set_thumbnail_url(mut self, thumbnail_url: String) -> Self {
        self.thumbnail_url = Some(thumbnail_url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn set_thumbnail_width(mut self, thumbnail_width: i64) -> Self {
        self.thumbnail_width = Some(thumbnail_width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn set_thumbnail_height(mut self, thumbnail_height: i64) -> Self {
        self.thumbnail_height = Some(thumbnail_height);
        self
    }
    pub fn build(self) -> InlineQueryResultContact {
        InlineQueryResultContact {
            tg_type: self.tg_type,
            id: self.id,
            phone_number: self.phone_number,
            first_name: self.first_name,
            last_name: self.last_name,
            vcard: self.vcard,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
            thumbnail_url: self.thumbnail_url,
            thumbnail_width: self.thumbnail_width,
            thumbnail_height: self.thumbnail_height,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object describes the position on faces where a mask should be placed by default."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MaskPosition {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The part of the face relative to which the mask should be placed. One of \"forehead\", \"eyes\", \"mouth\", or \"chin\"."]
    #[serde(rename = "point")]
    point: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."]
    #[serde(rename = "x_shift")]
    x_shift: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."]
    #[serde(rename = "y_shift")]
    y_shift: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Mask scaling coefficient. For example, 2.0 means double size."]
    #[serde(rename = "scale")]
    scale: ::ordered_float::OrderedFloat<f64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to MaskPosition that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipMaskPosition {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The part of the face relative to which the mask should be placed. One of \"forehead\", \"eyes\", \"mouth\", or \"chin\"."]
    #[serde(rename = "point")]
    point: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."]
    #[serde(rename = "x_shift")]
    x_shift: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."]
    #[serde(rename = "y_shift")]
    y_shift: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Mask scaling coefficient. For example, 2.0 means double size."]
    #[serde(rename = "scale")]
    scale: ::ordered_float::OrderedFloat<f64>,
}
impl From<NoSkipMaskPosition> for MaskPosition {
    fn from(t: NoSkipMaskPosition) -> Self {
        Self {
            point: t.point,
            x_shift: t.x_shift,
            y_shift: t.y_shift,
            scale: t.scale,
        }
    }
}
impl Into<NoSkipMaskPosition> for MaskPosition {
    fn into(self) -> NoSkipMaskPosition {
        NoSkipMaskPosition {
            point: self.point,
            x_shift: self.x_shift,
            y_shift: self.y_shift,
            scale: self.scale,
        }
    }
}
impl NoSkipMaskPosition {
    pub fn skip(self) -> MaskPosition {
        self.into()
    }
}
impl MaskPosition {
    pub fn noskip(self) -> NoSkipMaskPosition {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object describes the position on faces where a mask should be placed by default."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MaskPositionBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The part of the face relative to which the mask should be placed. One of \"forehead\", \"eyes\", \"mouth\", or \"chin\"."]
    #[serde(rename = "point")]
    point: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."]
    #[serde(rename = "x_shift")]
    x_shift: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."]
    #[serde(rename = "y_shift")]
    y_shift: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Mask scaling coefficient. For example, 2.0 means double size."]
    #[serde(rename = "scale")]
    scale: ::ordered_float::OrderedFloat<f64>,
}
impl MaskPositionBuilder {
    pub fn new(
        point: String,
        x_shift: ::ordered_float::OrderedFloat<f64>,
        y_shift: ::ordered_float::OrderedFloat<f64>,
        scale: ::ordered_float::OrderedFloat<f64>,
    ) -> Self {
        Self {
            point,
            x_shift,
            y_shift,
            scale,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The part of the face relative to which the mask should be placed. One of \"forehead\", \"eyes\", \"mouth\", or \"chin\"."]
    pub fn set_point(mut self, point: String) -> Self {
        self.point = point;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."]
    pub fn set_x_shift(mut self, x_shift: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.x_shift = x_shift;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."]
    pub fn set_y_shift(mut self, y_shift: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.y_shift = y_shift;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Mask scaling coefficient. For example, 2.0 means double size."]
    pub fn set_scale(mut self, scale: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.scale = scale;
        self
    }
    pub fn build(self) -> MaskPosition {
        MaskPosition {
            point: self.point,
            x_shift: self.x_shift,
            y_shift: self.y_shift,
            scale: self.scale,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about the user whose identifier was shared with the bot using a KeyboardButtonRequestUser button."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct UserShared {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."]
    #[serde(rename = "user_id")]
    user_id: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to UserShared that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipUserShared {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."]
    #[serde(rename = "user_id")]
    user_id: i64,
}
impl From<NoSkipUserShared> for UserShared {
    fn from(t: NoSkipUserShared) -> Self {
        Self {
            request_id: t.request_id,
            user_id: t.user_id,
        }
    }
}
impl Into<NoSkipUserShared> for UserShared {
    fn into(self) -> NoSkipUserShared {
        NoSkipUserShared {
            request_id: self.request_id,
            user_id: self.user_id,
        }
    }
}
impl NoSkipUserShared {
    pub fn skip(self) -> UserShared {
        self.into()
    }
}
impl UserShared {
    pub fn noskip(self) -> NoSkipUserShared {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about the user whose identifier was shared with the bot using a KeyboardButtonRequestUser button."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct UserSharedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."]
    #[serde(rename = "user_id")]
    user_id: i64,
}
impl UserSharedBuilder {
    pub fn new(request_id: i64, user_id: i64) -> Self {
        Self {
            request_id,
            user_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    pub fn set_request_id(mut self, request_id: i64) -> Self {
        self.request_id = request_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."]
    pub fn set_user_id(mut self, user_id: i64) -> Self {
        self.user_id = user_id;
        self
    }
    pub fn build(self) -> UserShared {
        UserShared {
            request_id: self.request_id,
            user_id: self.user_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering all group and supergroup chat administrators."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeAllChatAdministrators {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    #[serde(rename = "type")]
    tg_type: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotCommandScopeAllChatAdministrators that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotCommandScopeAllChatAdministrators {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl From<NoSkipBotCommandScopeAllChatAdministrators> for BotCommandScopeAllChatAdministrators {
    fn from(t: NoSkipBotCommandScopeAllChatAdministrators) -> Self {
        Self { tg_type: t.tg_type }
    }
}
impl Into<NoSkipBotCommandScopeAllChatAdministrators> for BotCommandScopeAllChatAdministrators {
    fn into(self) -> NoSkipBotCommandScopeAllChatAdministrators {
        NoSkipBotCommandScopeAllChatAdministrators {
            tg_type: self.tg_type,
        }
    }
}
impl NoSkipBotCommandScopeAllChatAdministrators {
    pub fn skip(self) -> BotCommandScopeAllChatAdministrators {
        self.into()
    }
}
impl BotCommandScopeAllChatAdministrators {
    pub fn noskip(self) -> NoSkipBotCommandScopeAllChatAdministrators {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering all group and supergroup chat administrators."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeAllChatAdministratorsBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl BotCommandScopeAllChatAdministratorsBuilder {
    pub fn new() -> Self {
        Self {
            tg_type: "all_chat_administrators".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    pub fn build(self) -> BotCommandScopeAllChatAdministrators {
        BotCommandScopeAllChatAdministrators {
            tg_type: self.tg_type,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputMediaAnimation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "width", default)]
    width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "height", default)]
    height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "duration", default)]
    duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_spoiler",
        default
    )]
    has_spoiler: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputMediaAnimation that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputMediaAnimation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    has_spoiler: Option<bool>,
}
impl From<NoSkipInputMediaAnimation> for InputMediaAnimation {
    fn from(t: NoSkipInputMediaAnimation) -> Self {
        Self {
            tg_type: t.tg_type,
            media: t.media,
            thumbnail: t.thumbnail,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            width: t.width,
            height: t.height,
            duration: t.duration,
            has_spoiler: t.has_spoiler,
        }
    }
}
impl Into<NoSkipInputMediaAnimation> for InputMediaAnimation {
    fn into(self) -> NoSkipInputMediaAnimation {
        NoSkipInputMediaAnimation {
            tg_type: self.tg_type,
            media: self.media,
            thumbnail: self.thumbnail,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            width: self.width,
            height: self.height,
            duration: self.duration,
            has_spoiler: self.has_spoiler,
        }
    }
}
impl NoSkipInputMediaAnimation {
    pub fn skip(self) -> InputMediaAnimation {
        self.into()
    }
}
impl InputMediaAnimation {
    pub fn noskip(self) -> NoSkipInputMediaAnimation {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputMediaAnimationBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "media")]
    media: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<InputFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "width", default)]
    width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "height", default)]
    height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "duration", default)]
    duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "has_spoiler",
        default
    )]
    has_spoiler: Option<bool>,
}
impl InputMediaAnimationBuilder {
    pub fn new(media: Option<InputFile>) -> Self {
        Self {
            tg_type: "animation".to_owned(),
            media,
            thumbnail: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            width: None,
            height: None,
            duration: None,
            has_spoiler: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_media(mut self, media: Option<InputFile>) -> Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_thumbnail(mut self, thumbnail: InputFile) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    pub fn set_width(mut self, width: i64) -> Self {
        self.width = Some(width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    pub fn set_height(mut self, height: i64) -> Self {
        self.height = Some(height);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    pub fn set_duration(mut self, duration: i64) -> Self {
        self.duration = Some(duration);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    pub fn set_has_spoiler(mut self, has_spoiler: bool) -> Self {
        self.has_spoiler = Some(has_spoiler);
        self
    }
    pub fn build(self) -> InputMediaAnimation {
        InputMediaAnimation {
            tg_type: self.tg_type,
            media: self.media,
            thumbnail: self.thumbnail,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            width: self.width,
            height: self.height,
            duration: self.duration,
            has_spoiler: self.has_spoiler,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents type of a poll, which is allowed to be created and sent when the corresponding button is pressed."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct KeyboardButtonPollType {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "type", default)]
    tg_type: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to KeyboardButtonPollType that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipKeyboardButtonPollType {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."]
    tg_type: Option<String>,
}
impl From<NoSkipKeyboardButtonPollType> for KeyboardButtonPollType {
    fn from(t: NoSkipKeyboardButtonPollType) -> Self {
        Self { tg_type: t.tg_type }
    }
}
impl Into<NoSkipKeyboardButtonPollType> for KeyboardButtonPollType {
    fn into(self) -> NoSkipKeyboardButtonPollType {
        NoSkipKeyboardButtonPollType {
            tg_type: self.tg_type,
        }
    }
}
impl NoSkipKeyboardButtonPollType {
    pub fn skip(self) -> KeyboardButtonPollType {
        self.into()
    }
}
impl KeyboardButtonPollType {
    pub fn noskip(self) -> NoSkipKeyboardButtonPollType {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents type of a poll, which is allowed to be created and sent when the corresponding button is pressed."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct KeyboardButtonPollTypeBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "type", default)]
    tg_type: Option<String>,
}
impl KeyboardButtonPollTypeBuilder {
    pub fn new() -> Self {
        Self {
            tg_type: Some("KeyboardButtonPollType".to_owned()),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = Some(tg_type);
        self
    }
    pub fn build(self) -> KeyboardButtonPollType {
        KeyboardButtonPollType {
            tg_type: self.tg_type,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a join request sent to a chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatJoinRequest {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat to which the request was sent"]
    #[serde(rename = "chat")]
    chat: Chat,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that sent the join request"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    #[serde(rename = "user_chat_id")]
    user_chat_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the request was sent in Unix time"]
    #[serde(rename = "date")]
    date: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "bio", default)]
    bio: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "invite_link",
        default
    )]
    invite_link: Option<ChatInviteLink>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatJoinRequest that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatJoinRequest {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat to which the request was sent"]
    #[serde(rename = "chat")]
    chat: Chat,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that sent the join request"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    #[serde(rename = "user_chat_id")]
    user_chat_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the request was sent in Unix time"]
    #[serde(rename = "date")]
    date: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    bio: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    invite_link: Option<ChatInviteLink>,
}
impl From<NoSkipChatJoinRequest> for ChatJoinRequest {
    fn from(t: NoSkipChatJoinRequest) -> Self {
        Self {
            chat: t.chat,
            from: t.from,
            user_chat_id: t.user_chat_id,
            date: t.date,
            bio: t.bio,
            invite_link: t.invite_link,
        }
    }
}
impl Into<NoSkipChatJoinRequest> for ChatJoinRequest {
    fn into(self) -> NoSkipChatJoinRequest {
        NoSkipChatJoinRequest {
            chat: self.chat,
            from: self.from,
            user_chat_id: self.user_chat_id,
            date: self.date,
            bio: self.bio,
            invite_link: self.invite_link,
        }
    }
}
impl NoSkipChatJoinRequest {
    pub fn skip(self) -> ChatJoinRequest {
        self.into()
    }
}
impl ChatJoinRequest {
    pub fn noskip(self) -> NoSkipChatJoinRequest {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a join request sent to a chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatJoinRequestBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat to which the request was sent"]
    #[serde(rename = "chat")]
    chat: Chat,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that sent the join request"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    #[serde(rename = "user_chat_id")]
    user_chat_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the request was sent in Unix time"]
    #[serde(rename = "date")]
    date: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "bio", default)]
    bio: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "invite_link",
        default
    )]
    invite_link: Option<ChatInviteLink>,
}
impl ChatJoinRequestBuilder {
    pub fn new(chat: Chat, from: User, user_chat_id: i64, date: i64) -> Self {
        Self {
            chat,
            from,
            user_chat_id,
            date,
            bio: None,
            invite_link: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat to which the request was sent"]
    pub fn set_chat(mut self, chat: Chat) -> Self {
        self.chat = chat;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that sent the join request"]
    pub fn set_from(mut self, from: User) -> Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    pub fn set_user_chat_id(mut self, user_chat_id: i64) -> Self {
        self.user_chat_id = user_chat_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the request was sent in Unix time"]
    pub fn set_date(mut self, date: i64) -> Self {
        self.date = date;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    pub fn set_bio(mut self, bio: String) -> Self {
        self.bio = Some(bio);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    pub fn set_invite_link(mut self, invite_link: ChatInviteLink) -> Self {
        self.invite_link = Some(invite_link);
        self
    }
    pub fn build(self) -> ChatJoinRequest {
        ChatJoinRequest {
            chat: self.chat,
            from: self.from,
            user_chat_id: self.user_chat_id,
            date: self.date,
            bio: self.bio,
            invite_link: self.invite_link,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct FileBytes {
    pub(crate) name: String,
    #[serde(skip, default)]
    pub(crate) bytes: Option<Vec<u8>>,
}
pub enum FileData {
    Bytes(Vec<u8>),
    String(String),
    Part(Part),
}
#[derive(Clone, Serialize, Deserialize, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum InputFile {
    Bytes(FileBytes),
    String(String),
}
impl Default for InputFile {
    fn default() -> Self {
        InputFile::Bytes(FileBytes {
            name: "default".to_owned(),
            bytes: None,
        })
    }
}
impl FileData {
    pub fn to_form(self, data: Form, name: String) -> Result<(Form, String)> {
        match self {
            Self::Bytes(bytes) => {
                let attach = format!("attach://{}", name);
                let form = data.part(name, Part::bytes(bytes).file_name(""));
                Ok((form, attach))
            }
            Self::Part(part) => {
                let attach = format!("attach://{}", name);
                let form = data.part(name, part);
                Ok((form, attach))
            }
            Self::String(name) => Ok((data, name)),
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a file stored on the Telegram servers. By default, this file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the file.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    #[serde(rename = "document_file_id")]
    document_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultCachedDocument that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultCachedDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    #[serde(rename = "document_file_id")]
    document_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultCachedDocument> for InlineQueryResultCachedDocument {
    fn from(t: NoSkipInlineQueryResultCachedDocument) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            title: t.title,
            document_file_id: t.document_file_id,
            description: t.description,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultCachedDocument> for InlineQueryResultCachedDocument {
    fn into(self) -> NoSkipInlineQueryResultCachedDocument {
        NoSkipInlineQueryResultCachedDocument {
            tg_type: self.tg_type,
            id: self.id,
            title: self.title,
            document_file_id: self.document_file_id,
            description: self.description,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultCachedDocument {
    pub fn skip(self) -> InlineQueryResultCachedDocument {
        self.into()
    }
}
impl InlineQueryResultCachedDocument {
    pub fn noskip(self) -> NoSkipInlineQueryResultCachedDocument {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a file stored on the Telegram servers. By default, this file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the file.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedDocumentBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    #[serde(rename = "document_file_id")]
    document_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultCachedDocumentBuilder {
    pub fn new(id: String, title: String, document_file_id: String) -> Self {
        Self {
            tg_type: "document".to_owned(),
            id,
            title,
            document_file_id,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    pub fn set_document_file_id(mut self, document_file_id: String) -> Self {
        self.document_file_id = document_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultCachedDocument {
        InlineQueryResultCachedDocument {
            tg_type: self.tg_type,
            id: self.id,
            title: self.title,
            document_file_id: self.document_file_id,
            description: self.description,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the rights of an administrator in a chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatAdministratorRights {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    #[serde(rename = "can_manage_chat")]
    can_manage_chat: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    #[serde(rename = "can_delete_messages")]
    can_delete_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    #[serde(rename = "can_manage_video_chats")]
    can_manage_video_chats: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    #[serde(rename = "can_restrict_members")]
    can_restrict_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    #[serde(rename = "can_promote_members")]
    can_promote_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    #[serde(rename = "can_change_info")]
    can_change_info: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    #[serde(rename = "can_invite_users")]
    can_invite_users: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_post_messages",
        default
    )]
    can_post_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_edit_messages",
        default
    )]
    can_edit_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_pin_messages",
        default
    )]
    can_pin_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_post_stories",
        default
    )]
    can_post_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_edit_stories",
        default
    )]
    can_edit_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_delete_stories",
        default
    )]
    can_delete_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_manage_topics",
        default
    )]
    can_manage_topics: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatAdministratorRights that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatAdministratorRights {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    #[serde(rename = "can_manage_chat")]
    can_manage_chat: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    #[serde(rename = "can_delete_messages")]
    can_delete_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    #[serde(rename = "can_manage_video_chats")]
    can_manage_video_chats: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    #[serde(rename = "can_restrict_members")]
    can_restrict_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    #[serde(rename = "can_promote_members")]
    can_promote_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    #[serde(rename = "can_change_info")]
    can_change_info: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    #[serde(rename = "can_invite_users")]
    can_invite_users: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    can_post_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    can_edit_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    can_pin_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    can_post_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    can_edit_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    can_delete_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    can_manage_topics: Option<bool>,
}
impl From<NoSkipChatAdministratorRights> for ChatAdministratorRights {
    fn from(t: NoSkipChatAdministratorRights) -> Self {
        Self {
            is_anonymous: t.is_anonymous,
            can_manage_chat: t.can_manage_chat,
            can_delete_messages: t.can_delete_messages,
            can_manage_video_chats: t.can_manage_video_chats,
            can_restrict_members: t.can_restrict_members,
            can_promote_members: t.can_promote_members,
            can_change_info: t.can_change_info,
            can_invite_users: t.can_invite_users,
            can_post_messages: t.can_post_messages,
            can_edit_messages: t.can_edit_messages,
            can_pin_messages: t.can_pin_messages,
            can_post_stories: t.can_post_stories,
            can_edit_stories: t.can_edit_stories,
            can_delete_stories: t.can_delete_stories,
            can_manage_topics: t.can_manage_topics,
        }
    }
}
impl Into<NoSkipChatAdministratorRights> for ChatAdministratorRights {
    fn into(self) -> NoSkipChatAdministratorRights {
        NoSkipChatAdministratorRights {
            is_anonymous: self.is_anonymous,
            can_manage_chat: self.can_manage_chat,
            can_delete_messages: self.can_delete_messages,
            can_manage_video_chats: self.can_manage_video_chats,
            can_restrict_members: self.can_restrict_members,
            can_promote_members: self.can_promote_members,
            can_change_info: self.can_change_info,
            can_invite_users: self.can_invite_users,
            can_post_messages: self.can_post_messages,
            can_edit_messages: self.can_edit_messages,
            can_pin_messages: self.can_pin_messages,
            can_post_stories: self.can_post_stories,
            can_edit_stories: self.can_edit_stories,
            can_delete_stories: self.can_delete_stories,
            can_manage_topics: self.can_manage_topics,
        }
    }
}
impl NoSkipChatAdministratorRights {
    pub fn skip(self) -> ChatAdministratorRights {
        self.into()
    }
}
impl ChatAdministratorRights {
    pub fn noskip(self) -> NoSkipChatAdministratorRights {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the rights of an administrator in a chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatAdministratorRightsBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    #[serde(rename = "can_manage_chat")]
    can_manage_chat: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    #[serde(rename = "can_delete_messages")]
    can_delete_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    #[serde(rename = "can_manage_video_chats")]
    can_manage_video_chats: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    #[serde(rename = "can_restrict_members")]
    can_restrict_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    #[serde(rename = "can_promote_members")]
    can_promote_members: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    #[serde(rename = "can_change_info")]
    can_change_info: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    #[serde(rename = "can_invite_users")]
    can_invite_users: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_post_messages",
        default
    )]
    can_post_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_edit_messages",
        default
    )]
    can_edit_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_pin_messages",
        default
    )]
    can_pin_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_post_stories",
        default
    )]
    can_post_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_edit_stories",
        default
    )]
    can_edit_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_delete_stories",
        default
    )]
    can_delete_stories: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_manage_topics",
        default
    )]
    can_manage_topics: Option<bool>,
}
impl ChatAdministratorRightsBuilder {
    pub fn new(
        is_anonymous: bool,
        can_manage_chat: bool,
        can_delete_messages: bool,
        can_manage_video_chats: bool,
        can_restrict_members: bool,
        can_promote_members: bool,
        can_change_info: bool,
        can_invite_users: bool,
    ) -> Self {
        Self {
            is_anonymous,
            can_manage_chat,
            can_delete_messages,
            can_manage_video_chats,
            can_restrict_members,
            can_promote_members,
            can_change_info,
            can_invite_users,
            can_post_messages: None,
            can_edit_messages: None,
            can_pin_messages: None,
            can_post_stories: None,
            can_edit_stories: None,
            can_delete_stories: None,
            can_manage_topics: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn set_is_anonymous(mut self, is_anonymous: bool) -> Self {
        self.is_anonymous = is_anonymous;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    pub fn set_can_manage_chat(mut self, can_manage_chat: bool) -> Self {
        self.can_manage_chat = can_manage_chat;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    pub fn set_can_delete_messages(mut self, can_delete_messages: bool) -> Self {
        self.can_delete_messages = can_delete_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    pub fn set_can_manage_video_chats(mut self, can_manage_video_chats: bool) -> Self {
        self.can_manage_video_chats = can_manage_video_chats;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    pub fn set_can_restrict_members(mut self, can_restrict_members: bool) -> Self {
        self.can_restrict_members = can_restrict_members;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    pub fn set_can_promote_members(mut self, can_promote_members: bool) -> Self {
        self.can_promote_members = can_promote_members;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn set_can_change_info(mut self, can_change_info: bool) -> Self {
        self.can_change_info = can_change_info;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn set_can_invite_users(mut self, can_invite_users: bool) -> Self {
        self.can_invite_users = can_invite_users;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    pub fn set_can_post_messages(mut self, can_post_messages: bool) -> Self {
        self.can_post_messages = Some(can_post_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    pub fn set_can_edit_messages(mut self, can_edit_messages: bool) -> Self {
        self.can_edit_messages = Some(can_edit_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    pub fn set_can_pin_messages(mut self, can_pin_messages: bool) -> Self {
        self.can_pin_messages = Some(can_pin_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    pub fn set_can_post_stories(mut self, can_post_stories: bool) -> Self {
        self.can_post_stories = Some(can_post_stories);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    pub fn set_can_edit_stories(mut self, can_edit_stories: bool) -> Self {
        self.can_edit_stories = Some(can_edit_stories);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    pub fn set_can_delete_stories(mut self, can_delete_stories: bool) -> Self {
        self.can_delete_stories = Some(can_delete_stories);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    pub fn set_can_manage_topics(mut self, can_manage_topics: bool) -> Self {
        self.can_manage_topics = Some(can_manage_topics);
        self
    }
    pub fn build(self) -> ChatAdministratorRights {
        ChatAdministratorRights {
            is_anonymous: self.is_anonymous,
            can_manage_chat: self.can_manage_chat,
            can_delete_messages: self.can_delete_messages,
            can_manage_video_chats: self.can_manage_video_chats,
            can_restrict_members: self.can_restrict_members,
            can_promote_members: self.can_promote_members,
            can_change_info: self.can_change_info,
            can_invite_users: self.can_invite_users,
            can_post_messages: self.can_post_messages,
            can_edit_messages: self.can_edit_messages,
            can_pin_messages: self.can_pin_messages,
            can_post_stories: self.can_post_stories,
            can_edit_stories: self.can_edit_stories,
            can_delete_stories: self.can_delete_stories,
            can_manage_topics: self.can_manage_topics,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum VideoChatStarted {}
impl VideoChatStarted {}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes the current status of a webhook."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WebhookInfo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Webhook URL, may be empty if webhook is not set up"]
    #[serde(rename = "url")]
    url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if a custom certificate was provided for webhook certificate checks"]
    #[serde(rename = "has_custom_certificate")]
    has_custom_certificate: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of updates awaiting delivery"]
    #[serde(rename = "pending_update_count")]
    pending_update_count: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Currently used webhook IP address"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "ip_address",
        default
    )]
    ip_address: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "last_error_date",
        default
    )]
    last_error_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "last_error_message",
        default
    )]
    last_error_message: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "last_synchronization_error_date",
        default
    )]
    last_synchronization_error_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "max_connections",
        default
    )]
    max_connections: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "allowed_updates",
        default
    )]
    allowed_updates: Option<Vec<String>>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to WebhookInfo that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipWebhookInfo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Webhook URL, may be empty if webhook is not set up"]
    #[serde(rename = "url")]
    url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if a custom certificate was provided for webhook certificate checks"]
    #[serde(rename = "has_custom_certificate")]
    has_custom_certificate: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of updates awaiting delivery"]
    #[serde(rename = "pending_update_count")]
    pending_update_count: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Currently used webhook IP address"]
    ip_address: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"]
    last_error_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"]
    last_error_message: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"]
    last_synchronization_error_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"]
    max_connections: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"]
    allowed_updates: Option<Vec<String>>,
}
impl From<NoSkipWebhookInfo> for WebhookInfo {
    fn from(t: NoSkipWebhookInfo) -> Self {
        Self {
            url: t.url,
            has_custom_certificate: t.has_custom_certificate,
            pending_update_count: t.pending_update_count,
            ip_address: t.ip_address,
            last_error_date: t.last_error_date,
            last_error_message: t.last_error_message,
            last_synchronization_error_date: t.last_synchronization_error_date,
            max_connections: t.max_connections,
            allowed_updates: t.allowed_updates,
        }
    }
}
impl Into<NoSkipWebhookInfo> for WebhookInfo {
    fn into(self) -> NoSkipWebhookInfo {
        NoSkipWebhookInfo {
            url: self.url,
            has_custom_certificate: self.has_custom_certificate,
            pending_update_count: self.pending_update_count,
            ip_address: self.ip_address,
            last_error_date: self.last_error_date,
            last_error_message: self.last_error_message,
            last_synchronization_error_date: self.last_synchronization_error_date,
            max_connections: self.max_connections,
            allowed_updates: self.allowed_updates,
        }
    }
}
impl NoSkipWebhookInfo {
    pub fn skip(self) -> WebhookInfo {
        self.into()
    }
}
impl WebhookInfo {
    pub fn noskip(self) -> NoSkipWebhookInfo {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes the current status of a webhook."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WebhookInfoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Webhook URL, may be empty if webhook is not set up"]
    #[serde(rename = "url")]
    url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if a custom certificate was provided for webhook certificate checks"]
    #[serde(rename = "has_custom_certificate")]
    has_custom_certificate: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of updates awaiting delivery"]
    #[serde(rename = "pending_update_count")]
    pending_update_count: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Currently used webhook IP address"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "ip_address",
        default
    )]
    ip_address: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "last_error_date",
        default
    )]
    last_error_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "last_error_message",
        default
    )]
    last_error_message: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "last_synchronization_error_date",
        default
    )]
    last_synchronization_error_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "max_connections",
        default
    )]
    max_connections: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "allowed_updates",
        default
    )]
    allowed_updates: Option<Vec<String>>,
}
impl WebhookInfoBuilder {
    pub fn new(url: String, has_custom_certificate: bool, pending_update_count: i64) -> Self {
        Self {
            url,
            has_custom_certificate,
            pending_update_count,
            ip_address: None,
            last_error_date: None,
            last_error_message: None,
            last_synchronization_error_date: None,
            max_connections: None,
            allowed_updates: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Webhook URL, may be empty if webhook is not set up"]
    pub fn set_url(mut self, url: String) -> Self {
        self.url = url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if a custom certificate was provided for webhook certificate checks"]
    pub fn set_has_custom_certificate(mut self, has_custom_certificate: bool) -> Self {
        self.has_custom_certificate = has_custom_certificate;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of updates awaiting delivery"]
    pub fn set_pending_update_count(mut self, pending_update_count: i64) -> Self {
        self.pending_update_count = pending_update_count;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Currently used webhook IP address"]
    pub fn set_ip_address(mut self, ip_address: String) -> Self {
        self.ip_address = Some(ip_address);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"]
    pub fn set_last_error_date(mut self, last_error_date: i64) -> Self {
        self.last_error_date = Some(last_error_date);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"]
    pub fn set_last_error_message(mut self, last_error_message: String) -> Self {
        self.last_error_message = Some(last_error_message);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"]
    pub fn set_last_synchronization_error_date(
        mut self,
        last_synchronization_error_date: i64,
    ) -> Self {
        self.last_synchronization_error_date = Some(last_synchronization_error_date);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"]
    pub fn set_max_connections(mut self, max_connections: i64) -> Self {
        self.max_connections = Some(max_connections);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"]
    pub fn set_allowed_updates(mut self, allowed_updates: Vec<String>) -> Self {
        self.allowed_updates = Some(allowed_updates);
        self
    }
    pub fn build(self) -> WebhookInfo {
        WebhookInfo {
            url: self.url,
            has_custom_certificate: self.has_custom_certificate,
            pending_update_count: self.pending_update_count,
            ip_address: self.ip_address,
            last_error_date: self.last_error_date,
            last_error_message: self.last_error_message,
            last_synchronization_error_date: self.last_synchronization_error_date,
            max_connections: self.max_connections,
            allowed_updates: self.allowed_updates,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes data sent from a Web App to the bot."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WebAppData {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The data. Be aware that a bad client can send arbitrary data in this field."]
    #[serde(rename = "data")]
    data: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."]
    #[serde(rename = "button_text")]
    button_text: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to WebAppData that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipWebAppData {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The data. Be aware that a bad client can send arbitrary data in this field."]
    #[serde(rename = "data")]
    data: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."]
    #[serde(rename = "button_text")]
    button_text: String,
}
impl From<NoSkipWebAppData> for WebAppData {
    fn from(t: NoSkipWebAppData) -> Self {
        Self {
            data: t.data,
            button_text: t.button_text,
        }
    }
}
impl Into<NoSkipWebAppData> for WebAppData {
    fn into(self) -> NoSkipWebAppData {
        NoSkipWebAppData {
            data: self.data,
            button_text: self.button_text,
        }
    }
}
impl NoSkipWebAppData {
    pub fn skip(self) -> WebAppData {
        self.into()
    }
}
impl WebAppData {
    pub fn noskip(self) -> NoSkipWebAppData {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes data sent from a Web App to the bot."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WebAppDataBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The data. Be aware that a bad client can send arbitrary data in this field."]
    #[serde(rename = "data")]
    data: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."]
    #[serde(rename = "button_text")]
    button_text: String,
}
impl WebAppDataBuilder {
    pub fn new(data: String, button_text: String) -> Self {
        Self { data, button_text }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The data. Be aware that a bad client can send arbitrary data in this field."]
    pub fn set_data(mut self, data: String) -> Self {
        self.data = data;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."]
    pub fn set_button_text(mut self, button_text: String) -> Self {
        self.button_text = button_text;
        self
    }
    pub fn build(self) -> WebAppData {
        WebAppData {
            data: self.data,
            button_text: self.button_text,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an incoming inline query. When the user sends an empty query, your bot could return some default or trending results."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the query (up to 256 characters)"]
    #[serde(rename = "query")]
    query: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    #[serde(rename = "offset")]
    offset: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "chat_type", default)]
    chat_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that request user location"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "location", default)]
    location: Option<Location>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQuery that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQuery {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the query (up to 256 characters)"]
    #[serde(rename = "query")]
    query: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    #[serde(rename = "offset")]
    offset: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    chat_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that request user location"]
    location: Option<Location>,
}
impl From<NoSkipInlineQuery> for InlineQuery {
    fn from(t: NoSkipInlineQuery) -> Self {
        Self {
            id: t.id,
            from: t.from,
            query: t.query,
            offset: t.offset,
            chat_type: t.chat_type,
            location: t.location,
        }
    }
}
impl Into<NoSkipInlineQuery> for InlineQuery {
    fn into(self) -> NoSkipInlineQuery {
        NoSkipInlineQuery {
            id: self.id,
            from: self.from,
            query: self.query,
            offset: self.offset,
            chat_type: self.chat_type,
            location: self.location,
        }
    }
}
impl NoSkipInlineQuery {
    pub fn skip(self) -> InlineQuery {
        self.into()
    }
}
impl InlineQuery {
    pub fn noskip(self) -> NoSkipInlineQuery {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an incoming inline query. When the user sends an empty query, your bot could return some default or trending results."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    #[serde(rename = "from")]
    from: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the query (up to 256 characters)"]
    #[serde(rename = "query")]
    query: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    #[serde(rename = "offset")]
    offset: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "chat_type", default)]
    chat_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that request user location"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "location", default)]
    location: Option<Location>,
}
impl InlineQueryBuilder {
    pub fn new(id: String, from: User, query: String, offset: String) -> Self {
        Self {
            id,
            from,
            query,
            offset,
            chat_type: None,
            location: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    pub fn set_from(mut self, from: User) -> Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the query (up to 256 characters)"]
    pub fn set_query(mut self, query: String) -> Self {
        self.query = query;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    pub fn set_offset(mut self, offset: String) -> Self {
        self.offset = offset;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    pub fn set_chat_type(mut self, chat_type: String) -> Self {
        self.chat_type = Some(chat_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that request user location"]
    pub fn set_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }
    pub fn build(self) -> InlineQuery {
        InlineQuery {
            id: self.id,
            from: self.from,
            query: self.query,
            offset: self.offset,
            chat_type: self.chat_type,
            location: self.location,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format when decrypted and don't exceed 10MB."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File size in bytes"]
    #[serde(rename = "file_size")]
    file_size: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unix time when the file was uploaded"]
    #[serde(rename = "file_date")]
    file_date: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportFile that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File size in bytes"]
    #[serde(rename = "file_size")]
    file_size: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unix time when the file was uploaded"]
    #[serde(rename = "file_date")]
    file_date: i64,
}
impl From<NoSkipPassportFile> for PassportFile {
    fn from(t: NoSkipPassportFile) -> Self {
        Self {
            file_id: t.file_id,
            file_unique_id: t.file_unique_id,
            file_size: t.file_size,
            file_date: t.file_date,
        }
    }
}
impl Into<NoSkipPassportFile> for PassportFile {
    fn into(self) -> NoSkipPassportFile {
        NoSkipPassportFile {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            file_size: self.file_size,
            file_date: self.file_date,
        }
    }
}
impl NoSkipPassportFile {
    pub fn skip(self) -> PassportFile {
        self.into()
    }
}
impl PassportFile {
    pub fn noskip(self) -> NoSkipPassportFile {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format when decrypted and don't exceed 10MB."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportFileBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File size in bytes"]
    #[serde(rename = "file_size")]
    file_size: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unix time when the file was uploaded"]
    #[serde(rename = "file_date")]
    file_date: i64,
}
impl PassportFileBuilder {
    pub fn new(file_id: String, file_unique_id: String, file_size: i64, file_date: i64) -> Self {
        Self {
            file_id,
            file_unique_id,
            file_size,
            file_date,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id(mut self, file_id: String) -> Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id(mut self, file_unique_id: String) -> Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File size in bytes"]
    pub fn set_file_size(mut self, file_size: i64) -> Self {
        self.file_size = file_size;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unix time when the file was uploaded"]
    pub fn set_file_date(mut self, file_date: i64) -> Self {
        self.file_date = file_date;
        self
    }
    pub fn build(self) -> PassportFile {
        PassportFile {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            file_size: self.file_size,
            file_date: self.file_date,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a sticker stored on the Telegram servers. By default, this sticker will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the sticker.Note: This will only work in Telegram versions released after 9 April, 2016 for static stickers and after 06 July, 2019 for animated stickers. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedSticker {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    #[serde(rename = "sticker_file_id")]
    sticker_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultCachedSticker that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultCachedSticker {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    #[serde(rename = "sticker_file_id")]
    sticker_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultCachedSticker> for InlineQueryResultCachedSticker {
    fn from(t: NoSkipInlineQueryResultCachedSticker) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            sticker_file_id: t.sticker_file_id,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultCachedSticker> for InlineQueryResultCachedSticker {
    fn into(self) -> NoSkipInlineQueryResultCachedSticker {
        NoSkipInlineQueryResultCachedSticker {
            tg_type: self.tg_type,
            id: self.id,
            sticker_file_id: self.sticker_file_id,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultCachedSticker {
    pub fn skip(self) -> InlineQueryResultCachedSticker {
        self.into()
    }
}
impl InlineQueryResultCachedSticker {
    pub fn noskip(self) -> NoSkipInlineQueryResultCachedSticker {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a sticker stored on the Telegram servers. By default, this sticker will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the sticker.Note: This will only work in Telegram versions released after 9 April, 2016 for static stickers and after 06 July, 2019 for animated stickers. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedStickerBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    #[serde(rename = "sticker_file_id")]
    sticker_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultCachedStickerBuilder {
    pub fn new(id: String, sticker_file_id: String) -> Self {
        Self {
            tg_type: "sticker".to_owned(),
            id,
            sticker_file_id,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    pub fn set_sticker_file_id(mut self, sticker_file_id: String) -> Self {
        self.sticker_file_id = sticker_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultCachedSticker {
        InlineQueryResultCachedSticker {
            tg_type: self.tg_type,
            id: self.id,
            sticker_file_id: self.sticker_file_id,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound)."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Animation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation thumbnail as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original animation filename as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_name", default)]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "mime_type", default)]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Animation that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipAnimation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation thumbnail as defined by sender"]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original animation filename as defined by sender"]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    file_size: Option<i64>,
}
impl From<NoSkipAnimation> for Animation {
    fn from(t: NoSkipAnimation) -> Self {
        Self {
            file_id: t.file_id,
            file_unique_id: t.file_unique_id,
            width: t.width,
            height: t.height,
            duration: t.duration,
            thumbnail: t.thumbnail,
            file_name: t.file_name,
            mime_type: t.mime_type,
            file_size: t.file_size,
        }
    }
}
impl Into<NoSkipAnimation> for Animation {
    fn into(self) -> NoSkipAnimation {
        NoSkipAnimation {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            width: self.width,
            height: self.height,
            duration: self.duration,
            thumbnail: self.thumbnail,
            file_name: self.file_name,
            mime_type: self.mime_type,
            file_size: self.file_size,
        }
    }
}
impl NoSkipAnimation {
    pub fn skip(self) -> Animation {
        self.into()
    }
}
impl Animation {
    pub fn noskip(self) -> NoSkipAnimation {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound)."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct AnimationBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation thumbnail as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original animation filename as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_name", default)]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "mime_type", default)]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
impl AnimationBuilder {
    pub fn new(
        file_id: String,
        file_unique_id: String,
        width: i64,
        height: i64,
        duration: i64,
    ) -> Self {
        Self {
            file_id,
            file_unique_id,
            width,
            height,
            duration,
            thumbnail: None,
            file_name: None,
            mime_type: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id(mut self, file_id: String) -> Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id(mut self, file_unique_id: String) -> Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    pub fn set_width(mut self, width: i64) -> Self {
        self.width = width;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    pub fn set_height(mut self, height: i64) -> Self {
        self.height = height;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn set_duration(mut self, duration: i64) -> Self {
        self.duration = duration;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation thumbnail as defined by sender"]
    pub fn set_thumbnail(mut self, thumbnail: PhotoSize) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original animation filename as defined by sender"]
    pub fn set_file_name(mut self, file_name: String) -> Self {
        self.file_name = Some(file_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn set_mime_type(mut self, mime_type: String) -> Self {
        self.mime_type = Some(mime_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size(mut self, file_size: i64) -> Self {
        self.file_size = Some(file_size);
        self
    }
    pub fn build(self) -> Animation {
        Animation {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            width: self.width,
            height: self.height,
            duration: self.duration,
            thumbnail: self.thumbnail,
            file_name: self.file_name,
            mime_type: self.mime_type,
            file_size: self.file_size,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a chat photo."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    #[serde(rename = "small_file_id")]
    small_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "small_file_unique_id")]
    small_file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    #[serde(rename = "big_file_id")]
    big_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "big_file_unique_id")]
    big_file_unique_id: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatPhoto that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    #[serde(rename = "small_file_id")]
    small_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "small_file_unique_id")]
    small_file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    #[serde(rename = "big_file_id")]
    big_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "big_file_unique_id")]
    big_file_unique_id: String,
}
impl From<NoSkipChatPhoto> for ChatPhoto {
    fn from(t: NoSkipChatPhoto) -> Self {
        Self {
            small_file_id: t.small_file_id,
            small_file_unique_id: t.small_file_unique_id,
            big_file_id: t.big_file_id,
            big_file_unique_id: t.big_file_unique_id,
        }
    }
}
impl Into<NoSkipChatPhoto> for ChatPhoto {
    fn into(self) -> NoSkipChatPhoto {
        NoSkipChatPhoto {
            small_file_id: self.small_file_id,
            small_file_unique_id: self.small_file_unique_id,
            big_file_id: self.big_file_id,
            big_file_unique_id: self.big_file_unique_id,
        }
    }
}
impl NoSkipChatPhoto {
    pub fn skip(self) -> ChatPhoto {
        self.into()
    }
}
impl ChatPhoto {
    pub fn noskip(self) -> NoSkipChatPhoto {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a chat photo."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatPhotoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    #[serde(rename = "small_file_id")]
    small_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "small_file_unique_id")]
    small_file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    #[serde(rename = "big_file_id")]
    big_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "big_file_unique_id")]
    big_file_unique_id: String,
}
impl ChatPhotoBuilder {
    pub fn new(
        small_file_id: String,
        small_file_unique_id: String,
        big_file_id: String,
        big_file_unique_id: String,
    ) -> Self {
        Self {
            small_file_id,
            small_file_unique_id,
            big_file_id,
            big_file_unique_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    pub fn set_small_file_id(mut self, small_file_id: String) -> Self {
        self.small_file_id = small_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_small_file_unique_id(mut self, small_file_unique_id: String) -> Self {
        self.small_file_unique_id = small_file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    pub fn set_big_file_id(mut self, big_file_id: String) -> Self {
        self.big_file_id = big_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_big_file_unique_id(mut self, big_file_unique_id: String) -> Self {
        self.big_file_unique_id = big_file_unique_id;
        self
    }
    pub fn build(self) -> ChatPhoto {
        ChatPhoto {
            small_file_id: self.small_file_id,
            small_file_unique_id: self.small_file_unique_id,
            big_file_id: self.big_file_id,
            big_file_unique_id: self.big_file_unique_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a sticker set."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct StickerSet {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set name"]
    #[serde(rename = "name")]
    name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of stickers in the set, currently one of \"regular\", \"mask\", \"custom_emoji\""]
    #[serde(rename = "sticker_type")]
    sticker_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains animated stickers"]
    #[serde(rename = "is_animated")]
    is_animated: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains video stickers"]
    #[serde(rename = "is_video")]
    is_video: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of all set stickers"]
    #[serde(rename = "stickers")]
    stickers: Vec<Sticker>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to StickerSet that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipStickerSet {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set name"]
    #[serde(rename = "name")]
    name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of stickers in the set, currently one of \"regular\", \"mask\", \"custom_emoji\""]
    #[serde(rename = "sticker_type")]
    sticker_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains animated stickers"]
    #[serde(rename = "is_animated")]
    is_animated: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains video stickers"]
    #[serde(rename = "is_video")]
    is_video: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of all set stickers"]
    #[serde(rename = "stickers")]
    stickers: Vec<Sticker>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"]
    thumbnail: Option<PhotoSize>,
}
impl From<NoSkipStickerSet> for StickerSet {
    fn from(t: NoSkipStickerSet) -> Self {
        Self {
            name: t.name,
            title: t.title,
            sticker_type: t.sticker_type,
            is_animated: t.is_animated,
            is_video: t.is_video,
            stickers: t.stickers,
            thumbnail: t.thumbnail,
        }
    }
}
impl Into<NoSkipStickerSet> for StickerSet {
    fn into(self) -> NoSkipStickerSet {
        NoSkipStickerSet {
            name: self.name,
            title: self.title,
            sticker_type: self.sticker_type,
            is_animated: self.is_animated,
            is_video: self.is_video,
            stickers: self.stickers,
            thumbnail: self.thumbnail,
        }
    }
}
impl NoSkipStickerSet {
    pub fn skip(self) -> StickerSet {
        self.into()
    }
}
impl StickerSet {
    pub fn noskip(self) -> NoSkipStickerSet {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a sticker set."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct StickerSetBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set name"]
    #[serde(rename = "name")]
    name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of stickers in the set, currently one of \"regular\", \"mask\", \"custom_emoji\""]
    #[serde(rename = "sticker_type")]
    sticker_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains animated stickers"]
    #[serde(rename = "is_animated")]
    is_animated: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains video stickers"]
    #[serde(rename = "is_video")]
    is_video: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of all set stickers"]
    #[serde(rename = "stickers")]
    stickers: Vec<Sticker>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
}
impl StickerSetBuilder {
    pub fn new(
        name: String,
        title: String,
        sticker_type: String,
        is_animated: bool,
        is_video: bool,
        stickers: Vec<Sticker>,
    ) -> Self {
        Self {
            name,
            title,
            sticker_type,
            is_animated,
            is_video,
            stickers,
            thumbnail: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set name"]
    pub fn set_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set title"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of stickers in the set, currently one of \"regular\", \"mask\", \"custom_emoji\""]
    pub fn set_sticker_type(mut self, sticker_type: String) -> Self {
        self.sticker_type = sticker_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains animated stickers"]
    pub fn set_is_animated(mut self, is_animated: bool) -> Self {
        self.is_animated = is_animated;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains video stickers"]
    pub fn set_is_video(mut self, is_video: bool) -> Self {
        self.is_video = is_video;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of all set stickers"]
    pub fn set_stickers(mut self, stickers: Vec<Sticker>) -> Self {
        self.stickers = stickers;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"]
    pub fn set_thumbnail(mut self, thumbnail: PhotoSize) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    pub fn build(self) -> StickerSet {
        StickerSet {
            name: self.name,
            title: self.title,
            sticker_type: self.sticker_type,
            is_animated: self.is_animated,
            is_video: self.is_video,
            stickers: self.stickers,
            thumbnail: self.thumbnail,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the content of a venue message to be sent as the result of an inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputVenueMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    #[serde(rename = "address")]
    address: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_id",
        default
    )]
    foursquare_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_type",
        default
    )]
    foursquare_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_id",
        default
    )]
    google_place_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_type",
        default
    )]
    google_place_type: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputVenueMessageContent that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputVenueMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    #[serde(rename = "address")]
    address: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    foursquare_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    foursquare_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    google_place_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    google_place_type: Option<String>,
}
impl From<NoSkipInputVenueMessageContent> for InputVenueMessageContent {
    fn from(t: NoSkipInputVenueMessageContent) -> Self {
        Self {
            latitude: t.latitude,
            longitude: t.longitude,
            title: t.title,
            address: t.address,
            foursquare_id: t.foursquare_id,
            foursquare_type: t.foursquare_type,
            google_place_id: t.google_place_id,
            google_place_type: t.google_place_type,
        }
    }
}
impl Into<NoSkipInputVenueMessageContent> for InputVenueMessageContent {
    fn into(self) -> NoSkipInputVenueMessageContent {
        NoSkipInputVenueMessageContent {
            latitude: self.latitude,
            longitude: self.longitude,
            title: self.title,
            address: self.address,
            foursquare_id: self.foursquare_id,
            foursquare_type: self.foursquare_type,
            google_place_id: self.google_place_id,
            google_place_type: self.google_place_type,
        }
    }
}
impl NoSkipInputVenueMessageContent {
    pub fn skip(self) -> InputVenueMessageContent {
        self.into()
    }
}
impl InputVenueMessageContent {
    pub fn noskip(self) -> NoSkipInputVenueMessageContent {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the content of a venue message to be sent as the result of an inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputVenueMessageContentBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    #[serde(rename = "address")]
    address: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_id",
        default
    )]
    foursquare_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "foursquare_type",
        default
    )]
    foursquare_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_id",
        default
    )]
    google_place_id: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "google_place_type",
        default
    )]
    google_place_type: Option<String>,
}
impl InputVenueMessageContentBuilder {
    pub fn new(
        latitude: ::ordered_float::OrderedFloat<f64>,
        longitude: ::ordered_float::OrderedFloat<f64>,
        title: String,
        address: String,
    ) -> Self {
        Self {
            latitude,
            longitude,
            title,
            address,
            foursquare_id: None,
            foursquare_type: None,
            google_place_id: None,
            google_place_type: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    pub fn set_latitude(mut self, latitude: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    pub fn set_longitude(mut self, longitude: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn set_address(mut self, address: String) -> Self {
        self.address = address;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    pub fn set_foursquare_id(mut self, foursquare_id: String) -> Self {
        self.foursquare_id = Some(foursquare_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn set_foursquare_type(mut self, foursquare_type: String) -> Self {
        self.foursquare_type = Some(foursquare_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn set_google_place_id(mut self, google_place_id: String) -> Self {
        self.google_place_id = Some(google_place_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn set_google_place_type(mut self, google_place_type: String) -> Self {
        self.google_place_type = Some(google_place_type);
        self
    }
    pub fn build(self) -> InputVenueMessageContent {
        InputVenueMessageContent {
            latitude: self.latitude,
            longitude: self.longitude,
            title: self.title,
            address: self.address,
            foursquare_id: self.foursquare_id,
            foursquare_type: self.foursquare_type,
            google_place_id: self.google_place_id,
            google_place_type: self.google_place_type,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with a list of scans. The error is considered resolved when the list of files containing the scans changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorFiles {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    #[serde(rename = "file_hashes")]
    file_hashes: Vec<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportElementErrorFiles that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportElementErrorFiles {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    #[serde(rename = "file_hashes")]
    file_hashes: Vec<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl From<NoSkipPassportElementErrorFiles> for PassportElementErrorFiles {
    fn from(t: NoSkipPassportElementErrorFiles) -> Self {
        Self {
            source: t.source,
            tg_type: t.tg_type,
            file_hashes: t.file_hashes,
            message: t.message,
        }
    }
}
impl Into<NoSkipPassportElementErrorFiles> for PassportElementErrorFiles {
    fn into(self) -> NoSkipPassportElementErrorFiles {
        NoSkipPassportElementErrorFiles {
            source: self.source,
            tg_type: self.tg_type,
            file_hashes: self.file_hashes,
            message: self.message,
        }
    }
}
impl NoSkipPassportElementErrorFiles {
    pub fn skip(self) -> PassportElementErrorFiles {
        self.into()
    }
}
impl PassportElementErrorFiles {
    pub fn noskip(self) -> NoSkipPassportElementErrorFiles {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with a list of scans. The error is considered resolved when the list of files containing the scans changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorFilesBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    #[serde(rename = "file_hashes")]
    file_hashes: Vec<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl PassportElementErrorFilesBuilder {
    pub fn new(source: String, file_hashes: Vec<String>, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorFiles".to_owned(),
            source,
            file_hashes,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    pub fn set_source(mut self, source: String) -> Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    pub fn set_file_hashes(mut self, file_hashes: Vec<String>) -> Self {
        self.file_hashes = file_hashes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message(mut self, message: String) -> Self {
        self.message = message;
        self
    }
    pub fn build(self) -> PassportElementErrorFiles {
        PassportElementErrorFiles {
            source: self.source,
            tg_type: self.tg_type,
            file_hashes: self.file_hashes,
            message: self.message,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering all administrators of a specific group or supergroup chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeChatAdministrators {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    #[serde(rename = "chat_id")]
    chat_id: ::ordered_float::OrderedFloat<f64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotCommandScopeChatAdministrators that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotCommandScopeChatAdministrators {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    #[serde(rename = "chat_id")]
    chat_id: ::ordered_float::OrderedFloat<f64>,
}
impl From<NoSkipBotCommandScopeChatAdministrators> for BotCommandScopeChatAdministrators {
    fn from(t: NoSkipBotCommandScopeChatAdministrators) -> Self {
        Self {
            tg_type: t.tg_type,
            chat_id: t.chat_id,
        }
    }
}
impl Into<NoSkipBotCommandScopeChatAdministrators> for BotCommandScopeChatAdministrators {
    fn into(self) -> NoSkipBotCommandScopeChatAdministrators {
        NoSkipBotCommandScopeChatAdministrators {
            tg_type: self.tg_type,
            chat_id: self.chat_id,
        }
    }
}
impl NoSkipBotCommandScopeChatAdministrators {
    pub fn skip(self) -> BotCommandScopeChatAdministrators {
        self.into()
    }
}
impl BotCommandScopeChatAdministrators {
    pub fn noskip(self) -> NoSkipBotCommandScopeChatAdministrators {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering all administrators of a specific group or supergroup chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeChatAdministratorsBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    #[serde(rename = "chat_id")]
    chat_id: ::ordered_float::OrderedFloat<f64>,
}
impl BotCommandScopeChatAdministratorsBuilder {
    pub fn new(chat_id: ::ordered_float::OrderedFloat<f64>) -> Self {
        Self {
            tg_type: "chat_administrators".to_owned(),
            chat_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn set_chat_id(mut self, chat_id: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.chat_id = chat_id;
        self
    }
    pub fn build(self) -> BotCommandScopeChatAdministrators {
        BotCommandScopeChatAdministrators {
            tg_type: self.tg_type,
            chat_id: self.chat_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a photo stored on the Telegram servers. By default, this photo will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the photo."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    #[serde(rename = "photo_file_id")]
    photo_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultCachedPhoto that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultCachedPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    #[serde(rename = "photo_file_id")]
    photo_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultCachedPhoto> for InlineQueryResultCachedPhoto {
    fn from(t: NoSkipInlineQueryResultCachedPhoto) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            photo_file_id: t.photo_file_id,
            title: t.title,
            description: t.description,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultCachedPhoto> for InlineQueryResultCachedPhoto {
    fn into(self) -> NoSkipInlineQueryResultCachedPhoto {
        NoSkipInlineQueryResultCachedPhoto {
            tg_type: self.tg_type,
            id: self.id,
            photo_file_id: self.photo_file_id,
            title: self.title,
            description: self.description,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultCachedPhoto {
    pub fn skip(self) -> InlineQueryResultCachedPhoto {
        self.into()
    }
}
impl InlineQueryResultCachedPhoto {
    pub fn noskip(self) -> NoSkipInlineQueryResultCachedPhoto {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a photo stored on the Telegram servers. By default, this photo will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the photo."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedPhotoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    #[serde(rename = "photo_file_id")]
    photo_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultCachedPhotoBuilder {
    pub fn new(id: String, photo_file_id: String) -> Self {
        Self {
            tg_type: "photo".to_owned(),
            id,
            photo_file_id,
            title: None,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    pub fn set_photo_file_id(mut self, photo_file_id: String) -> Self {
        self.photo_file_id = photo_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultCachedPhoto {
        InlineQueryResultCachedPhoto {
            tg_type: self.tg_type,
            id: self.id,
            photo_file_id: self.photo_file_id,
            title: self.title,
            description: self.description,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the content of an invoice message to be sent as the result of an inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputInvoiceMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    #[serde(rename = "description")]
    description: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    #[serde(rename = "payload")]
    payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    #[serde(rename = "provider_token")]
    provider_token: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    #[serde(rename = "prices")]
    prices: Vec<LabeledPrice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "max_tip_amount",
        default
    )]
    max_tip_amount: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "suggested_tip_amounts",
        default
    )]
    suggested_tip_amounts: Option<Vec<i64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "provider_data",
        default
    )]
    provider_data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "photo_url", default)]
    photo_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "photo_size",
        default
    )]
    photo_size: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "photo_width",
        default
    )]
    photo_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "photo_height",
        default
    )]
    photo_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "need_name", default)]
    need_name: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "need_phone_number",
        default
    )]
    need_phone_number: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "need_email",
        default
    )]
    need_email: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "need_shipping_address",
        default
    )]
    need_shipping_address: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "send_phone_number_to_provider",
        default
    )]
    send_phone_number_to_provider: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "send_email_to_provider",
        default
    )]
    send_email_to_provider: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "is_flexible",
        default
    )]
    is_flexible: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputInvoiceMessageContent that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputInvoiceMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    #[serde(rename = "description")]
    description: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    #[serde(rename = "payload")]
    payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    #[serde(rename = "provider_token")]
    provider_token: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    #[serde(rename = "prices")]
    prices: Vec<LabeledPrice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    max_tip_amount: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    suggested_tip_amounts: Option<Vec<i64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    provider_data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    photo_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    photo_size: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    photo_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    photo_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    need_name: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    need_phone_number: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    need_email: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    need_shipping_address: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    send_phone_number_to_provider: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    send_email_to_provider: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    is_flexible: Option<bool>,
}
impl From<NoSkipInputInvoiceMessageContent> for InputInvoiceMessageContent {
    fn from(t: NoSkipInputInvoiceMessageContent) -> Self {
        Self {
            title: t.title,
            description: t.description,
            payload: t.payload,
            provider_token: t.provider_token,
            currency: t.currency,
            prices: t.prices,
            max_tip_amount: t.max_tip_amount,
            suggested_tip_amounts: t.suggested_tip_amounts,
            provider_data: t.provider_data,
            photo_url: t.photo_url,
            photo_size: t.photo_size,
            photo_width: t.photo_width,
            photo_height: t.photo_height,
            need_name: t.need_name,
            need_phone_number: t.need_phone_number,
            need_email: t.need_email,
            need_shipping_address: t.need_shipping_address,
            send_phone_number_to_provider: t.send_phone_number_to_provider,
            send_email_to_provider: t.send_email_to_provider,
            is_flexible: t.is_flexible,
        }
    }
}
impl Into<NoSkipInputInvoiceMessageContent> for InputInvoiceMessageContent {
    fn into(self) -> NoSkipInputInvoiceMessageContent {
        NoSkipInputInvoiceMessageContent {
            title: self.title,
            description: self.description,
            payload: self.payload,
            provider_token: self.provider_token,
            currency: self.currency,
            prices: self.prices,
            max_tip_amount: self.max_tip_amount,
            suggested_tip_amounts: self.suggested_tip_amounts,
            provider_data: self.provider_data,
            photo_url: self.photo_url,
            photo_size: self.photo_size,
            photo_width: self.photo_width,
            photo_height: self.photo_height,
            need_name: self.need_name,
            need_phone_number: self.need_phone_number,
            need_email: self.need_email,
            need_shipping_address: self.need_shipping_address,
            send_phone_number_to_provider: self.send_phone_number_to_provider,
            send_email_to_provider: self.send_email_to_provider,
            is_flexible: self.is_flexible,
        }
    }
}
impl NoSkipInputInvoiceMessageContent {
    pub fn skip(self) -> InputInvoiceMessageContent {
        self.into()
    }
}
impl InputInvoiceMessageContent {
    pub fn noskip(self) -> NoSkipInputInvoiceMessageContent {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the content of an invoice message to be sent as the result of an inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputInvoiceMessageContentBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    #[serde(rename = "description")]
    description: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    #[serde(rename = "payload")]
    payload: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    #[serde(rename = "provider_token")]
    provider_token: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    #[serde(rename = "prices")]
    prices: Vec<LabeledPrice>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "max_tip_amount",
        default
    )]
    max_tip_amount: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "suggested_tip_amounts",
        default
    )]
    suggested_tip_amounts: Option<Vec<i64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "provider_data",
        default
    )]
    provider_data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "photo_url", default)]
    photo_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "photo_size",
        default
    )]
    photo_size: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "photo_width",
        default
    )]
    photo_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "photo_height",
        default
    )]
    photo_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "need_name", default)]
    need_name: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "need_phone_number",
        default
    )]
    need_phone_number: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "need_email",
        default
    )]
    need_email: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "need_shipping_address",
        default
    )]
    need_shipping_address: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "send_phone_number_to_provider",
        default
    )]
    send_phone_number_to_provider: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "send_email_to_provider",
        default
    )]
    send_email_to_provider: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "is_flexible",
        default
    )]
    is_flexible: Option<bool>,
}
impl InputInvoiceMessageContentBuilder {
    pub fn new(
        title: String,
        description: String,
        payload: String,
        provider_token: String,
        currency: String,
        prices: Vec<LabeledPrice>,
    ) -> Self {
        Self {
            title,
            description,
            payload,
            provider_token,
            currency,
            prices,
            max_tip_amount: None,
            suggested_tip_amounts: None,
            provider_data: None,
            photo_url: None,
            photo_size: None,
            photo_width: None,
            photo_height: None,
            need_name: None,
            need_phone_number: None,
            need_email: None,
            need_shipping_address: None,
            send_phone_number_to_provider: None,
            send_email_to_provider: None,
            is_flexible: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = description;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    pub fn set_payload(mut self, payload: String) -> Self {
        self.payload = payload;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    pub fn set_provider_token(mut self, provider_token: String) -> Self {
        self.provider_token = provider_token;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    pub fn set_currency(mut self, currency: String) -> Self {
        self.currency = currency;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    pub fn set_prices(mut self, prices: Vec<LabeledPrice>) -> Self {
        self.prices = prices;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    pub fn set_max_tip_amount(mut self, max_tip_amount: i64) -> Self {
        self.max_tip_amount = Some(max_tip_amount);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    pub fn set_suggested_tip_amounts(mut self, suggested_tip_amounts: Vec<i64>) -> Self {
        self.suggested_tip_amounts = Some(suggested_tip_amounts);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    pub fn set_provider_data(mut self, provider_data: String) -> Self {
        self.provider_data = Some(provider_data);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    pub fn set_photo_url(mut self, photo_url: String) -> Self {
        self.photo_url = Some(photo_url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    pub fn set_photo_size(mut self, photo_size: i64) -> Self {
        self.photo_size = Some(photo_size);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    pub fn set_photo_width(mut self, photo_width: i64) -> Self {
        self.photo_width = Some(photo_width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    pub fn set_photo_height(mut self, photo_height: i64) -> Self {
        self.photo_height = Some(photo_height);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    pub fn set_need_name(mut self, need_name: bool) -> Self {
        self.need_name = Some(need_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    pub fn set_need_phone_number(mut self, need_phone_number: bool) -> Self {
        self.need_phone_number = Some(need_phone_number);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    pub fn set_need_email(mut self, need_email: bool) -> Self {
        self.need_email = Some(need_email);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    pub fn set_need_shipping_address(mut self, need_shipping_address: bool) -> Self {
        self.need_shipping_address = Some(need_shipping_address);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    pub fn set_send_phone_number_to_provider(
        mut self,
        send_phone_number_to_provider: bool,
    ) -> Self {
        self.send_phone_number_to_provider = Some(send_phone_number_to_provider);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    pub fn set_send_email_to_provider(mut self, send_email_to_provider: bool) -> Self {
        self.send_email_to_provider = Some(send_email_to_provider);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    pub fn set_is_flexible(mut self, is_flexible: bool) -> Self {
        self.is_flexible = Some(is_flexible);
        self
    }
    pub fn build(self) -> InputInvoiceMessageContent {
        InputInvoiceMessageContent {
            title: self.title,
            description: self.description,
            payload: self.payload,
            provider_token: self.provider_token,
            currency: self.currency,
            prices: self.prices,
            max_tip_amount: self.max_tip_amount,
            suggested_tip_amounts: self.suggested_tip_amounts,
            provider_data: self.provider_data,
            photo_url: self.photo_url,
            photo_size: self.photo_size,
            photo_width: self.photo_width,
            photo_height: self.photo_height,
            need_name: self.need_name,
            need_phone_number: self.need_phone_number,
            need_email: self.need_email,
            need_shipping_address: self.need_shipping_address,
            send_phone_number_to_provider: self.send_phone_number_to_provider,
            send_email_to_provider: self.send_email_to_provider,
            is_flexible: self.is_flexible,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that has no additional privileges or restrictions."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberMember {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatMemberMember that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatMemberMember {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
}
impl From<NoSkipChatMemberMember> for ChatMemberMember {
    fn from(t: NoSkipChatMemberMember) -> Self {
        Self { user: t.user }
    }
}
impl Into<NoSkipChatMemberMember> for ChatMemberMember {
    fn into(self) -> NoSkipChatMemberMember {
        NoSkipChatMemberMember { user: self.user }
    }
}
impl NoSkipChatMemberMember {
    pub fn skip(self) -> ChatMemberMember {
        self.into()
    }
}
impl ChatMemberMember {
    pub fn noskip(self) -> NoSkipChatMemberMember {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that has no additional privileges or restrictions."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberMemberBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
}
impl ChatMemberMemberBuilder {
    pub fn new(user: User) -> Self {
        Self { user }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user(mut self, user: User) -> Self {
        self.user = user;
        self
    }
    pub fn build(self) -> ChatMemberMember {
        ChatMemberMember { user: self.user }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Upon receiving a message with this object, Telegram clients will display a reply interface to the user (act as if the user has selected the bot's message and tapped 'Reply'). This can be extremely useful if you want to create user-friendly step-by-step interfaces without having to sacrifice privacy mode."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ForceReply {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"]
    #[serde(rename = "force_reply")]
    force_reply: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_field_placeholder",
        default
    )]
    input_field_placeholder: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "selective", default)]
    selective: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ForceReply that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipForceReply {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"]
    #[serde(rename = "force_reply")]
    force_reply: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"]
    input_field_placeholder: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."]
    selective: Option<bool>,
}
impl From<NoSkipForceReply> for ForceReply {
    fn from(t: NoSkipForceReply) -> Self {
        Self {
            force_reply: t.force_reply,
            input_field_placeholder: t.input_field_placeholder,
            selective: t.selective,
        }
    }
}
impl Into<NoSkipForceReply> for ForceReply {
    fn into(self) -> NoSkipForceReply {
        NoSkipForceReply {
            force_reply: self.force_reply,
            input_field_placeholder: self.input_field_placeholder,
            selective: self.selective,
        }
    }
}
impl NoSkipForceReply {
    pub fn skip(self) -> ForceReply {
        self.into()
    }
}
impl ForceReply {
    pub fn noskip(self) -> NoSkipForceReply {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Upon receiving a message with this object, Telegram clients will display a reply interface to the user (act as if the user has selected the bot's message and tapped 'Reply'). This can be extremely useful if you want to create user-friendly step-by-step interfaces without having to sacrifice privacy mode."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ForceReplyBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"]
    #[serde(rename = "force_reply")]
    force_reply: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_field_placeholder",
        default
    )]
    input_field_placeholder: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "selective", default)]
    selective: Option<bool>,
}
impl ForceReplyBuilder {
    pub fn new(force_reply: bool) -> Self {
        Self {
            force_reply,
            input_field_placeholder: None,
            selective: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"]
    pub fn set_force_reply(mut self, force_reply: bool) -> Self {
        self.force_reply = force_reply;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"]
    pub fn set_input_field_placeholder(mut self, input_field_placeholder: String) -> Self {
        self.input_field_placeholder = Some(input_field_placeholder);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."]
    pub fn set_selective(mut self, selective: bool) -> Self {
        self.selective = Some(selective);
        self
    }
    pub fn build(self) -> ForceReply {
        ForceReply {
            force_reply: self.force_reply,
            input_field_placeholder: self.input_field_placeholder,
            selective: self.selective,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a menu button, which launches a Web App."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MenuButtonWebApp {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    #[serde(rename = "web_app")]
    web_app: WebAppInfo,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to MenuButtonWebApp that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipMenuButtonWebApp {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    #[serde(rename = "web_app")]
    web_app: WebAppInfo,
}
impl From<NoSkipMenuButtonWebApp> for MenuButtonWebApp {
    fn from(t: NoSkipMenuButtonWebApp) -> Self {
        Self {
            tg_type: t.tg_type,
            text: t.text,
            web_app: t.web_app,
        }
    }
}
impl Into<NoSkipMenuButtonWebApp> for MenuButtonWebApp {
    fn into(self) -> NoSkipMenuButtonWebApp {
        NoSkipMenuButtonWebApp {
            tg_type: self.tg_type,
            text: self.text,
            web_app: self.web_app,
        }
    }
}
impl NoSkipMenuButtonWebApp {
    pub fn skip(self) -> MenuButtonWebApp {
        self.into()
    }
}
impl MenuButtonWebApp {
    pub fn noskip(self) -> NoSkipMenuButtonWebApp {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a menu button, which launches a Web App."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MenuButtonWebAppBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    #[serde(rename = "web_app")]
    web_app: WebAppInfo,
}
impl MenuButtonWebAppBuilder {
    pub fn new(text: String, web_app: WebAppInfo) -> Self {
        Self {
            tg_type: "web_app".to_owned(),
            text,
            web_app,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    pub fn set_text(mut self, text: String) -> Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    pub fn set_web_app(mut self, web_app: WebAppInfo) -> Self {
        self.web_app = web_app;
        self
    }
    pub fn build(self) -> MenuButtonWebApp {
        MenuButtonWebApp {
            tg_type: self.tg_type,
            text: self.text,
            web_app: self.web_app,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an incoming update.At most one of the optional parameters can be present in any given update."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Update {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."]
    #[serde(rename = "update_id")]
    update_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming message of any kind - text, photo, sticker, etc."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "message", default)]
    message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a message that is known to the bot and was edited"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "edited_message",
        default
    )]
    edited_message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming channel post of any kind - text, photo, sticker, etc."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "channel_post",
        default
    )]
    channel_post: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a channel post that is known to the bot and was edited"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "edited_channel_post",
        default
    )]
    edited_channel_post: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming inline query"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "inline_query",
        default
    )]
    inline_query: Option<InlineQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chosen_inline_result",
        default
    )]
    chosen_inline_result: Option<ChosenInlineResult>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming callback query"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "callback_query",
        default
    )]
    callback_query: Option<CallbackQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming shipping query. Only for invoices with flexible price"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "shipping_query",
        default
    )]
    shipping_query: Option<ShippingQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming pre-checkout query. Contains full information about checkout"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "pre_checkout_query",
        default
    )]
    pre_checkout_query: Option<PreCheckoutQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "poll", default)]
    poll: Option<Poll>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "poll_answer",
        default
    )]
    poll_answer: Option<PollAnswer>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "my_chat_member",
        default
    )]
    my_chat_member: Option<ChatMemberUpdated>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify \"chat_member\" in the list of allowed_updates to receive these updates."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_member",
        default
    )]
    chat_member: Option<ChatMemberUpdated>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_join_request",
        default
    )]
    chat_join_request: Option<ChatJoinRequest>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Update that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipUpdate {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."]
    #[serde(rename = "update_id")]
    update_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming message of any kind - text, photo, sticker, etc."]
    message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a message that is known to the bot and was edited"]
    edited_message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming channel post of any kind - text, photo, sticker, etc."]
    channel_post: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a channel post that is known to the bot and was edited"]
    edited_channel_post: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming inline query"]
    inline_query: Option<InlineQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."]
    chosen_inline_result: Option<ChosenInlineResult>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming callback query"]
    callback_query: Option<CallbackQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming shipping query. Only for invoices with flexible price"]
    shipping_query: Option<ShippingQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming pre-checkout query. Contains full information about checkout"]
    pre_checkout_query: Option<PreCheckoutQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"]
    poll: Option<Poll>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."]
    poll_answer: Option<PollAnswer>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."]
    my_chat_member: Option<ChatMemberUpdated>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify \"chat_member\" in the list of allowed_updates to receive these updates."]
    chat_member: Option<ChatMemberUpdated>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."]
    chat_join_request: Option<ChatJoinRequest>,
}
impl From<NoSkipUpdate> for Update {
    fn from(t: NoSkipUpdate) -> Self {
        Self {
            update_id: t.update_id,
            message: t.message,
            edited_message: t.edited_message,
            channel_post: t.channel_post,
            edited_channel_post: t.edited_channel_post,
            inline_query: t.inline_query,
            chosen_inline_result: t.chosen_inline_result,
            callback_query: t.callback_query,
            shipping_query: t.shipping_query,
            pre_checkout_query: t.pre_checkout_query,
            poll: t.poll,
            poll_answer: t.poll_answer,
            my_chat_member: t.my_chat_member,
            chat_member: t.chat_member,
            chat_join_request: t.chat_join_request,
        }
    }
}
impl Into<NoSkipUpdate> for Update {
    fn into(self) -> NoSkipUpdate {
        NoSkipUpdate {
            update_id: self.update_id,
            message: self.message,
            edited_message: self.edited_message,
            channel_post: self.channel_post,
            edited_channel_post: self.edited_channel_post,
            inline_query: self.inline_query,
            chosen_inline_result: self.chosen_inline_result,
            callback_query: self.callback_query,
            shipping_query: self.shipping_query,
            pre_checkout_query: self.pre_checkout_query,
            poll: self.poll,
            poll_answer: self.poll_answer,
            my_chat_member: self.my_chat_member,
            chat_member: self.chat_member,
            chat_join_request: self.chat_join_request,
        }
    }
}
impl NoSkipUpdate {
    pub fn skip(self) -> Update {
        self.into()
    }
}
impl Update {
    pub fn noskip(self) -> NoSkipUpdate {
        self.into()
    }
}
#[derive(Debug, Clone, Eq, PartialEq, PartialOrd, Ord, Hash)]
pub enum UpdateExt {
    Message(Message),
    EditedMessage(Message),
    ChannelPost(Message),
    EditedChannelPost(Message),
    InlineQuery(InlineQuery),
    ChosenInlineResult(ChosenInlineResult),
    CallbackQuery(CallbackQuery),
    ShippingQuery(ShippingQuery),
    PreCheckoutQuery(PreCheckoutQuery),
    Poll(Poll),
    PollAnswer(PollAnswer),
    MyChatMember(ChatMemberUpdated),
    ChatMember(ChatMemberUpdated),
    ChatJoinRequest(ChatJoinRequest),
    Invalid,
}
impl UpdateExt {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    pub fn get_general_forum_topic_unhidden<'a>(
        &'a self,
    ) -> Option<Cow<'a, GeneralForumTopicUnhidden>> {
        match self {
            Self::Message(ref v) => Some(v.get_general_forum_topic_unhidden()),
            Self::EditedMessage(ref v) => Some(v.get_general_forum_topic_unhidden()),
            Self::ChannelPost(ref v) => Some(v.get_general_forum_topic_unhidden()),
            Self::EditedChannelPost(ref v) => Some(v.get_general_forum_topic_unhidden()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    pub fn get_chat_shared<'a>(&'a self) -> Option<Cow<'a, ChatShared>> {
        match self {
            Self::Message(ref v) => Some(v.get_chat_shared()),
            Self::EditedMessage(ref v) => Some(v.get_chat_shared()),
            Self::ChannelPost(ref v) => Some(v.get_chat_shared()),
            Self::EditedChannelPost(ref v) => Some(v.get_chat_shared()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    pub fn get_chat_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::InlineQuery(ref v) => Some(v.get_chat_type()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    pub fn get_is_topic_message<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Message(ref v) => Some(v.get_is_topic_message()),
            Self::EditedMessage(ref v) => Some(v.get_is_topic_message()),
            Self::ChannelPost(ref v) => Some(v.get_is_topic_message()),
            Self::EditedChannelPost(ref v) => Some(v.get_is_topic_message()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    pub fn get_message_auto_delete_timer_changed<'a>(
        &'a self,
    ) -> Option<Cow<'a, MessageAutoDeleteTimerChanged>> {
        match self {
            Self::Message(ref v) => Some(v.get_message_auto_delete_timer_changed()),
            Self::EditedMessage(ref v) => Some(v.get_message_auto_delete_timer_changed()),
            Self::ChannelPost(ref v) => Some(v.get_message_auto_delete_timer_changed()),
            Self::EditedChannelPost(ref v) => Some(v.get_message_auto_delete_timer_changed()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    pub fn get_video<'a>(&'a self) -> Option<Cow<'a, Video>> {
        match self {
            Self::Message(ref v) => Some(v.get_video()),
            Self::EditedMessage(ref v) => Some(v.get_video()),
            Self::ChannelPost(ref v) => Some(v.get_video()),
            Self::EditedChannelPost(ref v) => Some(v.get_video()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    pub fn get_forward_from_chat<'a>(&'a self) -> Option<Cow<'a, Chat>> {
        match self {
            Self::Message(ref v) => Some(v.get_forward_from_chat()),
            Self::EditedMessage(ref v) => Some(v.get_forward_from_chat()),
            Self::ChannelPost(ref v) => Some(v.get_forward_from_chat()),
            Self::EditedChannelPost(ref v) => Some(v.get_forward_from_chat()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    pub fn get_data<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::CallbackQuery(ref v) => Some(v.get_data()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    pub fn get_successful_payment<'a>(&'a self) -> Option<Cow<'a, SuccessfulPayment>> {
        match self {
            Self::Message(ref v) => Some(v.get_successful_payment()),
            Self::EditedMessage(ref v) => Some(v.get_successful_payment()),
            Self::ChannelPost(ref v) => Some(v.get_successful_payment()),
            Self::EditedChannelPost(ref v) => Some(v.get_successful_payment()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    pub fn get_message_id<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Message(ref v) => Some(v.get_message_id()),
            Self::EditedMessage(ref v) => Some(v.get_message_id()),
            Self::ChannelPost(ref v) => Some(v.get_message_id()),
            Self::EditedChannelPost(ref v) => Some(v.get_message_id()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    pub fn get_video_chat_scheduled<'a>(&'a self) -> Option<Cow<'a, VideoChatScheduled>> {
        match self {
            Self::Message(ref v) => Some(v.get_video_chat_scheduled()),
            Self::EditedMessage(ref v) => Some(v.get_video_chat_scheduled()),
            Self::ChannelPost(ref v) => Some(v.get_video_chat_scheduled()),
            Self::EditedChannelPost(ref v) => Some(v.get_video_chat_scheduled()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    pub fn get_old_chat_member<'a>(&'a self) -> Option<Cow<'a, ChatMember>> {
        match self {
            Self::MyChatMember(ref v) => Some(v.get_old_chat_member()),
            Self::ChatMember(ref v) => Some(v.get_old_chat_member()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    pub fn get_question<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Poll(ref v) => Some(v.get_question()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    pub fn get_forward_signature<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Message(ref v) => Some(v.get_forward_signature()),
            Self::EditedMessage(ref v) => Some(v.get_forward_signature()),
            Self::ChannelPost(ref v) => Some(v.get_forward_signature()),
            Self::EditedChannelPost(ref v) => Some(v.get_forward_signature()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    pub fn get_query<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::ChosenInlineResult(ref v) => Some(v.get_query()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    pub fn get_forum_topic_edited<'a>(&'a self) -> Option<Cow<'a, ForumTopicEdited>> {
        match self {
            Self::Message(ref v) => Some(v.get_forum_topic_edited()),
            Self::EditedMessage(ref v) => Some(v.get_forum_topic_edited()),
            Self::ChannelPost(ref v) => Some(v.get_forum_topic_edited()),
            Self::EditedChannelPost(ref v) => Some(v.get_forum_topic_edited()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    pub fn get_new_chat_member<'a>(&'a self) -> Option<Cow<'a, ChatMember>> {
        match self {
            Self::MyChatMember(ref v) => Some(v.get_new_chat_member()),
            Self::ChatMember(ref v) => Some(v.get_new_chat_member()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn get_invoice_payload<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::ShippingQuery(ref v) => Some(v.get_invoice_payload()),
            Self::PreCheckoutQuery(ref v) => Some(v.get_invoice_payload()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_migrate_to_chat_id<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Message(ref v) => Some(v.get_migrate_to_chat_id()),
            Self::EditedMessage(ref v) => Some(v.get_migrate_to_chat_id()),
            Self::ChannelPost(ref v) => Some(v.get_migrate_to_chat_id()),
            Self::EditedChannelPost(ref v) => Some(v.get_migrate_to_chat_id()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    pub fn get_order_info<'a>(&'a self) -> Option<Cow<'a, OrderInfo>> {
        match self {
            Self::PreCheckoutQuery(ref v) => Some(v.get_order_info()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    pub fn get_forum_topic_created<'a>(&'a self) -> Option<Cow<'a, ForumTopicCreated>> {
        match self {
            Self::Message(ref v) => Some(v.get_forum_topic_created()),
            Self::EditedMessage(ref v) => Some(v.get_forum_topic_created()),
            Self::ChannelPost(ref v) => Some(v.get_forum_topic_created()),
            Self::EditedChannelPost(ref v) => Some(v.get_forum_topic_created()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    pub fn get_invoice<'a>(&'a self) -> Option<Cow<'a, Invoice>> {
        match self {
            Self::Message(ref v) => Some(v.get_invoice()),
            Self::EditedMessage(ref v) => Some(v.get_invoice()),
            Self::ChannelPost(ref v) => Some(v.get_invoice()),
            Self::EditedChannelPost(ref v) => Some(v.get_invoice()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    pub fn get_document<'a>(&'a self) -> Option<Cow<'a, Document>> {
        match self {
            Self::Message(ref v) => Some(v.get_document()),
            Self::EditedMessage(ref v) => Some(v.get_document()),
            Self::ChannelPost(ref v) => Some(v.get_document()),
            Self::EditedChannelPost(ref v) => Some(v.get_document()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    pub fn get_forum_topic_reopened<'a>(&'a self) -> Option<Cow<'a, ForumTopicReopened>> {
        match self {
            Self::Message(ref v) => Some(v.get_forum_topic_reopened()),
            Self::EditedMessage(ref v) => Some(v.get_forum_topic_reopened()),
            Self::ChannelPost(ref v) => Some(v.get_forum_topic_reopened()),
            Self::EditedChannelPost(ref v) => Some(v.get_forum_topic_reopened()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    pub fn get_edit_date<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Message(ref v) => Some(v.get_edit_date()),
            Self::EditedMessage(ref v) => Some(v.get_edit_date()),
            Self::ChannelPost(ref v) => Some(v.get_edit_date()),
            Self::EditedChannelPost(ref v) => Some(v.get_edit_date()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    pub fn get_voter_chat<'a>(&'a self) -> Option<Cow<'a, Chat>> {
        match self {
            Self::PollAnswer(ref v) => Some(v.get_voter_chat()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    pub fn get_passport_data<'a>(&'a self) -> Option<Cow<'a, PassportData>> {
        match self {
            Self::Message(ref v) => Some(v.get_passport_data()),
            Self::EditedMessage(ref v) => Some(v.get_passport_data()),
            Self::ChannelPost(ref v) => Some(v.get_passport_data()),
            Self::EditedChannelPost(ref v) => Some(v.get_passport_data()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    pub fn get_photo<'a>(&'a self) -> Option<Cow<'a, Vec<PhotoSize>>> {
        match self {
            Self::Message(ref v) => Some(v.get_photo()),
            Self::EditedMessage(ref v) => Some(v.get_photo()),
            Self::ChannelPost(ref v) => Some(v.get_photo()),
            Self::EditedChannelPost(ref v) => Some(v.get_photo()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    pub fn get_poll_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::PollAnswer(ref v) => Some(v.get_poll_id()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    pub fn get_user_shared<'a>(&'a self) -> Option<Cow<'a, UserShared>> {
        match self {
            Self::Message(ref v) => Some(v.get_user_shared()),
            Self::EditedMessage(ref v) => Some(v.get_user_shared()),
            Self::ChannelPost(ref v) => Some(v.get_user_shared()),
            Self::EditedChannelPost(ref v) => Some(v.get_user_shared()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    pub fn get_is_closed<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Poll(ref v) => Some(v.get_is_closed()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    pub fn get_total_voter_count<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Poll(ref v) => Some(v.get_total_voter_count()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    pub fn get_text<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Message(ref v) => Some(v.get_text()),
            Self::EditedMessage(ref v) => Some(v.get_text()),
            Self::ChannelPost(ref v) => Some(v.get_text()),
            Self::EditedChannelPost(ref v) => Some(v.get_text()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    pub fn get_delete_chat_photo<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Message(ref v) => Some(v.get_delete_chat_photo()),
            Self::EditedMessage(ref v) => Some(v.get_delete_chat_photo()),
            Self::ChannelPost(ref v) => Some(v.get_delete_chat_photo()),
            Self::EditedChannelPost(ref v) => Some(v.get_delete_chat_photo()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    pub fn get_user_chat_id<'a>(&'a self) -> Option<i64> {
        match self {
            Self::ChatJoinRequest(ref v) => Some(v.get_user_chat_id()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    pub fn get_explanation_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        match self {
            Self::Poll(ref v) => Some(v.get_explanation_entities()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    pub fn get_new_chat_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Message(ref v) => Some(v.get_new_chat_title()),
            Self::EditedMessage(ref v) => Some(v.get_new_chat_title()),
            Self::ChannelPost(ref v) => Some(v.get_new_chat_title()),
            Self::EditedChannelPost(ref v) => Some(v.get_new_chat_title()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    pub fn get_write_access_allowed<'a>(&'a self) -> Option<Cow<'a, WriteAccessAllowed>> {
        match self {
            Self::Message(ref v) => Some(v.get_write_access_allowed()),
            Self::EditedMessage(ref v) => Some(v.get_write_access_allowed()),
            Self::ChannelPost(ref v) => Some(v.get_write_access_allowed()),
            Self::EditedChannelPost(ref v) => Some(v.get_write_access_allowed()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    pub fn get_open_period<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Poll(ref v) => Some(v.get_open_period()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    pub fn get_voice<'a>(&'a self) -> Option<Cow<'a, Voice>> {
        match self {
            Self::Message(ref v) => Some(v.get_voice()),
            Self::EditedMessage(ref v) => Some(v.get_voice()),
            Self::ChannelPost(ref v) => Some(v.get_voice()),
            Self::EditedChannelPost(ref v) => Some(v.get_voice()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    pub fn get_forum_topic_closed<'a>(&'a self) -> Option<Cow<'a, ForumTopicClosed>> {
        match self {
            Self::Message(ref v) => Some(v.get_forum_topic_closed()),
            Self::EditedMessage(ref v) => Some(v.get_forum_topic_closed()),
            Self::ChannelPost(ref v) => Some(v.get_forum_topic_closed()),
            Self::EditedChannelPost(ref v) => Some(v.get_forum_topic_closed()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    pub fn get_media_group_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Message(ref v) => Some(v.get_media_group_id()),
            Self::EditedMessage(ref v) => Some(v.get_media_group_id()),
            Self::ChannelPost(ref v) => Some(v.get_media_group_id()),
            Self::EditedChannelPost(ref v) => Some(v.get_media_group_id()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    pub fn get_chat<'a>(&'a self) -> Option<Cow<'a, Chat>> {
        match self {
            Self::Message(ref v) => Some(v.get_chat()),
            Self::EditedMessage(ref v) => Some(v.get_chat()),
            Self::ChannelPost(ref v) => Some(v.get_chat()),
            Self::EditedChannelPost(ref v) => Some(v.get_chat()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    pub fn get_location<'a>(&'a self) -> Option<Cow<'a, Location>> {
        match self {
            Self::ChosenInlineResult(ref v) => Some(v.get_location()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    pub fn get_from<'a>(&'a self) -> Option<Cow<'a, User>> {
        match self {
            Self::Message(ref v) => Some(v.get_from()),
            Self::EditedMessage(ref v) => Some(v.get_from()),
            Self::ChannelPost(ref v) => Some(v.get_from()),
            Self::EditedChannelPost(ref v) => Some(v.get_from()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    pub fn get_new_chat_photo<'a>(&'a self) -> Option<Cow<'a, Vec<PhotoSize>>> {
        match self {
            Self::Message(ref v) => Some(v.get_new_chat_photo()),
            Self::EditedMessage(ref v) => Some(v.get_new_chat_photo()),
            Self::ChannelPost(ref v) => Some(v.get_new_chat_photo()),
            Self::EditedChannelPost(ref v) => Some(v.get_new_chat_photo()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    pub fn get_has_protected_content<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Message(ref v) => Some(v.get_has_protected_content()),
            Self::EditedMessage(ref v) => Some(v.get_has_protected_content()),
            Self::ChannelPost(ref v) => Some(v.get_has_protected_content()),
            Self::EditedChannelPost(ref v) => Some(v.get_has_protected_content()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    pub fn get_is_automatic_forward<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Message(ref v) => Some(v.get_is_automatic_forward()),
            Self::EditedMessage(ref v) => Some(v.get_is_automatic_forward()),
            Self::ChannelPost(ref v) => Some(v.get_is_automatic_forward()),
            Self::EditedChannelPost(ref v) => Some(v.get_is_automatic_forward()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    pub fn get_video_chat_ended<'a>(&'a self) -> Option<Cow<'a, VideoChatEnded>> {
        match self {
            Self::Message(ref v) => Some(v.get_video_chat_ended()),
            Self::EditedMessage(ref v) => Some(v.get_video_chat_ended()),
            Self::ChannelPost(ref v) => Some(v.get_video_chat_ended()),
            Self::EditedChannelPost(ref v) => Some(v.get_video_chat_ended()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        match self {
            Self::Message(ref v) => Some(v.get_reply_markup()),
            Self::EditedMessage(ref v) => Some(v.get_reply_markup()),
            Self::ChannelPost(ref v) => Some(v.get_reply_markup()),
            Self::EditedChannelPost(ref v) => Some(v.get_reply_markup()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    pub fn get_user<'a>(&'a self) -> Option<Cow<'a, User>> {
        match self {
            Self::PollAnswer(ref v) => Some(v.get_user()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    pub fn get_dice<'a>(&'a self) -> Option<Cow<'a, Dice>> {
        match self {
            Self::Message(ref v) => Some(v.get_dice()),
            Self::EditedMessage(ref v) => Some(v.get_dice()),
            Self::ChannelPost(ref v) => Some(v.get_dice()),
            Self::EditedChannelPost(ref v) => Some(v.get_dice()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    pub fn get_via_bot<'a>(&'a self) -> Option<Cow<'a, User>> {
        match self {
            Self::Message(ref v) => Some(v.get_via_bot()),
            Self::EditedMessage(ref v) => Some(v.get_via_bot()),
            Self::ChannelPost(ref v) => Some(v.get_via_bot()),
            Self::EditedChannelPost(ref v) => Some(v.get_via_bot()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    pub fn get_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        match self {
            Self::Message(ref v) => Some(v.get_entities()),
            Self::EditedMessage(ref v) => Some(v.get_entities()),
            Self::ChannelPost(ref v) => Some(v.get_entities()),
            Self::EditedChannelPost(ref v) => Some(v.get_entities()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    pub fn get_options<'a>(&'a self) -> Option<Cow<'a, Vec<PollOption>>> {
        match self {
            Self::Poll(ref v) => Some(v.get_options()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    pub fn get_animation<'a>(&'a self) -> Option<Cow<'a, Animation>> {
        match self {
            Self::Message(ref v) => Some(v.get_animation()),
            Self::EditedMessage(ref v) => Some(v.get_animation()),
            Self::ChannelPost(ref v) => Some(v.get_animation()),
            Self::EditedChannelPost(ref v) => Some(v.get_animation()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    pub fn get_venue<'a>(&'a self) -> Option<Cow<'a, Venue>> {
        match self {
            Self::Message(ref v) => Some(v.get_venue()),
            Self::EditedMessage(ref v) => Some(v.get_venue()),
            Self::ChannelPost(ref v) => Some(v.get_venue()),
            Self::EditedChannelPost(ref v) => Some(v.get_venue()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    pub fn get_via_chat_folder_invite_link<'a>(&'a self) -> Option<bool> {
        match self {
            Self::MyChatMember(ref v) => Some(v.get_via_chat_folder_invite_link()),
            Self::ChatMember(ref v) => Some(v.get_via_chat_folder_invite_link()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    pub fn get_poll<'a>(&'a self) -> Option<Cow<'a, Poll>> {
        match self {
            Self::Message(ref v) => Some(v.get_poll()),
            Self::EditedMessage(ref v) => Some(v.get_poll()),
            Self::ChannelPost(ref v) => Some(v.get_poll()),
            Self::EditedChannelPost(ref v) => Some(v.get_poll()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    pub fn get_inline_message_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::ChosenInlineResult(ref v) => Some(v.get_inline_message_id()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    pub fn get_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::InlineQuery(ref v) => Some(v.get_id()),
            Self::CallbackQuery(ref v) => Some(v.get_id()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    pub fn get_message<'a>(&'a self) -> Option<Cow<'a, Message>> {
        match self {
            Self::CallbackQuery(ref v) => Some(v.get_message()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    pub fn get_game_short_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::CallbackQuery(ref v) => Some(v.get_game_short_name()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    pub fn get_chat_instance<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::CallbackQuery(ref v) => Some(v.get_chat_instance()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    pub fn get_game<'a>(&'a self) -> Option<Cow<'a, Game>> {
        match self {
            Self::Message(ref v) => Some(v.get_game()),
            Self::EditedMessage(ref v) => Some(v.get_game()),
            Self::ChannelPost(ref v) => Some(v.get_game()),
            Self::EditedChannelPost(ref v) => Some(v.get_game()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    pub fn get_forward_from<'a>(&'a self) -> Option<Cow<'a, User>> {
        match self {
            Self::Message(ref v) => Some(v.get_forward_from()),
            Self::EditedMessage(ref v) => Some(v.get_forward_from()),
            Self::ChannelPost(ref v) => Some(v.get_forward_from()),
            Self::EditedChannelPost(ref v) => Some(v.get_forward_from()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    pub fn get_sticker<'a>(&'a self) -> Option<Cow<'a, Sticker>> {
        match self {
            Self::Message(ref v) => Some(v.get_sticker()),
            Self::EditedMessage(ref v) => Some(v.get_sticker()),
            Self::ChannelPost(ref v) => Some(v.get_sticker()),
            Self::EditedChannelPost(ref v) => Some(v.get_sticker()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    pub fn get_forward_sender_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Message(ref v) => Some(v.get_forward_sender_name()),
            Self::EditedMessage(ref v) => Some(v.get_forward_sender_name()),
            Self::ChannelPost(ref v) => Some(v.get_forward_sender_name()),
            Self::EditedChannelPost(ref v) => Some(v.get_forward_sender_name()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    pub fn get_story<'a>(&'a self) -> Option<Cow<'a, Story>> {
        match self {
            Self::Message(ref v) => Some(v.get_story()),
            Self::EditedMessage(ref v) => Some(v.get_story()),
            Self::ChannelPost(ref v) => Some(v.get_story()),
            Self::EditedChannelPost(ref v) => Some(v.get_story()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    pub fn get_audio<'a>(&'a self) -> Option<Cow<'a, Audio>> {
        match self {
            Self::Message(ref v) => Some(v.get_audio()),
            Self::EditedMessage(ref v) => Some(v.get_audio()),
            Self::ChannelPost(ref v) => Some(v.get_audio()),
            Self::EditedChannelPost(ref v) => Some(v.get_audio()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    pub fn get_close_date<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Poll(ref v) => Some(v.get_close_date()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    pub fn get_has_media_spoiler<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Message(ref v) => Some(v.get_has_media_spoiler()),
            Self::EditedMessage(ref v) => Some(v.get_has_media_spoiler()),
            Self::ChannelPost(ref v) => Some(v.get_has_media_spoiler()),
            Self::EditedChannelPost(ref v) => Some(v.get_has_media_spoiler()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    pub fn get_allows_multiple_answers<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Poll(ref v) => Some(v.get_allows_multiple_answers()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    pub fn get_video_note<'a>(&'a self) -> Option<Cow<'a, VideoNote>> {
        match self {
            Self::Message(ref v) => Some(v.get_video_note()),
            Self::EditedMessage(ref v) => Some(v.get_video_note()),
            Self::ChannelPost(ref v) => Some(v.get_video_note()),
            Self::EditedChannelPost(ref v) => Some(v.get_video_note()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    pub fn get_general_forum_topic_hidden<'a>(
        &'a self,
    ) -> Option<Cow<'a, GeneralForumTopicHidden>> {
        match self {
            Self::Message(ref v) => Some(v.get_general_forum_topic_hidden()),
            Self::EditedMessage(ref v) => Some(v.get_general_forum_topic_hidden()),
            Self::ChannelPost(ref v) => Some(v.get_general_forum_topic_hidden()),
            Self::EditedChannelPost(ref v) => Some(v.get_general_forum_topic_hidden()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    pub fn get_new_chat_members<'a>(&'a self) -> Option<Cow<'a, Vec<User>>> {
        match self {
            Self::Message(ref v) => Some(v.get_new_chat_members()),
            Self::EditedMessage(ref v) => Some(v.get_new_chat_members()),
            Self::ChannelPost(ref v) => Some(v.get_new_chat_members()),
            Self::EditedChannelPost(ref v) => Some(v.get_new_chat_members()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    pub fn get_pinned_message<'a>(&'a self) -> Option<Cow<'a, Message>> {
        match self {
            Self::Message(ref v) => Some(v.get_pinned_message()),
            Self::EditedMessage(ref v) => Some(v.get_pinned_message()),
            Self::ChannelPost(ref v) => Some(v.get_pinned_message()),
            Self::EditedChannelPost(ref v) => Some(v.get_pinned_message()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    pub fn get_channel_chat_created<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Message(ref v) => Some(v.get_channel_chat_created()),
            Self::EditedMessage(ref v) => Some(v.get_channel_chat_created()),
            Self::ChannelPost(ref v) => Some(v.get_channel_chat_created()),
            Self::EditedChannelPost(ref v) => Some(v.get_channel_chat_created()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    pub fn get_date<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Message(ref v) => Some(v.get_date()),
            Self::EditedMessage(ref v) => Some(v.get_date()),
            Self::ChannelPost(ref v) => Some(v.get_date()),
            Self::EditedChannelPost(ref v) => Some(v.get_date()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    pub fn get_forward_date<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Message(ref v) => Some(v.get_forward_date()),
            Self::EditedMessage(ref v) => Some(v.get_forward_date()),
            Self::ChannelPost(ref v) => Some(v.get_forward_date()),
            Self::EditedChannelPost(ref v) => Some(v.get_forward_date()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    pub fn get_shipping_address<'a>(&'a self) -> Option<Cow<'a, ShippingAddress>> {
        match self {
            Self::ShippingQuery(ref v) => Some(v.get_shipping_address()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn get_currency<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::PreCheckoutQuery(ref v) => Some(v.get_currency()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    pub fn get_bio<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::ChatJoinRequest(ref v) => Some(v.get_bio()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    pub fn get_forward_from_message_id<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Message(ref v) => Some(v.get_forward_from_message_id()),
            Self::EditedMessage(ref v) => Some(v.get_forward_from_message_id()),
            Self::ChannelPost(ref v) => Some(v.get_forward_from_message_id()),
            Self::EditedChannelPost(ref v) => Some(v.get_forward_from_message_id()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    pub fn get_shipping_option_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::PreCheckoutQuery(ref v) => Some(v.get_shipping_option_id()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    pub fn get_offset<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::InlineQuery(ref v) => Some(v.get_offset()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    pub fn get_correct_option_id<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Poll(ref v) => Some(v.get_correct_option_id()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    pub fn get_result_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::ChosenInlineResult(ref v) => Some(v.get_result_id()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    pub fn get_explanation<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Poll(ref v) => Some(v.get_explanation()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    pub fn get_reply_to_message<'a>(&'a self) -> Option<Cow<'a, Message>> {
        match self {
            Self::Message(ref v) => Some(v.get_reply_to_message()),
            Self::EditedMessage(ref v) => Some(v.get_reply_to_message()),
            Self::ChannelPost(ref v) => Some(v.get_reply_to_message()),
            Self::EditedChannelPost(ref v) => Some(v.get_reply_to_message()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    pub fn get_invite_link<'a>(&'a self) -> Option<Cow<'a, ChatInviteLink>> {
        match self {
            Self::ChatJoinRequest(ref v) => Some(v.get_invite_link()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    pub fn get_contact<'a>(&'a self) -> Option<Cow<'a, Contact>> {
        match self {
            Self::Message(ref v) => Some(v.get_contact()),
            Self::EditedMessage(ref v) => Some(v.get_contact()),
            Self::ChannelPost(ref v) => Some(v.get_contact()),
            Self::EditedChannelPost(ref v) => Some(v.get_contact()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn get_total_amount<'a>(&'a self) -> Option<i64> {
        match self {
            Self::PreCheckoutQuery(ref v) => Some(v.get_total_amount()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    pub fn get_sender_chat<'a>(&'a self) -> Option<Cow<'a, Chat>> {
        match self {
            Self::Message(ref v) => Some(v.get_sender_chat()),
            Self::EditedMessage(ref v) => Some(v.get_sender_chat()),
            Self::ChannelPost(ref v) => Some(v.get_sender_chat()),
            Self::EditedChannelPost(ref v) => Some(v.get_sender_chat()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    pub fn get_video_chat_started<'a>(&'a self) -> Option<Cow<'a, VideoChatStarted>> {
        match self {
            Self::Message(ref v) => Some(v.get_video_chat_started()),
            Self::EditedMessage(ref v) => Some(v.get_video_chat_started()),
            Self::ChannelPost(ref v) => Some(v.get_video_chat_started()),
            Self::EditedChannelPost(ref v) => Some(v.get_video_chat_started()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    pub fn get_is_anonymous<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Poll(ref v) => Some(v.get_is_anonymous()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    pub fn get_connected_website<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Message(ref v) => Some(v.get_connected_website()),
            Self::EditedMessage(ref v) => Some(v.get_connected_website()),
            Self::ChannelPost(ref v) => Some(v.get_connected_website()),
            Self::EditedChannelPost(ref v) => Some(v.get_connected_website()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    pub fn get_video_chat_participants_invited<'a>(
        &'a self,
    ) -> Option<Cow<'a, VideoChatParticipantsInvited>> {
        match self {
            Self::Message(ref v) => Some(v.get_video_chat_participants_invited()),
            Self::EditedMessage(ref v) => Some(v.get_video_chat_participants_invited()),
            Self::ChannelPost(ref v) => Some(v.get_video_chat_participants_invited()),
            Self::EditedChannelPost(ref v) => Some(v.get_video_chat_participants_invited()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    pub fn get_supergroup_chat_created<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Message(ref v) => Some(v.get_supergroup_chat_created()),
            Self::EditedMessage(ref v) => Some(v.get_supergroup_chat_created()),
            Self::ChannelPost(ref v) => Some(v.get_supergroup_chat_created()),
            Self::EditedChannelPost(ref v) => Some(v.get_supergroup_chat_created()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    pub fn get_proximity_alert_triggered<'a>(&'a self) -> Option<Cow<'a, ProximityAlertTriggered>> {
        match self {
            Self::Message(ref v) => Some(v.get_proximity_alert_triggered()),
            Self::EditedMessage(ref v) => Some(v.get_proximity_alert_triggered()),
            Self::ChannelPost(ref v) => Some(v.get_proximity_alert_triggered()),
            Self::EditedChannelPost(ref v) => Some(v.get_proximity_alert_triggered()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    pub fn get_message_thread_id<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Message(ref v) => Some(v.get_message_thread_id()),
            Self::EditedMessage(ref v) => Some(v.get_message_thread_id()),
            Self::ChannelPost(ref v) => Some(v.get_message_thread_id()),
            Self::EditedChannelPost(ref v) => Some(v.get_message_thread_id()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    pub fn get_tg_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Poll(ref v) => Some(v.get_tg_type()),
            _ => None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    pub fn get_left_chat_member<'a>(&'a self) -> Option<Cow<'a, User>> {
        match self {
            Self::Message(ref v) => Some(v.get_left_chat_member()),
            Self::EditedMessage(ref v) => Some(v.get_left_chat_member()),
            Self::ChannelPost(ref v) => Some(v.get_left_chat_member()),
            Self::EditedChannelPost(ref v) => Some(v.get_left_chat_member()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    pub fn get_group_chat_created<'a>(&'a self) -> Option<bool> {
        match self {
            Self::Message(ref v) => Some(v.get_group_chat_created()),
            Self::EditedMessage(ref v) => Some(v.get_group_chat_created()),
            Self::ChannelPost(ref v) => Some(v.get_group_chat_created()),
            Self::EditedChannelPost(ref v) => Some(v.get_group_chat_created()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    pub fn get_web_app_data<'a>(&'a self) -> Option<Cow<'a, WebAppData>> {
        match self {
            Self::Message(ref v) => Some(v.get_web_app_data()),
            Self::EditedMessage(ref v) => Some(v.get_web_app_data()),
            Self::ChannelPost(ref v) => Some(v.get_web_app_data()),
            Self::EditedChannelPost(ref v) => Some(v.get_web_app_data()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        match self {
            Self::Message(ref v) => Some(v.get_caption_entities()),
            Self::EditedMessage(ref v) => Some(v.get_caption_entities()),
            Self::ChannelPost(ref v) => Some(v.get_caption_entities()),
            Self::EditedChannelPost(ref v) => Some(v.get_caption_entities()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_migrate_from_chat_id<'a>(&'a self) -> Option<i64> {
        match self {
            Self::Message(ref v) => Some(v.get_migrate_from_chat_id()),
            Self::EditedMessage(ref v) => Some(v.get_migrate_from_chat_id()),
            Self::ChannelPost(ref v) => Some(v.get_migrate_from_chat_id()),
            Self::EditedChannelPost(ref v) => Some(v.get_migrate_from_chat_id()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Message(ref v) => Some(v.get_caption()),
            Self::EditedMessage(ref v) => Some(v.get_caption()),
            Self::ChannelPost(ref v) => Some(v.get_caption()),
            Self::EditedChannelPost(ref v) => Some(v.get_caption()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    pub fn get_author_signature<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Self::Message(ref v) => Some(v.get_author_signature()),
            Self::EditedMessage(ref v) => Some(v.get_author_signature()),
            Self::ChannelPost(ref v) => Some(v.get_author_signature()),
            Self::EditedChannelPost(ref v) => Some(v.get_author_signature()),
            _ => None,
        }
        .flatten()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    pub fn get_option_ids<'a>(&'a self) -> Option<Cow<'a, Vec<i64>>> {
        match self {
            Self::PollAnswer(ref v) => Some(v.get_option_ids()),
            _ => None,
        }
    }
}
impl From<Update> for UpdateExt {
    fn from(update: Update) -> Self {
        if let Some(thing) = update.message {
            return Self::Message(thing);
        }
        if let Some(thing) = update.edited_message {
            return Self::EditedMessage(thing);
        }
        if let Some(thing) = update.channel_post {
            return Self::ChannelPost(thing);
        }
        if let Some(thing) = update.edited_channel_post {
            return Self::EditedChannelPost(thing);
        }
        if let Some(thing) = update.inline_query {
            return Self::InlineQuery(thing);
        }
        if let Some(thing) = update.chosen_inline_result {
            return Self::ChosenInlineResult(thing);
        }
        if let Some(thing) = update.callback_query {
            return Self::CallbackQuery(thing);
        }
        if let Some(thing) = update.shipping_query {
            return Self::ShippingQuery(thing);
        }
        if let Some(thing) = update.pre_checkout_query {
            return Self::PreCheckoutQuery(thing);
        }
        if let Some(thing) = update.poll {
            return Self::Poll(thing);
        }
        if let Some(thing) = update.poll_answer {
            return Self::PollAnswer(thing);
        }
        if let Some(thing) = update.my_chat_member {
            return Self::MyChatMember(thing);
        }
        if let Some(thing) = update.chat_member {
            return Self::ChatMember(thing);
        }
        if let Some(thing) = update.chat_join_request {
            return Self::ChatJoinRequest(thing);
        }
        Self::Invalid
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an incoming update.At most one of the optional parameters can be present in any given update."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct UpdateBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."]
    #[serde(rename = "update_id")]
    update_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming message of any kind - text, photo, sticker, etc."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "message", default)]
    message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a message that is known to the bot and was edited"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "edited_message",
        default
    )]
    edited_message: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming channel post of any kind - text, photo, sticker, etc."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "channel_post",
        default
    )]
    channel_post: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a channel post that is known to the bot and was edited"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "edited_channel_post",
        default
    )]
    edited_channel_post: Option<Message>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming inline query"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "inline_query",
        default
    )]
    inline_query: Option<InlineQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chosen_inline_result",
        default
    )]
    chosen_inline_result: Option<ChosenInlineResult>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming callback query"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "callback_query",
        default
    )]
    callback_query: Option<CallbackQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming shipping query. Only for invoices with flexible price"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "shipping_query",
        default
    )]
    shipping_query: Option<ShippingQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming pre-checkout query. Contains full information about checkout"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "pre_checkout_query",
        default
    )]
    pre_checkout_query: Option<PreCheckoutQuery>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "poll", default)]
    poll: Option<Poll>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "poll_answer",
        default
    )]
    poll_answer: Option<PollAnswer>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "my_chat_member",
        default
    )]
    my_chat_member: Option<ChatMemberUpdated>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify \"chat_member\" in the list of allowed_updates to receive these updates."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_member",
        default
    )]
    chat_member: Option<ChatMemberUpdated>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_join_request",
        default
    )]
    chat_join_request: Option<ChatJoinRequest>,
}
impl UpdateBuilder {
    pub fn new(update_id: i64) -> Self {
        Self {
            update_id,
            message: None,
            edited_message: None,
            channel_post: None,
            edited_channel_post: None,
            inline_query: None,
            chosen_inline_result: None,
            callback_query: None,
            shipping_query: None,
            pre_checkout_query: None,
            poll: None,
            poll_answer: None,
            my_chat_member: None,
            chat_member: None,
            chat_join_request: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."]
    pub fn set_update_id(mut self, update_id: i64) -> Self {
        self.update_id = update_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming message of any kind - text, photo, sticker, etc."]
    pub fn set_message(mut self, message: Message) -> Self {
        self.message = Some(message);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a message that is known to the bot and was edited"]
    pub fn set_edited_message(mut self, edited_message: Message) -> Self {
        self.edited_message = Some(edited_message);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming channel post of any kind - text, photo, sticker, etc."]
    pub fn set_channel_post(mut self, channel_post: Message) -> Self {
        self.channel_post = Some(channel_post);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a channel post that is known to the bot and was edited"]
    pub fn set_edited_channel_post(mut self, edited_channel_post: Message) -> Self {
        self.edited_channel_post = Some(edited_channel_post);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming inline query"]
    pub fn set_inline_query(mut self, inline_query: InlineQuery) -> Self {
        self.inline_query = Some(inline_query);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."]
    pub fn set_chosen_inline_result(mut self, chosen_inline_result: ChosenInlineResult) -> Self {
        self.chosen_inline_result = Some(chosen_inline_result);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming callback query"]
    pub fn set_callback_query(mut self, callback_query: CallbackQuery) -> Self {
        self.callback_query = Some(callback_query);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming shipping query. Only for invoices with flexible price"]
    pub fn set_shipping_query(mut self, shipping_query: ShippingQuery) -> Self {
        self.shipping_query = Some(shipping_query);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming pre-checkout query. Contains full information about checkout"]
    pub fn set_pre_checkout_query(mut self, pre_checkout_query: PreCheckoutQuery) -> Self {
        self.pre_checkout_query = Some(pre_checkout_query);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"]
    pub fn set_poll(mut self, poll: Poll) -> Self {
        self.poll = Some(poll);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."]
    pub fn set_poll_answer(mut self, poll_answer: PollAnswer) -> Self {
        self.poll_answer = Some(poll_answer);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."]
    pub fn set_my_chat_member(mut self, my_chat_member: ChatMemberUpdated) -> Self {
        self.my_chat_member = Some(my_chat_member);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify \"chat_member\" in the list of allowed_updates to receive these updates."]
    pub fn set_chat_member(mut self, chat_member: ChatMemberUpdated) -> Self {
        self.chat_member = Some(chat_member);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."]
    pub fn set_chat_join_request(mut self, chat_join_request: ChatJoinRequest) -> Self {
        self.chat_join_request = Some(chat_join_request);
        self
    }
    pub fn build(self) -> Update {
        Update {
            update_id: self.update_id,
            message: self.message,
            edited_message: self.edited_message,
            channel_post: self.channel_post,
            edited_channel_post: self.edited_channel_post,
            inline_query: self.inline_query,
            chosen_inline_result: self.chosen_inline_result,
            callback_query: self.callback_query,
            shipping_query: self.shipping_query,
            pre_checkout_query: self.pre_checkout_query,
            poll: self.poll,
            poll_answer: self.poll_answer,
            my_chat_member: self.my_chat_member,
            chat_member: self.chat_member,
            chat_join_request: self.chat_join_request,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a menu button, which opens the bot's list of commands."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MenuButtonCommands {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    #[serde(rename = "type")]
    tg_type: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to MenuButtonCommands that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipMenuButtonCommands {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl From<NoSkipMenuButtonCommands> for MenuButtonCommands {
    fn from(t: NoSkipMenuButtonCommands) -> Self {
        Self { tg_type: t.tg_type }
    }
}
impl Into<NoSkipMenuButtonCommands> for MenuButtonCommands {
    fn into(self) -> NoSkipMenuButtonCommands {
        NoSkipMenuButtonCommands {
            tg_type: self.tg_type,
        }
    }
}
impl NoSkipMenuButtonCommands {
    pub fn skip(self) -> MenuButtonCommands {
        self.into()
    }
}
impl MenuButtonCommands {
    pub fn noskip(self) -> NoSkipMenuButtonCommands {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a menu button, which opens the bot's list of commands."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MenuButtonCommandsBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl MenuButtonCommandsBuilder {
    pub fn new() -> Self {
        Self {
            tg_type: "commands".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    pub fn build(self) -> MenuButtonCommands {
        MenuButtonCommands {
            tg_type: self.tg_type,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that is under certain restrictions in the chat. Supergroups only."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberRestricted {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    #[serde(rename = "is_member")]
    is_member: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    #[serde(rename = "can_send_messages")]
    can_send_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    #[serde(rename = "can_send_audios")]
    can_send_audios: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    #[serde(rename = "can_send_documents")]
    can_send_documents: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    #[serde(rename = "can_send_photos")]
    can_send_photos: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    #[serde(rename = "can_send_videos")]
    can_send_videos: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    #[serde(rename = "can_send_video_notes")]
    can_send_video_notes: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    #[serde(rename = "can_send_voice_notes")]
    can_send_voice_notes: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    #[serde(rename = "can_send_polls")]
    can_send_polls: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    #[serde(rename = "can_send_other_messages")]
    can_send_other_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    #[serde(rename = "can_add_web_page_previews")]
    can_add_web_page_previews: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    #[serde(rename = "can_change_info")]
    can_change_info: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    #[serde(rename = "can_invite_users")]
    can_invite_users: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    #[serde(rename = "can_pin_messages")]
    can_pin_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    #[serde(rename = "can_manage_topics")]
    can_manage_topics: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    #[serde(rename = "until_date")]
    until_date: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatMemberRestricted that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatMemberRestricted {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    #[serde(rename = "is_member")]
    is_member: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    #[serde(rename = "can_send_messages")]
    can_send_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    #[serde(rename = "can_send_audios")]
    can_send_audios: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    #[serde(rename = "can_send_documents")]
    can_send_documents: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    #[serde(rename = "can_send_photos")]
    can_send_photos: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    #[serde(rename = "can_send_videos")]
    can_send_videos: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    #[serde(rename = "can_send_video_notes")]
    can_send_video_notes: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    #[serde(rename = "can_send_voice_notes")]
    can_send_voice_notes: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    #[serde(rename = "can_send_polls")]
    can_send_polls: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    #[serde(rename = "can_send_other_messages")]
    can_send_other_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    #[serde(rename = "can_add_web_page_previews")]
    can_add_web_page_previews: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    #[serde(rename = "can_change_info")]
    can_change_info: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    #[serde(rename = "can_invite_users")]
    can_invite_users: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    #[serde(rename = "can_pin_messages")]
    can_pin_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    #[serde(rename = "can_manage_topics")]
    can_manage_topics: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    #[serde(rename = "until_date")]
    until_date: i64,
}
impl From<NoSkipChatMemberRestricted> for ChatMemberRestricted {
    fn from(t: NoSkipChatMemberRestricted) -> Self {
        Self {
            user: t.user,
            is_member: t.is_member,
            can_send_messages: t.can_send_messages,
            can_send_audios: t.can_send_audios,
            can_send_documents: t.can_send_documents,
            can_send_photos: t.can_send_photos,
            can_send_videos: t.can_send_videos,
            can_send_video_notes: t.can_send_video_notes,
            can_send_voice_notes: t.can_send_voice_notes,
            can_send_polls: t.can_send_polls,
            can_send_other_messages: t.can_send_other_messages,
            can_add_web_page_previews: t.can_add_web_page_previews,
            can_change_info: t.can_change_info,
            can_invite_users: t.can_invite_users,
            can_pin_messages: t.can_pin_messages,
            can_manage_topics: t.can_manage_topics,
            until_date: t.until_date,
        }
    }
}
impl Into<NoSkipChatMemberRestricted> for ChatMemberRestricted {
    fn into(self) -> NoSkipChatMemberRestricted {
        NoSkipChatMemberRestricted {
            user: self.user,
            is_member: self.is_member,
            can_send_messages: self.can_send_messages,
            can_send_audios: self.can_send_audios,
            can_send_documents: self.can_send_documents,
            can_send_photos: self.can_send_photos,
            can_send_videos: self.can_send_videos,
            can_send_video_notes: self.can_send_video_notes,
            can_send_voice_notes: self.can_send_voice_notes,
            can_send_polls: self.can_send_polls,
            can_send_other_messages: self.can_send_other_messages,
            can_add_web_page_previews: self.can_add_web_page_previews,
            can_change_info: self.can_change_info,
            can_invite_users: self.can_invite_users,
            can_pin_messages: self.can_pin_messages,
            can_manage_topics: self.can_manage_topics,
            until_date: self.until_date,
        }
    }
}
impl NoSkipChatMemberRestricted {
    pub fn skip(self) -> ChatMemberRestricted {
        self.into()
    }
}
impl ChatMemberRestricted {
    pub fn noskip(self) -> NoSkipChatMemberRestricted {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that is under certain restrictions in the chat. Supergroups only."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberRestrictedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    #[serde(rename = "is_member")]
    is_member: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    #[serde(rename = "can_send_messages")]
    can_send_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    #[serde(rename = "can_send_audios")]
    can_send_audios: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    #[serde(rename = "can_send_documents")]
    can_send_documents: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    #[serde(rename = "can_send_photos")]
    can_send_photos: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    #[serde(rename = "can_send_videos")]
    can_send_videos: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    #[serde(rename = "can_send_video_notes")]
    can_send_video_notes: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    #[serde(rename = "can_send_voice_notes")]
    can_send_voice_notes: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    #[serde(rename = "can_send_polls")]
    can_send_polls: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    #[serde(rename = "can_send_other_messages")]
    can_send_other_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    #[serde(rename = "can_add_web_page_previews")]
    can_add_web_page_previews: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    #[serde(rename = "can_change_info")]
    can_change_info: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    #[serde(rename = "can_invite_users")]
    can_invite_users: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    #[serde(rename = "can_pin_messages")]
    can_pin_messages: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    #[serde(rename = "can_manage_topics")]
    can_manage_topics: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    #[serde(rename = "until_date")]
    until_date: i64,
}
impl ChatMemberRestrictedBuilder {
    pub fn new(
        user: User,
        is_member: bool,
        can_send_messages: bool,
        can_send_audios: bool,
        can_send_documents: bool,
        can_send_photos: bool,
        can_send_videos: bool,
        can_send_video_notes: bool,
        can_send_voice_notes: bool,
        can_send_polls: bool,
        can_send_other_messages: bool,
        can_add_web_page_previews: bool,
        can_change_info: bool,
        can_invite_users: bool,
        can_pin_messages: bool,
        can_manage_topics: bool,
        until_date: i64,
    ) -> Self {
        Self {
            user,
            is_member,
            can_send_messages,
            can_send_audios,
            can_send_documents,
            can_send_photos,
            can_send_videos,
            can_send_video_notes,
            can_send_voice_notes,
            can_send_polls,
            can_send_other_messages,
            can_add_web_page_previews,
            can_change_info,
            can_invite_users,
            can_pin_messages,
            can_manage_topics,
            until_date,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user(mut self, user: User) -> Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    pub fn set_is_member(mut self, is_member: bool) -> Self {
        self.is_member = is_member;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    pub fn set_can_send_messages(mut self, can_send_messages: bool) -> Self {
        self.can_send_messages = can_send_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    pub fn set_can_send_audios(mut self, can_send_audios: bool) -> Self {
        self.can_send_audios = can_send_audios;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    pub fn set_can_send_documents(mut self, can_send_documents: bool) -> Self {
        self.can_send_documents = can_send_documents;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    pub fn set_can_send_photos(mut self, can_send_photos: bool) -> Self {
        self.can_send_photos = can_send_photos;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    pub fn set_can_send_videos(mut self, can_send_videos: bool) -> Self {
        self.can_send_videos = can_send_videos;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    pub fn set_can_send_video_notes(mut self, can_send_video_notes: bool) -> Self {
        self.can_send_video_notes = can_send_video_notes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    pub fn set_can_send_voice_notes(mut self, can_send_voice_notes: bool) -> Self {
        self.can_send_voice_notes = can_send_voice_notes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    pub fn set_can_send_polls(mut self, can_send_polls: bool) -> Self {
        self.can_send_polls = can_send_polls;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    pub fn set_can_send_other_messages(mut self, can_send_other_messages: bool) -> Self {
        self.can_send_other_messages = can_send_other_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    pub fn set_can_add_web_page_previews(mut self, can_add_web_page_previews: bool) -> Self {
        self.can_add_web_page_previews = can_add_web_page_previews;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn set_can_change_info(mut self, can_change_info: bool) -> Self {
        self.can_change_info = can_change_info;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn set_can_invite_users(mut self, can_invite_users: bool) -> Self {
        self.can_invite_users = can_invite_users;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    pub fn set_can_pin_messages(mut self, can_pin_messages: bool) -> Self {
        self.can_pin_messages = can_pin_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    pub fn set_can_manage_topics(mut self, can_manage_topics: bool) -> Self {
        self.can_manage_topics = can_manage_topics;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    pub fn set_until_date(mut self, until_date: i64) -> Self {
        self.until_date = until_date;
        self
    }
    pub fn build(self) -> ChatMemberRestricted {
        ChatMemberRestricted {
            user: self.user,
            is_member: self.is_member,
            can_send_messages: self.can_send_messages,
            can_send_audios: self.can_send_audios,
            can_send_documents: self.can_send_documents,
            can_send_photos: self.can_send_photos,
            can_send_videos: self.can_send_videos,
            can_send_video_notes: self.can_send_video_notes,
            can_send_voice_notes: self.can_send_voice_notes,
            can_send_polls: self.can_send_polls,
            can_send_other_messages: self.can_send_other_messages,
            can_add_web_page_previews: self.can_add_web_page_previews,
            can_change_info: self.can_change_info,
            can_invite_users: self.can_invite_users,
            can_pin_messages: self.can_pin_messages,
            can_manage_topics: self.can_manage_topics,
            until_date: self.until_date,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to an article or web page."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultArticle {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    #[serde(rename = "input_message_content")]
    input_message_content: InputMessageContent,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "url", default)]
    url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "hide_url", default)]
    hide_url: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_url",
        default
    )]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_width",
        default
    )]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_height",
        default
    )]
    thumbnail_height: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultArticle that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultArticle {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    #[serde(rename = "input_message_content")]
    input_message_content: InputMessageContent,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    hide_url: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    thumbnail_height: Option<i64>,
}
impl From<NoSkipInlineQueryResultArticle> for InlineQueryResultArticle {
    fn from(t: NoSkipInlineQueryResultArticle) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            title: t.title,
            input_message_content: t.input_message_content,
            reply_markup: t.reply_markup,
            url: t.url,
            hide_url: t.hide_url,
            description: t.description,
            thumbnail_url: t.thumbnail_url,
            thumbnail_width: t.thumbnail_width,
            thumbnail_height: t.thumbnail_height,
        }
    }
}
impl Into<NoSkipInlineQueryResultArticle> for InlineQueryResultArticle {
    fn into(self) -> NoSkipInlineQueryResultArticle {
        NoSkipInlineQueryResultArticle {
            tg_type: self.tg_type,
            id: self.id,
            title: self.title,
            input_message_content: self.input_message_content,
            reply_markup: self.reply_markup,
            url: self.url,
            hide_url: self.hide_url,
            description: self.description,
            thumbnail_url: self.thumbnail_url,
            thumbnail_width: self.thumbnail_width,
            thumbnail_height: self.thumbnail_height,
        }
    }
}
impl NoSkipInlineQueryResultArticle {
    pub fn skip(self) -> InlineQueryResultArticle {
        self.into()
    }
}
impl InlineQueryResultArticle {
    pub fn noskip(self) -> NoSkipInlineQueryResultArticle {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to an article or web page."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultArticleBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    #[serde(rename = "input_message_content")]
    input_message_content: InputMessageContent,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "url", default)]
    url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "hide_url", default)]
    hide_url: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_url",
        default
    )]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_width",
        default
    )]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_height",
        default
    )]
    thumbnail_height: Option<i64>,
}
impl InlineQueryResultArticleBuilder {
    pub fn new(id: String, title: String, input_message_content: InputMessageContent) -> Self {
        Self {
            tg_type: "article".to_owned(),
            id,
            title,
            input_message_content,
            reply_markup: None,
            url: None,
            hide_url: None,
            description: None,
            thumbnail_url: None,
            thumbnail_width: None,
            thumbnail_height: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = input_message_content;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    pub fn set_url(mut self, url: String) -> Self {
        self.url = Some(url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    pub fn set_hide_url(mut self, hide_url: bool) -> Self {
        self.hide_url = Some(hide_url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn set_thumbnail_url(mut self, thumbnail_url: String) -> Self {
        self.thumbnail_url = Some(thumbnail_url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn set_thumbnail_width(mut self, thumbnail_width: i64) -> Self {
        self.thumbnail_width = Some(thumbnail_width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn set_thumbnail_height(mut self, thumbnail_height: i64) -> Self {
        self.thumbnail_height = Some(thumbnail_height);
        self
    }
    pub fn build(self) -> InlineQueryResultArticle {
        InlineQueryResultArticle {
            tg_type: self.tg_type,
            id: self.id,
            title: self.title,
            input_message_content: self.input_message_content,
            reply_markup: self.reply_markup,
            url: self.url,
            hide_url: self.hide_url,
            description: self.description,
            thumbnail_url: self.thumbnail_url,
            thumbnail_width: self.thumbnail_width,
            thumbnail_height: self.thumbnail_height,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum PassportElementError {
    PassportElementErrorDataField(PassportElementErrorDataField),
    PassportElementErrorFrontSide(PassportElementErrorFrontSide),
    PassportElementErrorReverseSide(PassportElementErrorReverseSide),
    PassportElementErrorSelfie(PassportElementErrorSelfie),
    PassportElementErrorFile(PassportElementErrorFile),
    PassportElementErrorFiles(PassportElementErrorFiles),
    PassportElementErrorTranslationFile(PassportElementErrorTranslationFile),
    PassportElementErrorTranslationFiles(PassportElementErrorTranslationFiles),
    PassportElementErrorUnspecified(PassportElementErrorUnspecified),
}
impl Default for PassportElementError {
    fn default() -> Self {
        PassportElementError::PassportElementErrorDataField(PassportElementErrorDataField::default())
    }
}
impl PassportElementError {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message<'a>(&'a self) -> Cow<'a, str> {
        match self {
            Self::PassportElementErrorDataField(ref v) => v.get_message(),
            Self::PassportElementErrorFrontSide(ref v) => v.get_message(),
            Self::PassportElementErrorReverseSide(ref v) => v.get_message(),
            Self::PassportElementErrorSelfie(ref v) => v.get_message(),
            Self::PassportElementErrorFile(ref v) => v.get_message(),
            Self::PassportElementErrorFiles(ref v) => v.get_message(),
            Self::PassportElementErrorTranslationFile(ref v) => v.get_message(),
            Self::PassportElementErrorTranslationFiles(ref v) => v.get_message(),
            Self::PassportElementErrorUnspecified(ref v) => v.get_message(),
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum GeneralForumTopicHidden {}
impl GeneralForumTopicHidden {}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes an inline message sent by a Web App on behalf of a user."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SentWebAppMessage {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "inline_message_id",
        default
    )]
    inline_message_id: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to SentWebAppMessage that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipSentWebAppMessage {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."]
    inline_message_id: Option<String>,
}
impl From<NoSkipSentWebAppMessage> for SentWebAppMessage {
    fn from(t: NoSkipSentWebAppMessage) -> Self {
        Self {
            inline_message_id: t.inline_message_id,
        }
    }
}
impl Into<NoSkipSentWebAppMessage> for SentWebAppMessage {
    fn into(self) -> NoSkipSentWebAppMessage {
        NoSkipSentWebAppMessage {
            inline_message_id: self.inline_message_id,
        }
    }
}
impl NoSkipSentWebAppMessage {
    pub fn skip(self) -> SentWebAppMessage {
        self.into()
    }
}
impl SentWebAppMessage {
    pub fn noskip(self) -> NoSkipSentWebAppMessage {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes an inline message sent by a Web App on behalf of a user."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SentWebAppMessageBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "inline_message_id",
        default
    )]
    inline_message_id: Option<String>,
}
impl SentWebAppMessageBuilder {
    pub fn new() -> Self {
        Self {
            inline_message_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."]
    pub fn set_inline_message_id(mut self, inline_message_id: String) -> Self {
        self.inline_message_id = Some(inline_message_id);
        self
    }
    pub fn build(self) -> SentWebAppMessage {
        SentWebAppMessage {
            inline_message_id: self.inline_message_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about new members invited to a video chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VideoChatParticipantsInvited {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New members that were invited to the video chat"]
    #[serde(rename = "users")]
    users: Vec<User>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to VideoChatParticipantsInvited that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipVideoChatParticipantsInvited {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New members that were invited to the video chat"]
    #[serde(rename = "users")]
    users: Vec<User>,
}
impl From<NoSkipVideoChatParticipantsInvited> for VideoChatParticipantsInvited {
    fn from(t: NoSkipVideoChatParticipantsInvited) -> Self {
        Self { users: t.users }
    }
}
impl Into<NoSkipVideoChatParticipantsInvited> for VideoChatParticipantsInvited {
    fn into(self) -> NoSkipVideoChatParticipantsInvited {
        NoSkipVideoChatParticipantsInvited { users: self.users }
    }
}
impl NoSkipVideoChatParticipantsInvited {
    pub fn skip(self) -> VideoChatParticipantsInvited {
        self.into()
    }
}
impl VideoChatParticipantsInvited {
    pub fn noskip(self) -> NoSkipVideoChatParticipantsInvited {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about new members invited to a video chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VideoChatParticipantsInvitedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New members that were invited to the video chat"]
    #[serde(rename = "users")]
    users: Vec<User>,
}
impl VideoChatParticipantsInvitedBuilder {
    pub fn new(users: Vec<User>) -> Self {
        Self { users }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New members that were invited to the video chat"]
    pub fn set_users(mut self, users: Vec<User>) -> Self {
        self.users = users;
        self
    }
    pub fn build(self) -> VideoChatParticipantsInvited {
        VideoChatParticipantsInvited { users: self.users }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one button of an inline keyboard. You must use exactly one of the optional fields."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineKeyboardButton {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "url", default)]
    url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "callback_data",
        default
    )]
    callback_data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "web_app", default)]
    web_app: Option<WebAppInfo>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "login_url", default)]
    login_url: Option<LoginUrl>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "switch_inline_query",
        default
    )]
    switch_inline_query: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "switch_inline_query_current_chat",
        default
    )]
    switch_inline_query_current_chat: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "switch_inline_query_chosen_chat",
        default
    )]
    switch_inline_query_chosen_chat: Option<SwitchInlineQueryChosenChat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "callback_game",
        default
    )]
    callback_game: Option<CallbackGame>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "pay", default)]
    pay: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineKeyboardButton that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineKeyboardButton {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."]
    url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"]
    callback_data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."]
    web_app: Option<WebAppInfo>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."]
    login_url: Option<LoginUrl>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."]
    switch_inline_query: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."]
    switch_inline_query_current_chat: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"]
    switch_inline_query_chosen_chat: Option<SwitchInlineQueryChosenChat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."]
    callback_game: Option<CallbackGame>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."]
    pay: Option<bool>,
}
impl From<NoSkipInlineKeyboardButton> for InlineKeyboardButton {
    fn from(t: NoSkipInlineKeyboardButton) -> Self {
        Self {
            text: t.text,
            url: t.url,
            callback_data: t.callback_data,
            web_app: t.web_app,
            login_url: t.login_url,
            switch_inline_query: t.switch_inline_query,
            switch_inline_query_current_chat: t.switch_inline_query_current_chat,
            switch_inline_query_chosen_chat: t.switch_inline_query_chosen_chat,
            callback_game: t.callback_game,
            pay: t.pay,
        }
    }
}
impl Into<NoSkipInlineKeyboardButton> for InlineKeyboardButton {
    fn into(self) -> NoSkipInlineKeyboardButton {
        NoSkipInlineKeyboardButton {
            text: self.text,
            url: self.url,
            callback_data: self.callback_data,
            web_app: self.web_app,
            login_url: self.login_url,
            switch_inline_query: self.switch_inline_query,
            switch_inline_query_current_chat: self.switch_inline_query_current_chat,
            switch_inline_query_chosen_chat: self.switch_inline_query_chosen_chat,
            callback_game: self.callback_game,
            pay: self.pay,
        }
    }
}
impl NoSkipInlineKeyboardButton {
    pub fn skip(self) -> InlineKeyboardButton {
        self.into()
    }
}
impl InlineKeyboardButton {
    pub fn noskip(self) -> NoSkipInlineKeyboardButton {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one button of an inline keyboard. You must use exactly one of the optional fields."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineKeyboardButtonBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    #[serde(rename = "text")]
    text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "url", default)]
    url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "callback_data",
        default
    )]
    callback_data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "web_app", default)]
    web_app: Option<WebAppInfo>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "login_url", default)]
    login_url: Option<LoginUrl>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "switch_inline_query",
        default
    )]
    switch_inline_query: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "switch_inline_query_current_chat",
        default
    )]
    switch_inline_query_current_chat: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "switch_inline_query_chosen_chat",
        default
    )]
    switch_inline_query_chosen_chat: Option<SwitchInlineQueryChosenChat>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "callback_game",
        default
    )]
    callback_game: Option<CallbackGame>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "pay", default)]
    pay: Option<bool>,
}
impl InlineKeyboardButtonBuilder {
    pub fn new(text: String) -> Self {
        Self {
            text,
            url: None,
            callback_data: None,
            web_app: None,
            login_url: None,
            switch_inline_query: None,
            switch_inline_query_current_chat: None,
            switch_inline_query_chosen_chat: None,
            callback_game: None,
            pay: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    pub fn set_text(mut self, text: String) -> Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."]
    pub fn set_url(mut self, url: String) -> Self {
        self.url = Some(url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"]
    pub fn set_callback_data(mut self, callback_data: String) -> Self {
        self.callback_data = Some(callback_data);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."]
    pub fn set_web_app(mut self, web_app: WebAppInfo) -> Self {
        self.web_app = Some(web_app);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."]
    pub fn set_login_url(mut self, login_url: LoginUrl) -> Self {
        self.login_url = Some(login_url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."]
    pub fn set_switch_inline_query(mut self, switch_inline_query: String) -> Self {
        self.switch_inline_query = Some(switch_inline_query);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."]
    pub fn set_switch_inline_query_current_chat(
        mut self,
        switch_inline_query_current_chat: String,
    ) -> Self {
        self.switch_inline_query_current_chat = Some(switch_inline_query_current_chat);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"]
    pub fn set_switch_inline_query_chosen_chat(
        mut self,
        switch_inline_query_chosen_chat: SwitchInlineQueryChosenChat,
    ) -> Self {
        self.switch_inline_query_chosen_chat = Some(switch_inline_query_chosen_chat);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."]
    pub fn set_callback_game(mut self, callback_game: CallbackGame) -> Self {
        self.callback_game = Some(callback_game);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."]
    pub fn set_pay(mut self, pay: bool) -> Self {
        self.pay = Some(pay);
        self
    }
    pub fn build(self) -> InlineKeyboardButton {
        InlineKeyboardButton {
            text: self.text,
            url: self.url,
            callback_data: self.callback_data,
            web_app: self.web_app,
            login_url: self.login_url,
            switch_inline_query: self.switch_inline_query,
            switch_inline_query_current_chat: self.switch_inline_query_current_chat,
            switch_inline_query_chosen_chat: self.switch_inline_query_chosen_chat,
            callback_game: self.callback_game,
            pay: self.pay,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum InlineQueryResult {
    InlineQueryResultCachedAudio(InlineQueryResultCachedAudio),
    InlineQueryResultCachedDocument(InlineQueryResultCachedDocument),
    InlineQueryResultCachedGif(InlineQueryResultCachedGif),
    InlineQueryResultCachedMpeg4Gif(InlineQueryResultCachedMpeg4Gif),
    InlineQueryResultCachedPhoto(InlineQueryResultCachedPhoto),
    InlineQueryResultCachedSticker(InlineQueryResultCachedSticker),
    InlineQueryResultCachedVideo(InlineQueryResultCachedVideo),
    InlineQueryResultCachedVoice(InlineQueryResultCachedVoice),
    InlineQueryResultArticle(InlineQueryResultArticle),
    InlineQueryResultAudio(InlineQueryResultAudio),
    InlineQueryResultContact(InlineQueryResultContact),
    InlineQueryResultGame(InlineQueryResultGame),
    InlineQueryResultDocument(InlineQueryResultDocument),
    InlineQueryResultGif(InlineQueryResultGif),
    InlineQueryResultLocation(InlineQueryResultLocation),
    InlineQueryResultMpeg4Gif(InlineQueryResultMpeg4Gif),
    InlineQueryResultPhoto(InlineQueryResultPhoto),
    InlineQueryResultVenue(InlineQueryResultVenue),
    InlineQueryResultVideo(InlineQueryResultVideo),
    InlineQueryResultVoice(InlineQueryResultVoice),
}
impl Default for InlineQueryResult {
    fn default() -> Self {
        InlineQueryResult::InlineQueryResultCachedAudio(InlineQueryResultCachedAudio::default())
    }
}
impl InlineQueryResult {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        match self {
            Self::InlineQueryResultCachedAudio(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultCachedDocument(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultCachedGif(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultCachedMpeg4Gif(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultCachedPhoto(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultCachedSticker(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultCachedVideo(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultCachedVoice(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultArticle(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultAudio(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultContact(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultGame(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultDocument(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultGif(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultLocation(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultMpeg4Gif(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultPhoto(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultVenue(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultVideo(ref v) => v.get_reply_markup(),
            Self::InlineQueryResultVoice(ref v) => v.get_reply_markup(),
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about the chat whose identifier was shared with the bot using a KeyboardButtonRequestChat button."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatShared {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."]
    #[serde(rename = "chat_id")]
    chat_id: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatShared that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatShared {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."]
    #[serde(rename = "chat_id")]
    chat_id: i64,
}
impl From<NoSkipChatShared> for ChatShared {
    fn from(t: NoSkipChatShared) -> Self {
        Self {
            request_id: t.request_id,
            chat_id: t.chat_id,
        }
    }
}
impl Into<NoSkipChatShared> for ChatShared {
    fn into(self) -> NoSkipChatShared {
        NoSkipChatShared {
            request_id: self.request_id,
            chat_id: self.chat_id,
        }
    }
}
impl NoSkipChatShared {
    pub fn skip(self) -> ChatShared {
        self.into()
    }
}
impl ChatShared {
    pub fn noskip(self) -> NoSkipChatShared {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains information about the chat whose identifier was shared with the bot using a KeyboardButtonRequestChat button."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatSharedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."]
    #[serde(rename = "chat_id")]
    chat_id: i64,
}
impl ChatSharedBuilder {
    pub fn new(request_id: i64, chat_id: i64) -> Self {
        Self {
            request_id,
            chat_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    pub fn set_request_id(mut self, request_id: i64) -> Self {
        self.request_id = request_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."]
    pub fn set_chat_id(mut self, chat_id: i64) -> Self {
        self.chat_id = chat_id;
        self
    }
    pub fn build(self) -> ChatShared {
        ChatShared {
            request_id: self.request_id,
            chat_id: self.chat_id,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a video animation (H.264/MPEG-4 AVC video without sound). By default, this animated MPEG-4 file will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultMpeg4Gif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    #[serde(rename = "mpeg4_url")]
    mpeg_4_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "mpeg4_width",
        default
    )]
    mpeg_4_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "mpeg4_height",
        default
    )]
    mpeg_4_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "mpeg4_duration",
        default
    )]
    mpeg_4_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_mime_type",
        default
    )]
    thumbnail_mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultMpeg4Gif that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultMpeg4Gif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    #[serde(rename = "mpeg4_url")]
    mpeg_4_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    mpeg_4_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    mpeg_4_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    mpeg_4_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    thumbnail_mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultMpeg4Gif> for InlineQueryResultMpeg4Gif {
    fn from(t: NoSkipInlineQueryResultMpeg4Gif) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            mpeg_4_url: t.mpeg_4_url,
            mpeg_4_width: t.mpeg_4_width,
            mpeg_4_height: t.mpeg_4_height,
            mpeg_4_duration: t.mpeg_4_duration,
            thumbnail_url: t.thumbnail_url,
            thumbnail_mime_type: t.thumbnail_mime_type,
            title: t.title,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultMpeg4Gif> for InlineQueryResultMpeg4Gif {
    fn into(self) -> NoSkipInlineQueryResultMpeg4Gif {
        NoSkipInlineQueryResultMpeg4Gif {
            tg_type: self.tg_type,
            id: self.id,
            mpeg_4_url: self.mpeg_4_url,
            mpeg_4_width: self.mpeg_4_width,
            mpeg_4_height: self.mpeg_4_height,
            mpeg_4_duration: self.mpeg_4_duration,
            thumbnail_url: self.thumbnail_url,
            thumbnail_mime_type: self.thumbnail_mime_type,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultMpeg4Gif {
    pub fn skip(self) -> InlineQueryResultMpeg4Gif {
        self.into()
    }
}
impl InlineQueryResultMpeg4Gif {
    pub fn noskip(self) -> NoSkipInlineQueryResultMpeg4Gif {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a video animation (H.264/MPEG-4 AVC video without sound). By default, this animated MPEG-4 file will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultMpeg4GifBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    #[serde(rename = "mpeg4_url")]
    mpeg_4_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "mpeg4_width",
        default
    )]
    mpeg_4_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "mpeg4_height",
        default
    )]
    mpeg_4_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "mpeg4_duration",
        default
    )]
    mpeg_4_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_mime_type",
        default
    )]
    thumbnail_mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultMpeg4GifBuilder {
    pub fn new(id: String, mpeg_4_url: String, thumbnail_url: String) -> Self {
        Self {
            tg_type: "mpeg4_gif".to_owned(),
            id,
            mpeg_4_url,
            thumbnail_url,
            mpeg_4_width: None,
            mpeg_4_height: None,
            mpeg_4_duration: None,
            thumbnail_mime_type: None,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    pub fn set_mpeg_4_url(mut self, mpeg_4_url: String) -> Self {
        self.mpeg_4_url = mpeg_4_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn set_mpeg_4_width(mut self, mpeg_4_width: i64) -> Self {
        self.mpeg_4_width = Some(mpeg_4_width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn set_mpeg_4_height(mut self, mpeg_4_height: i64) -> Self {
        self.mpeg_4_height = Some(mpeg_4_height);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn set_mpeg_4_duration(mut self, mpeg_4_duration: i64) -> Self {
        self.mpeg_4_duration = Some(mpeg_4_duration);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    pub fn set_thumbnail_url(mut self, thumbnail_url: String) -> Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    pub fn set_thumbnail_mime_type(mut self, thumbnail_mime_type: String) -> Self {
        self.thumbnail_mime_type = Some(thumbnail_mime_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultMpeg4Gif {
        InlineQueryResultMpeg4Gif {
            tg_type: self.tg_type,
            id: self.id,
            mpeg_4_url: self.mpeg_4_url,
            mpeg_4_width: self.mpeg_4_width,
            mpeg_4_height: self.mpeg_4_height,
            mpeg_4_duration: self.mpeg_4_duration,
            thumbnail_url: self.thumbnail_url,
            thumbnail_mime_type: self.thumbnail_mime_type,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a shipping address."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ShippingAddress {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Two-letter ISO 3166-1 alpha-2 country code"]
    #[serde(rename = "country_code")]
    country_code: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "State, if applicable"]
    #[serde(rename = "state")]
    state: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "City"]
    #[serde(rename = "city")]
    city: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "First line for the address"]
    #[serde(rename = "street_line1")]
    street_line_1: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Second line for the address"]
    #[serde(rename = "street_line2")]
    street_line_2: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address post code"]
    #[serde(rename = "post_code")]
    post_code: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ShippingAddress that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipShippingAddress {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Two-letter ISO 3166-1 alpha-2 country code"]
    #[serde(rename = "country_code")]
    country_code: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "State, if applicable"]
    #[serde(rename = "state")]
    state: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "City"]
    #[serde(rename = "city")]
    city: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "First line for the address"]
    #[serde(rename = "street_line1")]
    street_line_1: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Second line for the address"]
    #[serde(rename = "street_line2")]
    street_line_2: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address post code"]
    #[serde(rename = "post_code")]
    post_code: String,
}
impl From<NoSkipShippingAddress> for ShippingAddress {
    fn from(t: NoSkipShippingAddress) -> Self {
        Self {
            country_code: t.country_code,
            state: t.state,
            city: t.city,
            street_line_1: t.street_line_1,
            street_line_2: t.street_line_2,
            post_code: t.post_code,
        }
    }
}
impl Into<NoSkipShippingAddress> for ShippingAddress {
    fn into(self) -> NoSkipShippingAddress {
        NoSkipShippingAddress {
            country_code: self.country_code,
            state: self.state,
            city: self.city,
            street_line_1: self.street_line_1,
            street_line_2: self.street_line_2,
            post_code: self.post_code,
        }
    }
}
impl NoSkipShippingAddress {
    pub fn skip(self) -> ShippingAddress {
        self.into()
    }
}
impl ShippingAddress {
    pub fn noskip(self) -> NoSkipShippingAddress {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a shipping address."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ShippingAddressBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Two-letter ISO 3166-1 alpha-2 country code"]
    #[serde(rename = "country_code")]
    country_code: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "State, if applicable"]
    #[serde(rename = "state")]
    state: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "City"]
    #[serde(rename = "city")]
    city: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "First line for the address"]
    #[serde(rename = "street_line1")]
    street_line_1: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Second line for the address"]
    #[serde(rename = "street_line2")]
    street_line_2: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address post code"]
    #[serde(rename = "post_code")]
    post_code: String,
}
impl ShippingAddressBuilder {
    pub fn new(
        country_code: String,
        state: String,
        city: String,
        street_line_1: String,
        street_line_2: String,
        post_code: String,
    ) -> Self {
        Self {
            country_code,
            state,
            city,
            street_line_1,
            street_line_2,
            post_code,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Two-letter ISO 3166-1 alpha-2 country code"]
    pub fn set_country_code(mut self, country_code: String) -> Self {
        self.country_code = country_code;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "State, if applicable"]
    pub fn set_state(mut self, state: String) -> Self {
        self.state = state;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "City"]
    pub fn set_city(mut self, city: String) -> Self {
        self.city = city;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "First line for the address"]
    pub fn set_street_line_1(mut self, street_line_1: String) -> Self {
        self.street_line_1 = street_line_1;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Second line for the address"]
    pub fn set_street_line_2(mut self, street_line_2: String) -> Self {
        self.street_line_2 = street_line_2;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address post code"]
    pub fn set_post_code(mut self, post_code: String) -> Self {
        self.post_code = post_code;
        self
    }
    pub fn build(self) -> ShippingAddress {
        ShippingAddress {
            country_code: self.country_code,
            state: self.state,
            city: self.city,
            street_line_1: self.street_line_1,
            street_line_2: self.street_line_2,
            post_code: self.post_code,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue in one of the data fields that was provided by the user. The error is considered resolved when the field's value changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorDataField {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    #[serde(rename = "field_name")]
    field_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    #[serde(rename = "data_hash")]
    data_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportElementErrorDataField that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportElementErrorDataField {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    #[serde(rename = "field_name")]
    field_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    #[serde(rename = "data_hash")]
    data_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl From<NoSkipPassportElementErrorDataField> for PassportElementErrorDataField {
    fn from(t: NoSkipPassportElementErrorDataField) -> Self {
        Self {
            source: t.source,
            tg_type: t.tg_type,
            field_name: t.field_name,
            data_hash: t.data_hash,
            message: t.message,
        }
    }
}
impl Into<NoSkipPassportElementErrorDataField> for PassportElementErrorDataField {
    fn into(self) -> NoSkipPassportElementErrorDataField {
        NoSkipPassportElementErrorDataField {
            source: self.source,
            tg_type: self.tg_type,
            field_name: self.field_name,
            data_hash: self.data_hash,
            message: self.message,
        }
    }
}
impl NoSkipPassportElementErrorDataField {
    pub fn skip(self) -> PassportElementErrorDataField {
        self.into()
    }
}
impl PassportElementErrorDataField {
    pub fn noskip(self) -> NoSkipPassportElementErrorDataField {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue in one of the data fields that was provided by the user. The error is considered resolved when the field's value changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorDataFieldBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    #[serde(rename = "field_name")]
    field_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    #[serde(rename = "data_hash")]
    data_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl PassportElementErrorDataFieldBuilder {
    pub fn new(source: String, field_name: String, data_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorDataField".to_owned(),
            source,
            field_name,
            data_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    pub fn set_source(mut self, source: String) -> Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    pub fn set_field_name(mut self, field_name: String) -> Self {
        self.field_name = field_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    pub fn set_data_hash(mut self, data_hash: String) -> Self {
        self.data_hash = data_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message(mut self, message: String) -> Self {
        self.message = message;
        self
    }
    pub fn build(self) -> PassportElementErrorDataField {
        PassportElementErrorDataField {
            source: self.source,
            tg_type: self.tg_type,
            field_name: self.field_name,
            data_hash: self.data_hash,
            message: self.message,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an animated emoji that displays a random value."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Dice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Emoji on which the dice throw animation is based"]
    #[serde(rename = "emoji")]
    emoji: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Value of the dice, 1-6 for \"\", \"\" and \"\" base emoji, 1-5 for \"\" and \"\" base emoji, 1-64 for \"\" base emoji"]
    #[serde(rename = "value")]
    value: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Dice that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipDice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Emoji on which the dice throw animation is based"]
    #[serde(rename = "emoji")]
    emoji: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Value of the dice, 1-6 for \"\", \"\" and \"\" base emoji, 1-5 for \"\" and \"\" base emoji, 1-64 for \"\" base emoji"]
    #[serde(rename = "value")]
    value: i64,
}
impl From<NoSkipDice> for Dice {
    fn from(t: NoSkipDice) -> Self {
        Self {
            emoji: t.emoji,
            value: t.value,
        }
    }
}
impl Into<NoSkipDice> for Dice {
    fn into(self) -> NoSkipDice {
        NoSkipDice {
            emoji: self.emoji,
            value: self.value,
        }
    }
}
impl NoSkipDice {
    pub fn skip(self) -> Dice {
        self.into()
    }
}
impl Dice {
    pub fn noskip(self) -> NoSkipDice {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an animated emoji that displays a random value."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct DiceBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Emoji on which the dice throw animation is based"]
    #[serde(rename = "emoji")]
    emoji: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Value of the dice, 1-6 for \"\", \"\" and \"\" base emoji, 1-5 for \"\" and \"\" base emoji, 1-64 for \"\" base emoji"]
    #[serde(rename = "value")]
    value: i64,
}
impl DiceBuilder {
    pub fn new(emoji: String, value: i64) -> Self {
        Self { emoji, value }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Emoji on which the dice throw animation is based"]
    pub fn set_emoji(mut self, emoji: String) -> Self {
        self.emoji = emoji;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Value of the dice, 1-6 for \"\", \"\" and \"\" base emoji, 1-5 for \"\" and \"\" base emoji, 1-64 for \"\" base emoji"]
    pub fn set_value(mut self, value: i64) -> Self {
        self.value = value;
        self
    }
    pub fn build(self) -> Dice {
        Dice {
            emoji: self.emoji,
            value: self.value,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with one of the files that constitute the translation of a document. The error is considered resolved when the file changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorTranslationFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportElementErrorTranslationFile that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportElementErrorTranslationFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl From<NoSkipPassportElementErrorTranslationFile> for PassportElementErrorTranslationFile {
    fn from(t: NoSkipPassportElementErrorTranslationFile) -> Self {
        Self {
            source: t.source,
            tg_type: t.tg_type,
            file_hash: t.file_hash,
            message: t.message,
        }
    }
}
impl Into<NoSkipPassportElementErrorTranslationFile> for PassportElementErrorTranslationFile {
    fn into(self) -> NoSkipPassportElementErrorTranslationFile {
        NoSkipPassportElementErrorTranslationFile {
            source: self.source,
            tg_type: self.tg_type,
            file_hash: self.file_hash,
            message: self.message,
        }
    }
}
impl NoSkipPassportElementErrorTranslationFile {
    pub fn skip(self) -> PassportElementErrorTranslationFile {
        self.into()
    }
}
impl PassportElementErrorTranslationFile {
    pub fn noskip(self) -> NoSkipPassportElementErrorTranslationFile {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with one of the files that constitute the translation of a document. The error is considered resolved when the file changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorTranslationFileBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl PassportElementErrorTranslationFileBuilder {
    pub fn new(source: String, file_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorTranslationFile".to_owned(),
            source,
            file_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    pub fn set_source(mut self, source: String) -> Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    pub fn set_file_hash(mut self, file_hash: String) -> Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message(mut self, message: String) -> Self {
        self.message = message;
        self
    }
    pub fn build(self) -> PassportElementErrorTranslationFile {
        PassportElementErrorTranslationFile {
            source: self.source,
            tg_type: self.tg_type,
            file_hash: self.file_hash,
            message: self.message,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about a video chat scheduled in the chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VideoChatScheduled {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"]
    #[serde(rename = "start_date")]
    start_date: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to VideoChatScheduled that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipVideoChatScheduled {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"]
    #[serde(rename = "start_date")]
    start_date: i64,
}
impl From<NoSkipVideoChatScheduled> for VideoChatScheduled {
    fn from(t: NoSkipVideoChatScheduled) -> Self {
        Self {
            start_date: t.start_date,
        }
    }
}
impl Into<NoSkipVideoChatScheduled> for VideoChatScheduled {
    fn into(self) -> NoSkipVideoChatScheduled {
        NoSkipVideoChatScheduled {
            start_date: self.start_date,
        }
    }
}
impl NoSkipVideoChatScheduled {
    pub fn skip(self) -> VideoChatScheduled {
        self.into()
    }
}
impl VideoChatScheduled {
    pub fn noskip(self) -> NoSkipVideoChatScheduled {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about a video chat scheduled in the chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VideoChatScheduledBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"]
    #[serde(rename = "start_date")]
    start_date: i64,
}
impl VideoChatScheduledBuilder {
    pub fn new(start_date: i64) -> Self {
        Self { start_date }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"]
    pub fn set_start_date(mut self, start_date: i64) -> Self {
        self.start_date = start_date;
        self
    }
    pub fn build(self) -> VideoChatScheduled {
        VideoChatScheduled {
            start_date: self.start_date,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one shipping option."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ShippingOption {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shipping option identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of price portions"]
    #[serde(rename = "prices")]
    prices: Vec<LabeledPrice>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ShippingOption that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipShippingOption {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shipping option identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of price portions"]
    #[serde(rename = "prices")]
    prices: Vec<LabeledPrice>,
}
impl From<NoSkipShippingOption> for ShippingOption {
    fn from(t: NoSkipShippingOption) -> Self {
        Self {
            id: t.id,
            title: t.title,
            prices: t.prices,
        }
    }
}
impl Into<NoSkipShippingOption> for ShippingOption {
    fn into(self) -> NoSkipShippingOption {
        NoSkipShippingOption {
            id: self.id,
            title: self.title,
            prices: self.prices,
        }
    }
}
impl NoSkipShippingOption {
    pub fn skip(self) -> ShippingOption {
        self.into()
    }
}
impl ShippingOption {
    pub fn noskip(self) -> NoSkipShippingOption {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one shipping option."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ShippingOptionBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shipping option identifier"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of price portions"]
    #[serde(rename = "prices")]
    prices: Vec<LabeledPrice>,
}
impl ShippingOptionBuilder {
    pub fn new(id: String, title: String, prices: Vec<LabeledPrice>) -> Self {
        Self { id, title, prices }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shipping option identifier"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option title"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of price portions"]
    pub fn set_prices(mut self, prices: Vec<LabeledPrice>) -> Self {
        self.prices = prices;
        self
    }
    pub fn build(self) -> ShippingOption {
        ShippingOption {
            id: self.id,
            title: self.title,
            prices: self.prices,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes a Web App."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WebAppInfo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"]
    #[serde(rename = "url")]
    url: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to WebAppInfo that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipWebAppInfo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"]
    #[serde(rename = "url")]
    url: String,
}
impl From<NoSkipWebAppInfo> for WebAppInfo {
    fn from(t: NoSkipWebAppInfo) -> Self {
        Self { url: t.url }
    }
}
impl Into<NoSkipWebAppInfo> for WebAppInfo {
    fn into(self) -> NoSkipWebAppInfo {
        NoSkipWebAppInfo { url: self.url }
    }
}
impl NoSkipWebAppInfo {
    pub fn skip(self) -> WebAppInfo {
        self.into()
    }
}
impl WebAppInfo {
    pub fn noskip(self) -> NoSkipWebAppInfo {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes a Web App."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WebAppInfoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"]
    #[serde(rename = "url")]
    url: String,
}
impl WebAppInfoBuilder {
    pub fn new(url: String) -> Self {
        Self { url }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"]
    pub fn set_url(mut self, url: String) -> Self {
        self.url = url;
        self
    }
    pub fn build(self) -> WebAppInfo {
        WebAppInfo { url: self.url }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that was banned in the chat and can't return to the chat or view chat messages."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberBanned {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    #[serde(rename = "until_date")]
    until_date: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatMemberBanned that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatMemberBanned {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    #[serde(rename = "until_date")]
    until_date: i64,
}
impl From<NoSkipChatMemberBanned> for ChatMemberBanned {
    fn from(t: NoSkipChatMemberBanned) -> Self {
        Self {
            user: t.user,
            until_date: t.until_date,
        }
    }
}
impl Into<NoSkipChatMemberBanned> for ChatMemberBanned {
    fn into(self) -> NoSkipChatMemberBanned {
        NoSkipChatMemberBanned {
            user: self.user,
            until_date: self.until_date,
        }
    }
}
impl NoSkipChatMemberBanned {
    pub fn skip(self) -> ChatMemberBanned {
        self.into()
    }
}
impl ChatMemberBanned {
    pub fn noskip(self) -> NoSkipChatMemberBanned {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that was banned in the chat and can't return to the chat or view chat messages."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberBannedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    #[serde(rename = "until_date")]
    until_date: i64,
}
impl ChatMemberBannedBuilder {
    pub fn new(user: User, until_date: i64) -> Self {
        Self { user, until_date }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user(mut self, user: User) -> Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    pub fn set_until_date(mut self, until_date: i64) -> Self {
        self.until_date = until_date;
        self
    }
    pub fn build(self) -> ChatMemberBanned {
        ChatMemberBanned {
            user: self.user,
            until_date: self.until_date,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the default scope of bot commands. Default commands are used if no commands with a narrower scope are specified for the user."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeDefault {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    #[serde(rename = "type")]
    tg_type: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotCommandScopeDefault that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotCommandScopeDefault {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl From<NoSkipBotCommandScopeDefault> for BotCommandScopeDefault {
    fn from(t: NoSkipBotCommandScopeDefault) -> Self {
        Self { tg_type: t.tg_type }
    }
}
impl Into<NoSkipBotCommandScopeDefault> for BotCommandScopeDefault {
    fn into(self) -> NoSkipBotCommandScopeDefault {
        NoSkipBotCommandScopeDefault {
            tg_type: self.tg_type,
        }
    }
}
impl NoSkipBotCommandScopeDefault {
    pub fn skip(self) -> BotCommandScopeDefault {
        self.into()
    }
}
impl BotCommandScopeDefault {
    pub fn noskip(self) -> NoSkipBotCommandScopeDefault {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the default scope of bot commands. Default commands are used if no commands with a narrower scope are specified for the user."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeDefaultBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl BotCommandScopeDefaultBuilder {
    pub fn new() -> Self {
        Self {
            tg_type: "default".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    pub fn build(self) -> BotCommandScopeDefault {
        BotCommandScopeDefault {
            tg_type: self.tg_type,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes Telegram Passport data shared with the bot by the user."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportData {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array with information about documents and other Telegram Passport elements that was shared with the bot"]
    #[serde(rename = "data")]
    data: Vec<EncryptedPassportElement>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Encrypted credentials required to decrypt the data"]
    #[serde(rename = "credentials")]
    credentials: EncryptedCredentials,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportData that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportData {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array with information about documents and other Telegram Passport elements that was shared with the bot"]
    #[serde(rename = "data")]
    data: Vec<EncryptedPassportElement>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Encrypted credentials required to decrypt the data"]
    #[serde(rename = "credentials")]
    credentials: EncryptedCredentials,
}
impl From<NoSkipPassportData> for PassportData {
    fn from(t: NoSkipPassportData) -> Self {
        Self {
            data: t.data,
            credentials: t.credentials,
        }
    }
}
impl Into<NoSkipPassportData> for PassportData {
    fn into(self) -> NoSkipPassportData {
        NoSkipPassportData {
            data: self.data,
            credentials: self.credentials,
        }
    }
}
impl NoSkipPassportData {
    pub fn skip(self) -> PassportData {
        self.into()
    }
}
impl PassportData {
    pub fn noskip(self) -> NoSkipPassportData {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes Telegram Passport data shared with the bot by the user."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportDataBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array with information about documents and other Telegram Passport elements that was shared with the bot"]
    #[serde(rename = "data")]
    data: Vec<EncryptedPassportElement>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Encrypted credentials required to decrypt the data"]
    #[serde(rename = "credentials")]
    credentials: EncryptedCredentials,
}
impl PassportDataBuilder {
    pub fn new(data: Vec<EncryptedPassportElement>, credentials: EncryptedCredentials) -> Self {
        Self { data, credentials }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array with information about documents and other Telegram Passport elements that was shared with the bot"]
    pub fn set_data(mut self, data: Vec<EncryptedPassportElement>) -> Self {
        self.data = data;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Encrypted credentials required to decrypt the data"]
    pub fn set_credentials(mut self, credentials: EncryptedCredentials) -> Self {
        self.credentials = credentials;
        self
    }
    pub fn build(self) -> PassportData {
        PassportData {
            data: self.data,
            credentials: self.credentials,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object describes a sticker to be added to a sticker set."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputSticker {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "sticker")]
    sticker: InputFile,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of 1-20 emoji associated with the sticker"]
    #[serde(rename = "emoji_list")]
    emoji_list: Vec<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Position where the mask should be placed on faces. For \"mask\" stickers only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "mask_position",
        default
    )]
    mask_position: Option<MaskPosition>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For \"regular\" and \"custom_emoji\" stickers only."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "keywords", default)]
    keywords: Option<Vec<String>>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputSticker that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputSticker {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "sticker")]
    sticker: InputFile,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of 1-20 emoji associated with the sticker"]
    #[serde(rename = "emoji_list")]
    emoji_list: Vec<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Position where the mask should be placed on faces. For \"mask\" stickers only."]
    mask_position: Option<MaskPosition>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For \"regular\" and \"custom_emoji\" stickers only."]
    keywords: Option<Vec<String>>,
}
impl From<NoSkipInputSticker> for InputSticker {
    fn from(t: NoSkipInputSticker) -> Self {
        Self {
            sticker: t.sticker,
            emoji_list: t.emoji_list,
            mask_position: t.mask_position,
            keywords: t.keywords,
        }
    }
}
impl Into<NoSkipInputSticker> for InputSticker {
    fn into(self) -> NoSkipInputSticker {
        NoSkipInputSticker {
            sticker: self.sticker,
            emoji_list: self.emoji_list,
            mask_position: self.mask_position,
            keywords: self.keywords,
        }
    }
}
impl NoSkipInputSticker {
    pub fn skip(self) -> InputSticker {
        self.into()
    }
}
impl InputSticker {
    pub fn noskip(self) -> NoSkipInputSticker {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object describes a sticker to be added to a sticker set."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputStickerBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    #[serde(rename = "sticker")]
    sticker: InputFile,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of 1-20 emoji associated with the sticker"]
    #[serde(rename = "emoji_list")]
    emoji_list: Vec<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Position where the mask should be placed on faces. For \"mask\" stickers only."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "mask_position",
        default
    )]
    mask_position: Option<MaskPosition>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For \"regular\" and \"custom_emoji\" stickers only."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "keywords", default)]
    keywords: Option<Vec<String>>,
}
impl InputStickerBuilder {
    pub fn new(sticker: InputFile, emoji_list: Vec<String>) -> Self {
        Self {
            sticker,
            emoji_list,
            mask_position: None,
            keywords: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_sticker(mut self, sticker: InputFile) -> Self {
        self.sticker = sticker;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of 1-20 emoji associated with the sticker"]
    pub fn set_emoji_list(mut self, emoji_list: Vec<String>) -> Self {
        self.emoji_list = emoji_list;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Position where the mask should be placed on faces. For \"mask\" stickers only."]
    pub fn set_mask_position(mut self, mask_position: MaskPosition) -> Self {
        self.mask_position = Some(mask_position);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For \"regular\" and \"custom_emoji\" stickers only."]
    pub fn set_keywords(mut self, keywords: Vec<String>) -> Self {
        self.keywords = Some(keywords);
        self
    }
    pub fn build(self) -> InputSticker {
        InputSticker {
            sticker: self.sticker,
            emoji_list: self.emoji_list,
            mask_position: self.mask_position,
            keywords: self.keywords,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a location to which a chat is connected."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatLocation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The location to which the supergroup is connected. Can't be a live location."]
    #[serde(rename = "location")]
    location: Location,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location address; 1-64 characters, as defined by the chat owner"]
    #[serde(rename = "address")]
    address: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatLocation that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatLocation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The location to which the supergroup is connected. Can't be a live location."]
    #[serde(rename = "location")]
    location: Location,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location address; 1-64 characters, as defined by the chat owner"]
    #[serde(rename = "address")]
    address: String,
}
impl From<NoSkipChatLocation> for ChatLocation {
    fn from(t: NoSkipChatLocation) -> Self {
        Self {
            location: t.location,
            address: t.address,
        }
    }
}
impl Into<NoSkipChatLocation> for ChatLocation {
    fn into(self) -> NoSkipChatLocation {
        NoSkipChatLocation {
            location: self.location,
            address: self.address,
        }
    }
}
impl NoSkipChatLocation {
    pub fn skip(self) -> ChatLocation {
        self.into()
    }
}
impl ChatLocation {
    pub fn noskip(self) -> NoSkipChatLocation {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a location to which a chat is connected."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatLocationBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The location to which the supergroup is connected. Can't be a live location."]
    #[serde(rename = "location")]
    location: Location,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location address; 1-64 characters, as defined by the chat owner"]
    #[serde(rename = "address")]
    address: String,
}
impl ChatLocationBuilder {
    pub fn new(location: Location, address: String) -> Self {
        Self { location, address }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The location to which the supergroup is connected. Can't be a live location."]
    pub fn set_location(mut self, location: Location) -> Self {
        self.location = location;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location address; 1-64 characters, as defined by the chat owner"]
    pub fn set_address(mut self, address: String) -> Self {
        self.address = address;
        self
    }
    pub fn build(self) -> ChatLocation {
        ChatLocation {
            location: self.location,
            address: self.address,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum CallbackGame {}
impl CallbackGame {}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to an animated GIF file. By default, this animated GIF file will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultGif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    #[serde(rename = "gif_url")]
    gif_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "gif_width", default)]
    gif_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "gif_height",
        default
    )]
    gif_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "gif_duration",
        default
    )]
    gif_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_mime_type",
        default
    )]
    thumbnail_mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultGif that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultGif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    #[serde(rename = "gif_url")]
    gif_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    gif_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    gif_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    gif_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    thumbnail_mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultGif> for InlineQueryResultGif {
    fn from(t: NoSkipInlineQueryResultGif) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            gif_url: t.gif_url,
            gif_width: t.gif_width,
            gif_height: t.gif_height,
            gif_duration: t.gif_duration,
            thumbnail_url: t.thumbnail_url,
            thumbnail_mime_type: t.thumbnail_mime_type,
            title: t.title,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultGif> for InlineQueryResultGif {
    fn into(self) -> NoSkipInlineQueryResultGif {
        NoSkipInlineQueryResultGif {
            tg_type: self.tg_type,
            id: self.id,
            gif_url: self.gif_url,
            gif_width: self.gif_width,
            gif_height: self.gif_height,
            gif_duration: self.gif_duration,
            thumbnail_url: self.thumbnail_url,
            thumbnail_mime_type: self.thumbnail_mime_type,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultGif {
    pub fn skip(self) -> InlineQueryResultGif {
        self.into()
    }
}
impl InlineQueryResultGif {
    pub fn noskip(self) -> NoSkipInlineQueryResultGif {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to an animated GIF file. By default, this animated GIF file will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultGifBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    #[serde(rename = "gif_url")]
    gif_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "gif_width", default)]
    gif_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "gif_height",
        default
    )]
    gif_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "gif_duration",
        default
    )]
    gif_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_mime_type",
        default
    )]
    thumbnail_mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultGifBuilder {
    pub fn new(id: String, gif_url: String, thumbnail_url: String) -> Self {
        Self {
            tg_type: "gif".to_owned(),
            id,
            gif_url,
            thumbnail_url,
            gif_width: None,
            gif_height: None,
            gif_duration: None,
            thumbnail_mime_type: None,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    pub fn set_gif_url(mut self, gif_url: String) -> Self {
        self.gif_url = gif_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    pub fn set_gif_width(mut self, gif_width: i64) -> Self {
        self.gif_width = Some(gif_width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    pub fn set_gif_height(mut self, gif_height: i64) -> Self {
        self.gif_height = Some(gif_height);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    pub fn set_gif_duration(mut self, gif_duration: i64) -> Self {
        self.gif_duration = Some(gif_duration);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    pub fn set_thumbnail_url(mut self, thumbnail_url: String) -> Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    pub fn set_thumbnail_mime_type(mut self, thumbnail_mime_type: String) -> Self {
        self.thumbnail_mime_type = Some(thumbnail_mime_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultGif {
        InlineQueryResultGif {
            tg_type: self.tg_type,
            id: self.id,
            gif_url: self.gif_url,
            gif_width: self.gif_width,
            gif_height: self.gif_height,
            gif_duration: self.gif_duration,
            thumbnail_url: self.thumbnail_url,
            thumbnail_mime_type: self.thumbnail_mime_type,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents the bot's name."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotName {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's name"]
    #[serde(rename = "name")]
    name: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotName that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotName {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's name"]
    #[serde(rename = "name")]
    name: String,
}
impl From<NoSkipBotName> for BotName {
    fn from(t: NoSkipBotName) -> Self {
        Self { name: t.name }
    }
}
impl Into<NoSkipBotName> for BotName {
    fn into(self) -> NoSkipBotName {
        NoSkipBotName { name: self.name }
    }
}
impl NoSkipBotName {
    pub fn skip(self) -> BotName {
        self.into()
    }
}
impl BotName {
    pub fn noskip(self) -> NoSkipBotName {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents the bot's name."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotNameBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's name"]
    #[serde(rename = "name")]
    name: String,
}
impl BotNameBuilder {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's name"]
    pub fn set_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }
    pub fn build(self) -> BotName {
        BotName { name: self.name }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a video file."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Video {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_name", default)]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "mime_type", default)]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Video that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    file_size: Option<i64>,
}
impl From<NoSkipVideo> for Video {
    fn from(t: NoSkipVideo) -> Self {
        Self {
            file_id: t.file_id,
            file_unique_id: t.file_unique_id,
            width: t.width,
            height: t.height,
            duration: t.duration,
            thumbnail: t.thumbnail,
            file_name: t.file_name,
            mime_type: t.mime_type,
            file_size: t.file_size,
        }
    }
}
impl Into<NoSkipVideo> for Video {
    fn into(self) -> NoSkipVideo {
        NoSkipVideo {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            width: self.width,
            height: self.height,
            duration: self.duration,
            thumbnail: self.thumbnail,
            file_name: self.file_name,
            mime_type: self.mime_type,
            file_size: self.file_size,
        }
    }
}
impl NoSkipVideo {
    pub fn skip(self) -> Video {
        self.into()
    }
}
impl Video {
    pub fn noskip(self) -> NoSkipVideo {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a video file."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VideoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "thumbnail", default)]
    thumbnail: Option<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_name", default)]
    file_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "mime_type", default)]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
impl VideoBuilder {
    pub fn new(
        file_id: String,
        file_unique_id: String,
        width: i64,
        height: i64,
        duration: i64,
    ) -> Self {
        Self {
            file_id,
            file_unique_id,
            width,
            height,
            duration,
            thumbnail: None,
            file_name: None,
            mime_type: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id(mut self, file_id: String) -> Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id(mut self, file_unique_id: String) -> Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    pub fn set_width(mut self, width: i64) -> Self {
        self.width = width;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    pub fn set_height(mut self, height: i64) -> Self {
        self.height = height;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn set_duration(mut self, duration: i64) -> Self {
        self.duration = duration;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    pub fn set_thumbnail(mut self, thumbnail: PhotoSize) -> Self {
        self.thumbnail = Some(thumbnail);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn set_file_name(mut self, file_name: String) -> Self {
        self.file_name = Some(file_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn set_mime_type(mut self, mime_type: String) -> Self {
        self.mime_type = Some(mime_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size(mut self, file_size: i64) -> Self {
        self.file_size = Some(file_size);
        self
    }
    pub fn build(self) -> Video {
        Video {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            width: self.width,
            height: self.height,
            duration: self.duration,
            thumbnail: self.thumbnail,
            file_name: self.file_name,
            mime_type: self.mime_type,
            file_size: self.file_size,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the content of a text message to be sent as the result of an inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputTextMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    #[serde(rename = "message_text")]
    message_text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "entities", default)]
    entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "disable_web_page_preview",
        default
    )]
    disable_web_page_preview: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InputTextMessageContent that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInputTextMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    #[serde(rename = "message_text")]
    message_text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    disable_web_page_preview: Option<bool>,
}
impl From<NoSkipInputTextMessageContent> for InputTextMessageContent {
    fn from(t: NoSkipInputTextMessageContent) -> Self {
        Self {
            message_text: t.message_text,
            parse_mode: t.parse_mode,
            entities: t.entities,
            disable_web_page_preview: t.disable_web_page_preview,
        }
    }
}
impl Into<NoSkipInputTextMessageContent> for InputTextMessageContent {
    fn into(self) -> NoSkipInputTextMessageContent {
        NoSkipInputTextMessageContent {
            message_text: self.message_text,
            parse_mode: self.parse_mode,
            entities: self.entities,
            disable_web_page_preview: self.disable_web_page_preview,
        }
    }
}
impl NoSkipInputTextMessageContent {
    pub fn skip(self) -> InputTextMessageContent {
        self.into()
    }
}
impl InputTextMessageContent {
    pub fn noskip(self) -> NoSkipInputTextMessageContent {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the content of a text message to be sent as the result of an inline query."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InputTextMessageContentBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    #[serde(rename = "message_text")]
    message_text: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "entities", default)]
    entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "disable_web_page_preview",
        default
    )]
    disable_web_page_preview: Option<bool>,
}
impl InputTextMessageContentBuilder {
    pub fn new(message_text: String) -> Self {
        Self {
            message_text,
            parse_mode: None,
            entities: None,
            disable_web_page_preview: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    pub fn set_message_text(mut self, message_text: String) -> Self {
        self.message_text = message_text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    pub fn set_entities(mut self, entities: Vec<MessageEntity>) -> Self {
        self.entities = Some(entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    pub fn set_disable_web_page_preview(mut self, disable_web_page_preview: bool) -> Self {
        self.disable_web_page_preview = Some(disable_web_page_preview);
        self
    }
    pub fn build(self) -> InputTextMessageContent {
        InputTextMessageContent {
            message_text: self.message_text,
            parse_mode: self.parse_mode,
            entities: self.entities,
            disable_web_page_preview: self.disable_web_page_preview,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the Telegram servers. By default, this animated MPEG-4 file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedMpeg4Gif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    #[serde(rename = "mpeg4_file_id")]
    mpeg_4_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultCachedMpeg4Gif that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultCachedMpeg4Gif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    #[serde(rename = "mpeg4_file_id")]
    mpeg_4_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultCachedMpeg4Gif> for InlineQueryResultCachedMpeg4Gif {
    fn from(t: NoSkipInlineQueryResultCachedMpeg4Gif) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            mpeg_4_file_id: t.mpeg_4_file_id,
            title: t.title,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultCachedMpeg4Gif> for InlineQueryResultCachedMpeg4Gif {
    fn into(self) -> NoSkipInlineQueryResultCachedMpeg4Gif {
        NoSkipInlineQueryResultCachedMpeg4Gif {
            tg_type: self.tg_type,
            id: self.id,
            mpeg_4_file_id: self.mpeg_4_file_id,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultCachedMpeg4Gif {
    pub fn skip(self) -> InlineQueryResultCachedMpeg4Gif {
        self.into()
    }
}
impl InlineQueryResultCachedMpeg4Gif {
    pub fn noskip(self) -> NoSkipInlineQueryResultCachedMpeg4Gif {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the Telegram servers. By default, this animated MPEG-4 file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedMpeg4GifBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    #[serde(rename = "mpeg4_file_id")]
    mpeg_4_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultCachedMpeg4GifBuilder {
    pub fn new(id: String, mpeg_4_file_id: String) -> Self {
        Self {
            tg_type: "mpeg4_gif".to_owned(),
            id,
            mpeg_4_file_id,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    pub fn set_mpeg_4_file_id(mut self, mpeg_4_file_id: String) -> Self {
        self.mpeg_4_file_id = mpeg_4_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultCachedMpeg4Gif {
        InlineQueryResultCachedMpeg4Gif {
            tg_type: self.tg_type,
            id: self.id,
            mpeg_4_file_id: self.mpeg_4_file_id,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a file. By default, this file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the file. Currently, only .PDF and .ZIP files can be sent using this method.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    #[serde(rename = "document_url")]
    document_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    #[serde(rename = "mime_type")]
    mime_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_url",
        default
    )]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_width",
        default
    )]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_height",
        default
    )]
    thumbnail_height: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultDocument that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    #[serde(rename = "document_url")]
    document_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    #[serde(rename = "mime_type")]
    mime_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    thumbnail_height: Option<i64>,
}
impl From<NoSkipInlineQueryResultDocument> for InlineQueryResultDocument {
    fn from(t: NoSkipInlineQueryResultDocument) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            title: t.title,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            document_url: t.document_url,
            mime_type: t.mime_type,
            description: t.description,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
            thumbnail_url: t.thumbnail_url,
            thumbnail_width: t.thumbnail_width,
            thumbnail_height: t.thumbnail_height,
        }
    }
}
impl Into<NoSkipInlineQueryResultDocument> for InlineQueryResultDocument {
    fn into(self) -> NoSkipInlineQueryResultDocument {
        NoSkipInlineQueryResultDocument {
            tg_type: self.tg_type,
            id: self.id,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            document_url: self.document_url,
            mime_type: self.mime_type,
            description: self.description,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
            thumbnail_url: self.thumbnail_url,
            thumbnail_width: self.thumbnail_width,
            thumbnail_height: self.thumbnail_height,
        }
    }
}
impl NoSkipInlineQueryResultDocument {
    pub fn skip(self) -> InlineQueryResultDocument {
        self.into()
    }
}
impl InlineQueryResultDocument {
    pub fn noskip(self) -> NoSkipInlineQueryResultDocument {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a file. By default, this file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the file. Currently, only .PDF and .ZIP files can be sent using this method.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultDocumentBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    #[serde(rename = "document_url")]
    document_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    #[serde(rename = "mime_type")]
    mime_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_url",
        default
    )]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_width",
        default
    )]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_height",
        default
    )]
    thumbnail_height: Option<i64>,
}
impl InlineQueryResultDocumentBuilder {
    pub fn new(id: String, title: String, document_url: String, mime_type: String) -> Self {
        Self {
            tg_type: "document".to_owned(),
            id,
            title,
            document_url,
            mime_type,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            description: None,
            reply_markup: None,
            input_message_content: None,
            thumbnail_url: None,
            thumbnail_width: None,
            thumbnail_height: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    pub fn set_document_url(mut self, document_url: String) -> Self {
        self.document_url = document_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    pub fn set_mime_type(mut self, mime_type: String) -> Self {
        self.mime_type = mime_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    pub fn set_thumbnail_url(mut self, thumbnail_url: String) -> Self {
        self.thumbnail_url = Some(thumbnail_url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn set_thumbnail_width(mut self, thumbnail_width: i64) -> Self {
        self.thumbnail_width = Some(thumbnail_width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn set_thumbnail_height(mut self, thumbnail_height: i64) -> Self {
        self.thumbnail_height = Some(thumbnail_height);
        self
    }
    pub fn build(self) -> InlineQueryResultDocument {
        InlineQueryResultDocument {
            tg_type: self.tg_type,
            id: self.id,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            document_url: self.document_url,
            mime_type: self.mime_type,
            description: self.description,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
            thumbnail_url: self.thumbnail_url,
            thumbnail_width: self.thumbnail_width,
            thumbnail_height: self.thumbnail_height,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue in an unspecified place. The error is considered resolved when new data is added."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorUnspecified {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    #[serde(rename = "element_hash")]
    element_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportElementErrorUnspecified that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportElementErrorUnspecified {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    #[serde(rename = "element_hash")]
    element_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl From<NoSkipPassportElementErrorUnspecified> for PassportElementErrorUnspecified {
    fn from(t: NoSkipPassportElementErrorUnspecified) -> Self {
        Self {
            source: t.source,
            tg_type: t.tg_type,
            element_hash: t.element_hash,
            message: t.message,
        }
    }
}
impl Into<NoSkipPassportElementErrorUnspecified> for PassportElementErrorUnspecified {
    fn into(self) -> NoSkipPassportElementErrorUnspecified {
        NoSkipPassportElementErrorUnspecified {
            source: self.source,
            tg_type: self.tg_type,
            element_hash: self.element_hash,
            message: self.message,
        }
    }
}
impl NoSkipPassportElementErrorUnspecified {
    pub fn skip(self) -> PassportElementErrorUnspecified {
        self.into()
    }
}
impl PassportElementErrorUnspecified {
    pub fn noskip(self) -> NoSkipPassportElementErrorUnspecified {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue in an unspecified place. The error is considered resolved when new data is added."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorUnspecifiedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    #[serde(rename = "element_hash")]
    element_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl PassportElementErrorUnspecifiedBuilder {
    pub fn new(source: String, element_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorUnspecified".to_owned(),
            source,
            element_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    pub fn set_source(mut self, source: String) -> Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    pub fn set_element_hash(mut self, element_hash: String) -> Self {
        self.element_hash = element_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message(mut self, message: String) -> Self {
        self.message = message;
        self
    }
    pub fn build(self) -> PassportElementErrorUnspecified {
        PassportElementErrorUnspecified {
            source: self.source,
            tg_type: self.tg_type,
            element_hash: self.element_hash,
            message: self.message,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to an MP3 audio file stored on the Telegram servers. By default, this audio file will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the audio.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    #[serde(rename = "audio_file_id")]
    audio_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultCachedAudio that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultCachedAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    #[serde(rename = "audio_file_id")]
    audio_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultCachedAudio> for InlineQueryResultCachedAudio {
    fn from(t: NoSkipInlineQueryResultCachedAudio) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            audio_file_id: t.audio_file_id,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultCachedAudio> for InlineQueryResultCachedAudio {
    fn into(self) -> NoSkipInlineQueryResultCachedAudio {
        NoSkipInlineQueryResultCachedAudio {
            tg_type: self.tg_type,
            id: self.id,
            audio_file_id: self.audio_file_id,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultCachedAudio {
    pub fn skip(self) -> InlineQueryResultCachedAudio {
        self.into()
    }
}
impl InlineQueryResultCachedAudio {
    pub fn noskip(self) -> NoSkipInlineQueryResultCachedAudio {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to an MP3 audio file stored on the Telegram servers. By default, this audio file will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the audio.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedAudioBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    #[serde(rename = "audio_file_id")]
    audio_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultCachedAudioBuilder {
    pub fn new(id: String, audio_file_id: String) -> Self {
        Self {
            tg_type: "audio".to_owned(),
            id,
            audio_file_id,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    pub fn set_audio_file_id(mut self, audio_file_id: String) -> Self {
        self.audio_file_id = audio_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultCachedAudio {
        InlineQueryResultCachedAudio {
            tg_type: self.tg_type,
            id: self.id,
            audio_file_id: self.audio_file_id,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about a video chat ended in the chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VideoChatEnded {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video chat duration in seconds"]
    #[serde(rename = "duration")]
    duration: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to VideoChatEnded that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipVideoChatEnded {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video chat duration in seconds"]
    #[serde(rename = "duration")]
    duration: i64,
}
impl From<NoSkipVideoChatEnded> for VideoChatEnded {
    fn from(t: NoSkipVideoChatEnded) -> Self {
        Self {
            duration: t.duration,
        }
    }
}
impl Into<NoSkipVideoChatEnded> for VideoChatEnded {
    fn into(self) -> NoSkipVideoChatEnded {
        NoSkipVideoChatEnded {
            duration: self.duration,
        }
    }
}
impl NoSkipVideoChatEnded {
    pub fn skip(self) -> VideoChatEnded {
        self.into()
    }
}
impl VideoChatEnded {
    pub fn noskip(self) -> NoSkipVideoChatEnded {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about a video chat ended in the chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VideoChatEndedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video chat duration in seconds"]
    #[serde(rename = "duration")]
    duration: i64,
}
impl VideoChatEndedBuilder {
    pub fn new(duration: i64) -> Self {
        Self { duration }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video chat duration in seconds"]
    pub fn set_duration(mut self, duration: i64) -> Self {
        self.duration = duration;
        self
    }
    pub fn build(self) -> VideoChatEnded {
        VideoChatEnded {
            duration: self.duration,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a voice recording in an .OGG container encoded with OPUS. By default, this voice recording will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the the voice message.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultVoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    #[serde(rename = "voice_url")]
    voice_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "voice_duration",
        default
    )]
    voice_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultVoice that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultVoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    #[serde(rename = "voice_url")]
    voice_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    voice_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultVoice> for InlineQueryResultVoice {
    fn from(t: NoSkipInlineQueryResultVoice) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            voice_url: t.voice_url,
            title: t.title,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            voice_duration: t.voice_duration,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultVoice> for InlineQueryResultVoice {
    fn into(self) -> NoSkipInlineQueryResultVoice {
        NoSkipInlineQueryResultVoice {
            tg_type: self.tg_type,
            id: self.id,
            voice_url: self.voice_url,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            voice_duration: self.voice_duration,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultVoice {
    pub fn skip(self) -> InlineQueryResultVoice {
        self.into()
    }
}
impl InlineQueryResultVoice {
    pub fn noskip(self) -> NoSkipInlineQueryResultVoice {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a voice recording in an .OGG container encoded with OPUS. By default, this voice recording will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the the voice message.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultVoiceBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    #[serde(rename = "voice_url")]
    voice_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "voice_duration",
        default
    )]
    voice_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultVoiceBuilder {
    pub fn new(id: String, voice_url: String, title: String) -> Self {
        Self {
            tg_type: "voice".to_owned(),
            id,
            voice_url,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            voice_duration: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    pub fn set_voice_url(mut self, voice_url: String) -> Self {
        self.voice_url = voice_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    pub fn set_voice_duration(mut self, voice_duration: i64) -> Self {
        self.voice_duration = Some(voice_duration);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultVoice {
        InlineQueryResultVoice {
            tg_type: self.tg_type,
            id: self.id,
            voice_url: self.voice_url,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            voice_duration: self.voice_duration,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes why a request was unsuccessful."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ResponseParameters {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "migrate_to_chat_id",
        default
    )]
    migrate_to_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "retry_after",
        default
    )]
    retry_after: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ResponseParameters that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipResponseParameters {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    migrate_to_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"]
    retry_after: Option<i64>,
}
impl From<NoSkipResponseParameters> for ResponseParameters {
    fn from(t: NoSkipResponseParameters) -> Self {
        Self {
            migrate_to_chat_id: t.migrate_to_chat_id,
            retry_after: t.retry_after,
        }
    }
}
impl Into<NoSkipResponseParameters> for ResponseParameters {
    fn into(self) -> NoSkipResponseParameters {
        NoSkipResponseParameters {
            migrate_to_chat_id: self.migrate_to_chat_id,
            retry_after: self.retry_after,
        }
    }
}
impl NoSkipResponseParameters {
    pub fn skip(self) -> ResponseParameters {
        self.into()
    }
}
impl ResponseParameters {
    pub fn noskip(self) -> NoSkipResponseParameters {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes why a request was unsuccessful."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ResponseParametersBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "migrate_to_chat_id",
        default
    )]
    migrate_to_chat_id: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "retry_after",
        default
    )]
    retry_after: Option<i64>,
}
impl ResponseParametersBuilder {
    pub fn new() -> Self {
        Self {
            migrate_to_chat_id: None,
            retry_after: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_migrate_to_chat_id(mut self, migrate_to_chat_id: i64) -> Self {
        self.migrate_to_chat_id = Some(migrate_to_chat_id);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"]
    pub fn set_retry_after(mut self, retry_after: i64) -> Self {
        self.retry_after = Some(retry_after);
        self
    }
    pub fn build(self) -> ResponseParameters {
        ResponseParameters {
            migrate_to_chat_id: self.migrate_to_chat_id,
            retry_after: self.retry_after,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes documents or other Telegram Passport elements shared with the bot by the user."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct EncryptedPassportElement {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Element type. One of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\", \"phone_number\", \"email\"."]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\" and \"address\" types. Can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "data", default)]
    data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified phone number, available only for \"phone_number\" type"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "phone_number",
        default
    )]
    phone_number: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified email address, available only for \"email\" type"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "email", default)]
    email: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with documents provided by the user, available for \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "files", default)]
    files: Option<Vec<PassportFile>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the front side of the document, provided by the user. Available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "front_side",
        default
    )]
    front_side: Option<PassportFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the reverse side of the document, provided by the user. Available for \"driver_license\" and \"identity_card\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reverse_side",
        default
    )]
    reverse_side: Option<PassportFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "selfie", default)]
    selfie: Option<PassportFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "translation",
        default
    )]
    translation: Option<Vec<PassportFile>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash for using in PassportElementErrorUnspecified"]
    #[serde(rename = "hash")]
    hash: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to EncryptedPassportElement that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipEncryptedPassportElement {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Element type. One of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\", \"phone_number\", \"email\"."]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\" and \"address\" types. Can be decrypted and verified using the accompanying EncryptedCredentials."]
    data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified phone number, available only for \"phone_number\" type"]
    phone_number: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified email address, available only for \"email\" type"]
    email: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with documents provided by the user, available for \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    files: Option<Vec<PassportFile>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the front side of the document, provided by the user. Available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    front_side: Option<PassportFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the reverse side of the document, provided by the user. Available for \"driver_license\" and \"identity_card\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    reverse_side: Option<PassportFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    selfie: Option<PassportFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    translation: Option<Vec<PassportFile>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash for using in PassportElementErrorUnspecified"]
    #[serde(rename = "hash")]
    hash: String,
}
impl From<NoSkipEncryptedPassportElement> for EncryptedPassportElement {
    fn from(t: NoSkipEncryptedPassportElement) -> Self {
        Self {
            tg_type: t.tg_type,
            data: t.data,
            phone_number: t.phone_number,
            email: t.email,
            files: t.files,
            front_side: t.front_side,
            reverse_side: t.reverse_side,
            selfie: t.selfie,
            translation: t.translation,
            hash: t.hash,
        }
    }
}
impl Into<NoSkipEncryptedPassportElement> for EncryptedPassportElement {
    fn into(self) -> NoSkipEncryptedPassportElement {
        NoSkipEncryptedPassportElement {
            tg_type: self.tg_type,
            data: self.data,
            phone_number: self.phone_number,
            email: self.email,
            files: self.files,
            front_side: self.front_side,
            reverse_side: self.reverse_side,
            selfie: self.selfie,
            translation: self.translation,
            hash: self.hash,
        }
    }
}
impl NoSkipEncryptedPassportElement {
    pub fn skip(self) -> EncryptedPassportElement {
        self.into()
    }
}
impl EncryptedPassportElement {
    pub fn noskip(self) -> NoSkipEncryptedPassportElement {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Describes documents or other Telegram Passport elements shared with the bot by the user."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct EncryptedPassportElementBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Element type. One of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\", \"phone_number\", \"email\"."]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\" and \"address\" types. Can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "data", default)]
    data: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified phone number, available only for \"phone_number\" type"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "phone_number",
        default
    )]
    phone_number: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified email address, available only for \"email\" type"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "email", default)]
    email: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with documents provided by the user, available for \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "files", default)]
    files: Option<Vec<PassportFile>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the front side of the document, provided by the user. Available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "front_side",
        default
    )]
    front_side: Option<PassportFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the reverse side of the document, provided by the user. Available for \"driver_license\" and \"identity_card\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reverse_side",
        default
    )]
    reverse_side: Option<PassportFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "selfie", default)]
    selfie: Option<PassportFile>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "translation",
        default
    )]
    translation: Option<Vec<PassportFile>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash for using in PassportElementErrorUnspecified"]
    #[serde(rename = "hash")]
    hash: String,
}
impl EncryptedPassportElementBuilder {
    pub fn new(hash: String) -> Self {
        Self {
            tg_type: "EncryptedPassportElement".to_owned(),
            hash,
            data: None,
            phone_number: None,
            email: None,
            files: None,
            front_side: None,
            reverse_side: None,
            selfie: None,
            translation: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Element type. One of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\", \"phone_number\", \"email\"."]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\" and \"address\" types. Can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_data(mut self, data: String) -> Self {
        self.data = Some(data);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified phone number, available only for \"phone_number\" type"]
    pub fn set_phone_number(mut self, phone_number: String) -> Self {
        self.phone_number = Some(phone_number);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified email address, available only for \"email\" type"]
    pub fn set_email(mut self, email: String) -> Self {
        self.email = Some(email);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with documents provided by the user, available for \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_files(mut self, files: Vec<PassportFile>) -> Self {
        self.files = Some(files);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the front side of the document, provided by the user. Available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_front_side(mut self, front_side: PassportFile) -> Self {
        self.front_side = Some(front_side);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the reverse side of the document, provided by the user. Available for \"driver_license\" and \"identity_card\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_reverse_side(mut self, reverse_side: PassportFile) -> Self {
        self.reverse_side = Some(reverse_side);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_selfie(mut self, selfie: PassportFile) -> Self {
        self.selfie = Some(selfie);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_translation(mut self, translation: Vec<PassportFile>) -> Self {
        self.translation = Some(translation);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash for using in PassportElementErrorUnspecified"]
    pub fn set_hash(mut self, hash: String) -> Self {
        self.hash = hash;
        self
    }
    pub fn build(self) -> EncryptedPassportElement {
        EncryptedPassportElement {
            tg_type: self.tg_type,
            data: self.data,
            phone_number: self.phone_number,
            email: self.email,
            files: self.files,
            front_side: self.front_side,
            reverse_side: self.reverse_side,
            selfie: self.selfie,
            translation: self.translation,
            hash: self.hash,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one size of a photo or a file / sticker thumbnail."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PhotoSize {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo width"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo height"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PhotoSize that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPhotoSize {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo width"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo height"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    file_size: Option<i64>,
}
impl From<NoSkipPhotoSize> for PhotoSize {
    fn from(t: NoSkipPhotoSize) -> Self {
        Self {
            file_id: t.file_id,
            file_unique_id: t.file_unique_id,
            width: t.width,
            height: t.height,
            file_size: t.file_size,
        }
    }
}
impl Into<NoSkipPhotoSize> for PhotoSize {
    fn into(self) -> NoSkipPhotoSize {
        NoSkipPhotoSize {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            width: self.width,
            height: self.height,
            file_size: self.file_size,
        }
    }
}
impl NoSkipPhotoSize {
    pub fn skip(self) -> PhotoSize {
        self.into()
    }
}
impl PhotoSize {
    pub fn noskip(self) -> NoSkipPhotoSize {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents one size of a photo or a file / sticker thumbnail."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PhotoSizeBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo width"]
    #[serde(rename = "width")]
    width: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo height"]
    #[serde(rename = "height")]
    height: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
impl PhotoSizeBuilder {
    pub fn new(file_id: String, file_unique_id: String, width: i64, height: i64) -> Self {
        Self {
            file_id,
            file_unique_id,
            width,
            height,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id(mut self, file_id: String) -> Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id(mut self, file_unique_id: String) -> Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo width"]
    pub fn set_width(mut self, width: i64) -> Self {
        self.width = width;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo height"]
    pub fn set_height(mut self, height: i64) -> Self {
        self.height = height;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn set_file_size(mut self, file_size: i64) -> Self {
        self.file_size = Some(file_size);
        self
    }
    pub fn build(self) -> PhotoSize {
        PhotoSize {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            width: self.width,
            height: self.height,
            file_size: self.file_size,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a video file stored on the Telegram servers. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the video."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    #[serde(rename = "video_file_id")]
    video_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultCachedVideo that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultCachedVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    #[serde(rename = "video_file_id")]
    video_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultCachedVideo> for InlineQueryResultCachedVideo {
    fn from(t: NoSkipInlineQueryResultCachedVideo) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            video_file_id: t.video_file_id,
            title: t.title,
            description: t.description,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultCachedVideo> for InlineQueryResultCachedVideo {
    fn into(self) -> NoSkipInlineQueryResultCachedVideo {
        NoSkipInlineQueryResultCachedVideo {
            tg_type: self.tg_type,
            id: self.id,
            video_file_id: self.video_file_id,
            title: self.title,
            description: self.description,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultCachedVideo {
    pub fn skip(self) -> InlineQueryResultCachedVideo {
        self.into()
    }
}
impl InlineQueryResultCachedVideo {
    pub fn noskip(self) -> NoSkipInlineQueryResultCachedVideo {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a video file stored on the Telegram servers. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the video."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedVideoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    #[serde(rename = "video_file_id")]
    video_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultCachedVideoBuilder {
    pub fn new(id: String, video_file_id: String, title: String) -> Self {
        Self {
            tg_type: "video".to_owned(),
            id,
            video_file_id,
            title,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    pub fn set_video_file_id(mut self, video_file_id: String) -> Self {
        self.video_file_id = video_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultCachedVideo {
        InlineQueryResultCachedVideo {
            tg_type: self.tg_type,
            id: self.id,
            video_file_id: self.video_file_id,
            title: self.title,
            description: self.description,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a voice note."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Voice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "mime_type", default)]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Voice that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipVoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    file_size: Option<i64>,
}
impl From<NoSkipVoice> for Voice {
    fn from(t: NoSkipVoice) -> Self {
        Self {
            file_id: t.file_id,
            file_unique_id: t.file_unique_id,
            duration: t.duration,
            mime_type: t.mime_type,
            file_size: t.file_size,
        }
    }
}
impl Into<NoSkipVoice> for Voice {
    fn into(self) -> NoSkipVoice {
        NoSkipVoice {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            duration: self.duration,
            mime_type: self.mime_type,
            file_size: self.file_size,
        }
    }
}
impl NoSkipVoice {
    pub fn skip(self) -> Voice {
        self.into()
    }
}
impl Voice {
    pub fn noskip(self) -> NoSkipVoice {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a voice note."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VoiceBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    #[serde(rename = "file_id")]
    file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    #[serde(rename = "file_unique_id")]
    file_unique_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    #[serde(rename = "duration")]
    duration: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "mime_type", default)]
    mime_type: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "file_size", default)]
    file_size: Option<i64>,
}
impl VoiceBuilder {
    pub fn new(file_id: String, file_unique_id: String, duration: i64) -> Self {
        Self {
            file_id,
            file_unique_id,
            duration,
            mime_type: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id(mut self, file_id: String) -> Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id(mut self, file_unique_id: String) -> Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    pub fn set_duration(mut self, duration: i64) -> Self {
        self.duration = duration;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn set_mime_type(mut self, mime_type: String) -> Self {
        self.mime_type = Some(mime_type);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size(mut self, file_size: i64) -> Self {
        self.file_size = Some(file_size);
        self
    }
    pub fn build(self) -> Voice {
        Voice {
            file_id: self.file_id,
            file_unique_id: self.file_unique_id,
            duration: self.duration,
            mime_type: self.mime_type,
            file_size: self.file_size,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a game. Use BotFather to create and edit games, their short names will act as unique identifiers."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Game {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the game"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the game"]
    #[serde(rename = "description")]
    description: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo that will be displayed in the game message in chats."]
    #[serde(rename = "photo")]
    photo: Vec<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "text", default)]
    text: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "text_entities",
        default
    )]
    text_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "animation", default)]
    animation: Option<Animation>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Game that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipGame {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the game"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the game"]
    #[serde(rename = "description")]
    description: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo that will be displayed in the game message in chats."]
    #[serde(rename = "photo")]
    photo: Vec<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."]
    text: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."]
    text_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"]
    animation: Option<Animation>,
}
impl From<NoSkipGame> for Game {
    fn from(t: NoSkipGame) -> Self {
        Self {
            title: t.title,
            description: t.description,
            photo: t.photo,
            text: t.text,
            text_entities: t.text_entities,
            animation: t.animation,
        }
    }
}
impl Into<NoSkipGame> for Game {
    fn into(self) -> NoSkipGame {
        NoSkipGame {
            title: self.title,
            description: self.description,
            photo: self.photo,
            text: self.text,
            text_entities: self.text_entities,
            animation: self.animation,
        }
    }
}
impl NoSkipGame {
    pub fn skip(self) -> Game {
        self.into()
    }
}
impl Game {
    pub fn noskip(self) -> NoSkipGame {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a game. Use BotFather to create and edit games, their short names will act as unique identifiers."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct GameBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the game"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the game"]
    #[serde(rename = "description")]
    description: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo that will be displayed in the game message in chats."]
    #[serde(rename = "photo")]
    photo: Vec<PhotoSize>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "text", default)]
    text: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "text_entities",
        default
    )]
    text_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "animation", default)]
    animation: Option<Animation>,
}
impl GameBuilder {
    pub fn new(title: String, description: String, photo: Vec<PhotoSize>) -> Self {
        Self {
            title,
            description,
            photo,
            text: None,
            text_entities: None,
            animation: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the game"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the game"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = description;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo that will be displayed in the game message in chats."]
    pub fn set_photo(mut self, photo: Vec<PhotoSize>) -> Self {
        self.photo = photo;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."]
    pub fn set_text(mut self, text: String) -> Self {
        self.text = Some(text);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."]
    pub fn set_text_entities(mut self, text_entities: Vec<MessageEntity>) -> Self {
        self.text_entities = Some(text_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"]
    pub fn set_animation(mut self, animation: Animation) -> Self {
        self.animation = Some(animation);
        self
    }
    pub fn build(self) -> Game {
        Game {
            title: self.title,
            description: self.description,
            photo: self.photo,
            text: self.text,
            text_entities: self.text_entities,
            animation: self.animation,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a photo. By default, this photo will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the photo."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    #[serde(rename = "photo_url")]
    photo_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "photo_width",
        default
    )]
    photo_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "photo_height",
        default
    )]
    photo_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultPhoto that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    #[serde(rename = "photo_url")]
    photo_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    photo_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    photo_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultPhoto> for InlineQueryResultPhoto {
    fn from(t: NoSkipInlineQueryResultPhoto) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            photo_url: t.photo_url,
            thumbnail_url: t.thumbnail_url,
            photo_width: t.photo_width,
            photo_height: t.photo_height,
            title: t.title,
            description: t.description,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultPhoto> for InlineQueryResultPhoto {
    fn into(self) -> NoSkipInlineQueryResultPhoto {
        NoSkipInlineQueryResultPhoto {
            tg_type: self.tg_type,
            id: self.id,
            photo_url: self.photo_url,
            thumbnail_url: self.thumbnail_url,
            photo_width: self.photo_width,
            photo_height: self.photo_height,
            title: self.title,
            description: self.description,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultPhoto {
    pub fn skip(self) -> InlineQueryResultPhoto {
        self.into()
    }
}
impl InlineQueryResultPhoto {
    pub fn noskip(self) -> NoSkipInlineQueryResultPhoto {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to a photo. By default, this photo will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the photo."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultPhotoBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    #[serde(rename = "photo_url")]
    photo_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    #[serde(rename = "thumbnail_url")]
    thumbnail_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "photo_width",
        default
    )]
    photo_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "photo_height",
        default
    )]
    photo_height: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "description",
        default
    )]
    description: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultPhotoBuilder {
    pub fn new(id: String, photo_url: String, thumbnail_url: String) -> Self {
        Self {
            tg_type: "photo".to_owned(),
            id,
            photo_url,
            thumbnail_url,
            photo_width: None,
            photo_height: None,
            title: None,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    pub fn set_photo_url(mut self, photo_url: String) -> Self {
        self.photo_url = photo_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    pub fn set_thumbnail_url(mut self, thumbnail_url: String) -> Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    pub fn set_photo_width(mut self, photo_width: i64) -> Self {
        self.photo_width = Some(photo_width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    pub fn set_photo_height(mut self, photo_height: i64) -> Self {
        self.photo_height = Some(photo_height);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultPhoto {
        InlineQueryResultPhoto {
            tg_type: self.tg_type,
            id: self.id,
            photo_url: self.photo_url,
            thumbnail_url: self.thumbnail_url,
            photo_width: self.photo_width,
            photo_height: self.photo_height,
            title: self.title,
            description: self.description,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a location on a map. By default, the location will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the location.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultLocation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "horizontal_accuracy",
        default
    )]
    horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "live_period",
        default
    )]
    live_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "heading", default)]
    heading: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "proximity_alert_radius",
        default
    )]
    proximity_alert_radius: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_url",
        default
    )]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_width",
        default
    )]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_height",
        default
    )]
    thumbnail_height: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultLocation that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultLocation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    live_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    heading: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    proximity_alert_radius: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    thumbnail_height: Option<i64>,
}
impl From<NoSkipInlineQueryResultLocation> for InlineQueryResultLocation {
    fn from(t: NoSkipInlineQueryResultLocation) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            latitude: t.latitude,
            longitude: t.longitude,
            title: t.title,
            horizontal_accuracy: t.horizontal_accuracy,
            live_period: t.live_period,
            heading: t.heading,
            proximity_alert_radius: t.proximity_alert_radius,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
            thumbnail_url: t.thumbnail_url,
            thumbnail_width: t.thumbnail_width,
            thumbnail_height: t.thumbnail_height,
        }
    }
}
impl Into<NoSkipInlineQueryResultLocation> for InlineQueryResultLocation {
    fn into(self) -> NoSkipInlineQueryResultLocation {
        NoSkipInlineQueryResultLocation {
            tg_type: self.tg_type,
            id: self.id,
            latitude: self.latitude,
            longitude: self.longitude,
            title: self.title,
            horizontal_accuracy: self.horizontal_accuracy,
            live_period: self.live_period,
            heading: self.heading,
            proximity_alert_radius: self.proximity_alert_radius,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
            thumbnail_url: self.thumbnail_url,
            thumbnail_width: self.thumbnail_width,
            thumbnail_height: self.thumbnail_height,
        }
    }
}
impl NoSkipInlineQueryResultLocation {
    pub fn skip(self) -> InlineQueryResultLocation {
        self.into()
    }
}
impl InlineQueryResultLocation {
    pub fn noskip(self) -> NoSkipInlineQueryResultLocation {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a location on a map. By default, the location will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the location.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultLocationBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    #[serde(rename = "latitude")]
    latitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    #[serde(rename = "longitude")]
    longitude: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "horizontal_accuracy",
        default
    )]
    horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "live_period",
        default
    )]
    live_period: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "heading", default)]
    heading: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "proximity_alert_radius",
        default
    )]
    proximity_alert_radius: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_url",
        default
    )]
    thumbnail_url: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_width",
        default
    )]
    thumbnail_width: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "thumbnail_height",
        default
    )]
    thumbnail_height: Option<i64>,
}
impl InlineQueryResultLocationBuilder {
    pub fn new(
        id: String,
        latitude: ::ordered_float::OrderedFloat<f64>,
        longitude: ::ordered_float::OrderedFloat<f64>,
        title: String,
    ) -> Self {
        Self {
            tg_type: "location".to_owned(),
            id,
            latitude,
            longitude,
            title,
            horizontal_accuracy: None,
            live_period: None,
            heading: None,
            proximity_alert_radius: None,
            reply_markup: None,
            input_message_content: None,
            thumbnail_url: None,
            thumbnail_width: None,
            thumbnail_height: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    pub fn set_latitude(mut self, latitude: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    pub fn set_longitude(mut self, longitude: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn set_horizontal_accuracy(
        mut self,
        horizontal_accuracy: ::ordered_float::OrderedFloat<f64>,
    ) -> Self {
        self.horizontal_accuracy = Some(horizontal_accuracy);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    pub fn set_live_period(mut self, live_period: i64) -> Self {
        self.live_period = Some(live_period);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    pub fn set_heading(mut self, heading: i64) -> Self {
        self.heading = Some(heading);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    pub fn set_proximity_alert_radius(mut self, proximity_alert_radius: i64) -> Self {
        self.proximity_alert_radius = Some(proximity_alert_radius);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn set_thumbnail_url(mut self, thumbnail_url: String) -> Self {
        self.thumbnail_url = Some(thumbnail_url);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn set_thumbnail_width(mut self, thumbnail_width: i64) -> Self {
        self.thumbnail_width = Some(thumbnail_width);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn set_thumbnail_height(mut self, thumbnail_height: i64) -> Self {
        self.thumbnail_height = Some(thumbnail_height);
        self
    }
    pub fn build(self) -> InlineQueryResultLocation {
        InlineQueryResultLocation {
            tg_type: self.tg_type,
            id: self.id,
            latitude: self.latitude,
            longitude: self.longitude,
            title: self.title,
            horizontal_accuracy: self.horizontal_accuracy,
            live_period: self.live_period,
            heading: self.heading,
            proximity_alert_radius: self.proximity_alert_radius,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
            thumbnail_url: self.thumbnail_url,
            thumbnail_width: self.thumbnail_width,
            thumbnail_height: self.thumbnail_height,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum InputMessageContent {
    InputTextMessageContent(InputTextMessageContent),
    InputLocationMessageContent(InputLocationMessageContent),
    InputVenueMessageContent(InputVenueMessageContent),
    InputContactMessageContent(InputContactMessageContent),
    InputInvoiceMessageContent(InputInvoiceMessageContent),
}
impl Default for InputMessageContent {
    fn default() -> Self {
        InputMessageContent::InputTextMessageContent(InputTextMessageContent::default())
    }
}
impl InputMessageContent {}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that owns the chat and has all administrator privileges."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberOwner {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "custom_title",
        default
    )]
    custom_title: Option<String>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatMemberOwner that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatMemberOwner {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    custom_title: Option<String>,
}
impl From<NoSkipChatMemberOwner> for ChatMemberOwner {
    fn from(t: NoSkipChatMemberOwner) -> Self {
        Self {
            user: t.user,
            is_anonymous: t.is_anonymous,
            custom_title: t.custom_title,
        }
    }
}
impl Into<NoSkipChatMemberOwner> for ChatMemberOwner {
    fn into(self) -> NoSkipChatMemberOwner {
        NoSkipChatMemberOwner {
            user: self.user,
            is_anonymous: self.is_anonymous,
            custom_title: self.custom_title,
        }
    }
}
impl NoSkipChatMemberOwner {
    pub fn skip(self) -> ChatMemberOwner {
        self.into()
    }
}
impl ChatMemberOwner {
    pub fn noskip(self) -> NoSkipChatMemberOwner {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a chat member that owns the chat and has all administrator privileges."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatMemberOwnerBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    #[serde(rename = "user")]
    user: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    #[serde(rename = "is_anonymous")]
    is_anonymous: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "custom_title",
        default
    )]
    custom_title: Option<String>,
}
impl ChatMemberOwnerBuilder {
    pub fn new(user: User, is_anonymous: bool) -> Self {
        Self {
            user,
            is_anonymous,
            custom_title: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user(mut self, user: User) -> Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn set_is_anonymous(mut self, is_anonymous: bool) -> Self {
        self.is_anonymous = is_anonymous;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    pub fn set_custom_title(mut self, custom_title: String) -> Self {
        self.custom_title = Some(custom_title);
        self
    }
    pub fn build(self) -> ChatMemberOwner {
        ChatMemberOwner {
            user: self.user,
            is_anonymous: self.is_anonymous,
            custom_title: self.custom_title,
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum Story {}
impl Story {}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum MenuButton {
    MenuButtonCommands(MenuButtonCommands),
    MenuButtonWebApp(MenuButtonWebApp),
    MenuButtonDefault(MenuButtonDefault),
}
impl Default for MenuButton {
    fn default() -> Self {
        MenuButton::MenuButtonCommands(MenuButtonCommands::default())
    }
}
impl MenuButton {}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a Telegram user or bot."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct User {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(rename = "id")]
    id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if this user is a bot"]
    #[serde(rename = "is_bot")]
    is_bot: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User's or bot's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's last name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "last_name", default)]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's username"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "username", default)]
    username: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. IETF language tag of the user's language"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "language_code",
        default
    )]
    language_code: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user is a Telegram Premium user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "is_premium",
        default
    )]
    is_premium: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user added the bot to the attachment menu"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "added_to_attachment_menu",
        default
    )]
    added_to_attachment_menu: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can be invited to groups. Returned only in getMe."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_join_groups",
        default
    )]
    can_join_groups: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_read_all_group_messages",
        default
    )]
    can_read_all_group_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot supports inline queries. Returned only in getMe."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "supports_inline_queries",
        default
    )]
    supports_inline_queries: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to User that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipUser {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(rename = "id")]
    id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if this user is a bot"]
    #[serde(rename = "is_bot")]
    is_bot: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User's or bot's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's last name"]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's username"]
    username: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. IETF language tag of the user's language"]
    language_code: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user is a Telegram Premium user"]
    is_premium: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user added the bot to the attachment menu"]
    added_to_attachment_menu: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can be invited to groups. Returned only in getMe."]
    can_join_groups: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."]
    can_read_all_group_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot supports inline queries. Returned only in getMe."]
    supports_inline_queries: Option<bool>,
}
impl From<NoSkipUser> for User {
    fn from(t: NoSkipUser) -> Self {
        Self {
            id: t.id,
            is_bot: t.is_bot,
            first_name: t.first_name,
            last_name: t.last_name,
            username: t.username,
            language_code: t.language_code,
            is_premium: t.is_premium,
            added_to_attachment_menu: t.added_to_attachment_menu,
            can_join_groups: t.can_join_groups,
            can_read_all_group_messages: t.can_read_all_group_messages,
            supports_inline_queries: t.supports_inline_queries,
        }
    }
}
impl Into<NoSkipUser> for User {
    fn into(self) -> NoSkipUser {
        NoSkipUser {
            id: self.id,
            is_bot: self.is_bot,
            first_name: self.first_name,
            last_name: self.last_name,
            username: self.username,
            language_code: self.language_code,
            is_premium: self.is_premium,
            added_to_attachment_menu: self.added_to_attachment_menu,
            can_join_groups: self.can_join_groups,
            can_read_all_group_messages: self.can_read_all_group_messages,
            supports_inline_queries: self.supports_inline_queries,
        }
    }
}
impl NoSkipUser {
    pub fn skip(self) -> User {
        self.into()
    }
}
impl User {
    pub fn noskip(self) -> NoSkipUser {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a Telegram user or bot."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct UserBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    #[serde(rename = "id")]
    id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if this user is a bot"]
    #[serde(rename = "is_bot")]
    is_bot: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User's or bot's first name"]
    #[serde(rename = "first_name")]
    first_name: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's last name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "last_name", default)]
    last_name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's username"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "username", default)]
    username: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. IETF language tag of the user's language"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "language_code",
        default
    )]
    language_code: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user is a Telegram Premium user"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "is_premium",
        default
    )]
    is_premium: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user added the bot to the attachment menu"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "added_to_attachment_menu",
        default
    )]
    added_to_attachment_menu: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can be invited to groups. Returned only in getMe."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_join_groups",
        default
    )]
    can_join_groups: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "can_read_all_group_messages",
        default
    )]
    can_read_all_group_messages: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot supports inline queries. Returned only in getMe."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "supports_inline_queries",
        default
    )]
    supports_inline_queries: Option<bool>,
}
impl UserBuilder {
    pub fn new(id: i64, is_bot: bool, first_name: String) -> Self {
        Self {
            id,
            is_bot,
            first_name,
            last_name: None,
            username: None,
            language_code: None,
            is_premium: None,
            added_to_attachment_menu: None,
            can_join_groups: None,
            can_read_all_group_messages: None,
            supports_inline_queries: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_id(mut self, id: i64) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if this user is a bot"]
    pub fn set_is_bot(mut self, is_bot: bool) -> Self {
        self.is_bot = is_bot;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User's or bot's first name"]
    pub fn set_first_name(mut self, first_name: String) -> Self {
        self.first_name = first_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's last name"]
    pub fn set_last_name(mut self, last_name: String) -> Self {
        self.last_name = Some(last_name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's username"]
    pub fn set_username(mut self, username: String) -> Self {
        self.username = Some(username);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. IETF language tag of the user's language"]
    pub fn set_language_code(mut self, language_code: String) -> Self {
        self.language_code = Some(language_code);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user is a Telegram Premium user"]
    pub fn set_is_premium(mut self, is_premium: bool) -> Self {
        self.is_premium = Some(is_premium);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user added the bot to the attachment menu"]
    pub fn set_added_to_attachment_menu(mut self, added_to_attachment_menu: bool) -> Self {
        self.added_to_attachment_menu = Some(added_to_attachment_menu);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can be invited to groups. Returned only in getMe."]
    pub fn set_can_join_groups(mut self, can_join_groups: bool) -> Self {
        self.can_join_groups = Some(can_join_groups);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."]
    pub fn set_can_read_all_group_messages(mut self, can_read_all_group_messages: bool) -> Self {
        self.can_read_all_group_messages = Some(can_read_all_group_messages);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot supports inline queries. Returned only in getMe."]
    pub fn set_supports_inline_queries(mut self, supports_inline_queries: bool) -> Self {
        self.supports_inline_queries = Some(supports_inline_queries);
        self
    }
    pub fn build(self) -> User {
        User {
            id: self.id,
            is_bot: self.is_bot,
            first_name: self.first_name,
            last_name: self.last_name,
            username: self.username,
            language_code: self.language_code,
            is_premium: self.is_premium,
            added_to_attachment_menu: self.added_to_attachment_menu,
            can_join_groups: self.can_join_groups,
            can_read_all_group_messages: self.can_read_all_group_messages,
            supports_inline_queries: self.supports_inline_queries,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to an MP3 audio file. By default, this audio file will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the audio.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    #[serde(rename = "audio_url")]
    audio_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "performer", default)]
    performer: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "audio_duration",
        default
    )]
    audio_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultAudio that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    #[serde(rename = "audio_url")]
    audio_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    performer: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    audio_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultAudio> for InlineQueryResultAudio {
    fn from(t: NoSkipInlineQueryResultAudio) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            audio_url: t.audio_url,
            title: t.title,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            performer: t.performer,
            audio_duration: t.audio_duration,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultAudio> for InlineQueryResultAudio {
    fn into(self) -> NoSkipInlineQueryResultAudio {
        NoSkipInlineQueryResultAudio {
            tg_type: self.tg_type,
            id: self.id,
            audio_url: self.audio_url,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            performer: self.performer,
            audio_duration: self.audio_duration,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultAudio {
    pub fn skip(self) -> InlineQueryResultAudio {
        self.into()
    }
}
impl InlineQueryResultAudio {
    pub fn noskip(self) -> NoSkipInlineQueryResultAudio {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to an MP3 audio file. By default, this audio file will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the audio.Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultAudioBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    #[serde(rename = "audio_url")]
    audio_url: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "performer", default)]
    performer: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "audio_duration",
        default
    )]
    audio_duration: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultAudioBuilder {
    pub fn new(id: String, audio_url: String, title: String) -> Self {
        Self {
            tg_type: "audio".to_owned(),
            id,
            audio_url,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            performer: None,
            audio_duration: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    pub fn set_audio_url(mut self, audio_url: String) -> Self {
        self.audio_url = audio_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    pub fn set_performer(mut self, performer: String) -> Self {
        self.performer = Some(performer);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    pub fn set_audio_duration(mut self, audio_duration: i64) -> Self {
        self.audio_duration = Some(audio_duration);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultAudio {
        InlineQueryResultAudio {
            tg_type: self.tg_type,
            id: self.id,
            audio_url: self.audio_url,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            performer: self.performer,
            audio_duration: self.audio_duration,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an invite link for a chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatInviteLink {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with \"...\"."]
    #[serde(rename = "invite_link")]
    invite_link: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Creator of the link"]
    #[serde(rename = "creator")]
    creator: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if users joining the chat via the link need to be approved by chat administrators"]
    #[serde(rename = "creates_join_request")]
    creates_join_request: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is primary"]
    #[serde(rename = "is_primary")]
    is_primary: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is revoked"]
    #[serde(rename = "is_revoked")]
    is_revoked: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Invite link name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "name", default)]
    name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "expire_date",
        default
    )]
    expire_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "member_limit",
        default
    )]
    member_limit: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Number of pending join requests created using this link"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "pending_join_request_count",
        default
    )]
    pending_join_request_count: Option<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ChatInviteLink that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipChatInviteLink {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with \"...\"."]
    #[serde(rename = "invite_link")]
    invite_link: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Creator of the link"]
    #[serde(rename = "creator")]
    creator: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if users joining the chat via the link need to be approved by chat administrators"]
    #[serde(rename = "creates_join_request")]
    creates_join_request: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is primary"]
    #[serde(rename = "is_primary")]
    is_primary: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is revoked"]
    #[serde(rename = "is_revoked")]
    is_revoked: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Invite link name"]
    name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"]
    expire_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"]
    member_limit: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Number of pending join requests created using this link"]
    pending_join_request_count: Option<i64>,
}
impl From<NoSkipChatInviteLink> for ChatInviteLink {
    fn from(t: NoSkipChatInviteLink) -> Self {
        Self {
            invite_link: t.invite_link,
            creator: t.creator,
            creates_join_request: t.creates_join_request,
            is_primary: t.is_primary,
            is_revoked: t.is_revoked,
            name: t.name,
            expire_date: t.expire_date,
            member_limit: t.member_limit,
            pending_join_request_count: t.pending_join_request_count,
        }
    }
}
impl Into<NoSkipChatInviteLink> for ChatInviteLink {
    fn into(self) -> NoSkipChatInviteLink {
        NoSkipChatInviteLink {
            invite_link: self.invite_link,
            creator: self.creator,
            creates_join_request: self.creates_join_request,
            is_primary: self.is_primary,
            is_revoked: self.is_revoked,
            name: self.name,
            expire_date: self.expire_date,
            member_limit: self.member_limit,
            pending_join_request_count: self.pending_join_request_count,
        }
    }
}
impl NoSkipChatInviteLink {
    pub fn skip(self) -> ChatInviteLink {
        self.into()
    }
}
impl ChatInviteLink {
    pub fn noskip(self) -> NoSkipChatInviteLink {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an invite link for a chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChatInviteLinkBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with \"...\"."]
    #[serde(rename = "invite_link")]
    invite_link: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Creator of the link"]
    #[serde(rename = "creator")]
    creator: User,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if users joining the chat via the link need to be approved by chat administrators"]
    #[serde(rename = "creates_join_request")]
    creates_join_request: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is primary"]
    #[serde(rename = "is_primary")]
    is_primary: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is revoked"]
    #[serde(rename = "is_revoked")]
    is_revoked: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Invite link name"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "name", default)]
    name: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "expire_date",
        default
    )]
    expire_date: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "member_limit",
        default
    )]
    member_limit: Option<i64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Number of pending join requests created using this link"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "pending_join_request_count",
        default
    )]
    pending_join_request_count: Option<i64>,
}
impl ChatInviteLinkBuilder {
    pub fn new(
        invite_link: String,
        creator: User,
        creates_join_request: bool,
        is_primary: bool,
        is_revoked: bool,
    ) -> Self {
        Self {
            invite_link,
            creator,
            creates_join_request,
            is_primary,
            is_revoked,
            name: None,
            expire_date: None,
            member_limit: None,
            pending_join_request_count: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with \"...\"."]
    pub fn set_invite_link(mut self, invite_link: String) -> Self {
        self.invite_link = invite_link;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Creator of the link"]
    pub fn set_creator(mut self, creator: User) -> Self {
        self.creator = creator;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if users joining the chat via the link need to be approved by chat administrators"]
    pub fn set_creates_join_request(mut self, creates_join_request: bool) -> Self {
        self.creates_join_request = creates_join_request;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is primary"]
    pub fn set_is_primary(mut self, is_primary: bool) -> Self {
        self.is_primary = is_primary;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is revoked"]
    pub fn set_is_revoked(mut self, is_revoked: bool) -> Self {
        self.is_revoked = is_revoked;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Invite link name"]
    pub fn set_name(mut self, name: String) -> Self {
        self.name = Some(name);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"]
    pub fn set_expire_date(mut self, expire_date: i64) -> Self {
        self.expire_date = Some(expire_date);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"]
    pub fn set_member_limit(mut self, member_limit: i64) -> Self {
        self.member_limit = Some(member_limit);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Number of pending join requests created using this link"]
    pub fn set_pending_join_request_count(mut self, pending_join_request_count: i64) -> Self {
        self.pending_join_request_count = Some(pending_join_request_count);
        self
    }
    pub fn build(self) -> ChatInviteLink {
        ChatInviteLink {
            invite_link: self.invite_link,
            creator: self.creator,
            creates_join_request: self.creates_join_request,
            is_primary: self.is_primary,
            is_revoked: self.is_revoked,
            name: self.name,
            expire_date: self.expire_date,
            member_limit: self.member_limit,
            pending_join_request_count: self.pending_join_request_count,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about a change in auto-delete timer settings."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MessageAutoDeleteTimerChanged {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New auto-delete time for messages in the chat; in seconds"]
    #[serde(rename = "message_auto_delete_time")]
    message_auto_delete_time: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to MessageAutoDeleteTimerChanged that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipMessageAutoDeleteTimerChanged {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New auto-delete time for messages in the chat; in seconds"]
    #[serde(rename = "message_auto_delete_time")]
    message_auto_delete_time: i64,
}
impl From<NoSkipMessageAutoDeleteTimerChanged> for MessageAutoDeleteTimerChanged {
    fn from(t: NoSkipMessageAutoDeleteTimerChanged) -> Self {
        Self {
            message_auto_delete_time: t.message_auto_delete_time,
        }
    }
}
impl Into<NoSkipMessageAutoDeleteTimerChanged> for MessageAutoDeleteTimerChanged {
    fn into(self) -> NoSkipMessageAutoDeleteTimerChanged {
        NoSkipMessageAutoDeleteTimerChanged {
            message_auto_delete_time: self.message_auto_delete_time,
        }
    }
}
impl NoSkipMessageAutoDeleteTimerChanged {
    pub fn skip(self) -> MessageAutoDeleteTimerChanged {
        self.into()
    }
}
impl MessageAutoDeleteTimerChanged {
    pub fn noskip(self) -> NoSkipMessageAutoDeleteTimerChanged {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a service message about a change in auto-delete timer settings."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MessageAutoDeleteTimerChangedBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New auto-delete time for messages in the chat; in seconds"]
    #[serde(rename = "message_auto_delete_time")]
    message_auto_delete_time: i64,
}
impl MessageAutoDeleteTimerChangedBuilder {
    pub fn new(message_auto_delete_time: i64) -> Self {
        Self {
            message_auto_delete_time,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New auto-delete time for messages in the chat; in seconds"]
    pub fn set_message_auto_delete_time(mut self, message_auto_delete_time: i64) -> Self {
        self.message_auto_delete_time = message_auto_delete_time;
        self
    }
    pub fn build(self) -> MessageAutoDeleteTimerChanged {
        MessageAutoDeleteTimerChanged {
            message_auto_delete_time: self.message_auto_delete_time,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to an animated GIF file stored on the Telegram servers. By default, this animated GIF file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with specified content instead of the animation."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedGif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    #[serde(rename = "gif_file_id")]
    gif_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to InlineQueryResultCachedGif that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInlineQueryResultCachedGif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    #[serde(rename = "gif_file_id")]
    gif_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    input_message_content: Option<InputMessageContent>,
}
impl From<NoSkipInlineQueryResultCachedGif> for InlineQueryResultCachedGif {
    fn from(t: NoSkipInlineQueryResultCachedGif) -> Self {
        Self {
            tg_type: t.tg_type,
            id: t.id,
            gif_file_id: t.gif_file_id,
            title: t.title,
            caption: t.caption,
            parse_mode: t.parse_mode,
            caption_entities: t.caption_entities,
            reply_markup: t.reply_markup,
            input_message_content: t.input_message_content,
        }
    }
}
impl Into<NoSkipInlineQueryResultCachedGif> for InlineQueryResultCachedGif {
    fn into(self) -> NoSkipInlineQueryResultCachedGif {
        NoSkipInlineQueryResultCachedGif {
            tg_type: self.tg_type,
            id: self.id,
            gif_file_id: self.gif_file_id,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
impl NoSkipInlineQueryResultCachedGif {
    pub fn skip(self) -> InlineQueryResultCachedGif {
        self.into()
    }
}
impl InlineQueryResultCachedGif {
    pub fn noskip(self) -> NoSkipInlineQueryResultCachedGif {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents a link to an animated GIF file stored on the Telegram servers. By default, this animated GIF file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with specified content instead of the animation."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InlineQueryResultCachedGifBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    #[serde(rename = "id")]
    id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    #[serde(rename = "gif_file_id")]
    gif_file_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "title", default)]
    title: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "caption", default)]
    caption: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "parse_mode",
        default
    )]
    parse_mode: Option<String>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "caption_entities",
        default
    )]
    caption_entities: Option<Vec<MessageEntity>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "reply_markup",
        default
    )]
    reply_markup: Option<InlineKeyboardMarkup>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "input_message_content",
        default
    )]
    input_message_content: Option<InputMessageContent>,
}
impl InlineQueryResultCachedGifBuilder {
    pub fn new(id: String, gif_file_id: String) -> Self {
        Self {
            tg_type: "gif".to_owned(),
            id,
            gif_file_id,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id(mut self, id: String) -> Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    pub fn set_gif_file_id(mut self, gif_file_id: String) -> Self {
        self.gif_file_id = gif_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption(mut self, caption: String) -> Self {
        self.caption = Some(caption);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn set_parse_mode(mut self, parse_mode: String) -> Self {
        self.parse_mode = Some(parse_mode);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities(mut self, caption_entities: Vec<MessageEntity>) -> Self {
        self.caption_entities = Some(caption_entities);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup(mut self, reply_markup: InlineKeyboardMarkup) -> Self {
        self.reply_markup = Some(reply_markup);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    pub fn set_input_message_content(mut self, input_message_content: InputMessageContent) -> Self {
        self.input_message_content = Some(input_message_content);
        self
    }
    pub fn build(self) -> InlineQueryResultCachedGif {
        InlineQueryResultCachedGif {
            tg_type: self.tg_type,
            id: self.id,
            gif_file_id: self.gif_file_id,
            title: self.title,
            caption: self.caption,
            parse_mode: self.parse_mode,
            caption_entities: self.caption_entities,
            reply_markup: self.reply_markup,
            input_message_content: self.input_message_content,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a portion of the price for goods or services."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct LabeledPrice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Portion label"]
    #[serde(rename = "label")]
    label: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "amount")]
    amount: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to LabeledPrice that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipLabeledPrice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Portion label"]
    #[serde(rename = "label")]
    label: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "amount")]
    amount: i64,
}
impl From<NoSkipLabeledPrice> for LabeledPrice {
    fn from(t: NoSkipLabeledPrice) -> Self {
        Self {
            label: t.label,
            amount: t.amount,
        }
    }
}
impl Into<NoSkipLabeledPrice> for LabeledPrice {
    fn into(self) -> NoSkipLabeledPrice {
        NoSkipLabeledPrice {
            label: self.label,
            amount: self.amount,
        }
    }
}
impl NoSkipLabeledPrice {
    pub fn skip(self) -> LabeledPrice {
        self.into()
    }
}
impl LabeledPrice {
    pub fn noskip(self) -> NoSkipLabeledPrice {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents a portion of the price for goods or services."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct LabeledPriceBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Portion label"]
    #[serde(rename = "label")]
    label: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "amount")]
    amount: i64,
}
impl LabeledPriceBuilder {
    pub fn new(label: String, amount: i64) -> Self {
        Self { label, amount }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Portion label"]
    pub fn set_label(mut self, label: String) -> Self {
        self.label = label;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn set_amount(mut self, amount: i64) -> Self {
        self.amount = amount;
        self
    }
    pub fn build(self) -> LabeledPrice {
        LabeledPrice {
            label: self.label,
            amount: self.amount,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an answer of a user in a non-anonymous poll."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PollAnswer {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    #[serde(rename = "poll_id")]
    poll_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "voter_chat",
        default
    )]
    voter_chat: Option<Box<Chat>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "user", default)]
    user: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    #[serde(rename = "option_ids")]
    option_ids: Vec<i64>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PollAnswer that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPollAnswer {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    #[serde(rename = "poll_id")]
    poll_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    voter_chat: Option<Box<Chat>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    user: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    #[serde(rename = "option_ids")]
    option_ids: Vec<i64>,
}
impl From<NoSkipPollAnswer> for PollAnswer {
    fn from(t: NoSkipPollAnswer) -> Self {
        Self {
            poll_id: t.poll_id,
            voter_chat: t.voter_chat,
            user: t.user,
            option_ids: t.option_ids,
        }
    }
}
impl Into<NoSkipPollAnswer> for PollAnswer {
    fn into(self) -> NoSkipPollAnswer {
        NoSkipPollAnswer {
            poll_id: self.poll_id,
            voter_chat: self.voter_chat,
            user: self.user,
            option_ids: self.option_ids,
        }
    }
}
impl NoSkipPollAnswer {
    pub fn skip(self) -> PollAnswer {
        self.into()
    }
}
impl PollAnswer {
    pub fn noskip(self) -> NoSkipPollAnswer {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object represents an answer of a user in a non-anonymous poll."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PollAnswerBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    #[serde(rename = "poll_id")]
    poll_id: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "voter_chat",
        default
    )]
    voter_chat: Option<Box<Chat>>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    #[serde(skip_serializing_if = "Option::is_none", rename = "user", default)]
    user: Option<User>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    #[serde(rename = "option_ids")]
    option_ids: Vec<i64>,
}
impl PollAnswerBuilder {
    pub fn new(poll_id: String, option_ids: Vec<i64>) -> Self {
        Self {
            poll_id,
            option_ids,
            voter_chat: None,
            user: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    pub fn set_poll_id(mut self, poll_id: String) -> Self {
        self.poll_id = poll_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    pub fn set_voter_chat(mut self, voter_chat: Box<Chat>) -> Self {
        self.voter_chat = Some(voter_chat);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    pub fn set_user(mut self, user: User) -> Self {
        self.user = Some(user);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    pub fn set_option_ids(mut self, option_ids: Vec<i64>) -> Self {
        self.option_ids = option_ids;
        self
    }
    pub fn build(self) -> PollAnswer {
        PollAnswer {
            poll_id: self.poll_id,
            voter_chat: self.voter_chat,
            user: self.user,
            option_ids: self.option_ids,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains basic information about an invoice."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Invoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description"]
    #[serde(rename = "description")]
    description: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique bot deep-linking parameter that can be used to generate this invoice"]
    #[serde(rename = "start_parameter")]
    start_parameter: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "total_amount")]
    total_amount: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to Invoice that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipInvoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description"]
    #[serde(rename = "description")]
    description: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique bot deep-linking parameter that can be used to generate this invoice"]
    #[serde(rename = "start_parameter")]
    start_parameter: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "total_amount")]
    total_amount: i64,
}
impl From<NoSkipInvoice> for Invoice {
    fn from(t: NoSkipInvoice) -> Self {
        Self {
            title: t.title,
            description: t.description,
            start_parameter: t.start_parameter,
            currency: t.currency,
            total_amount: t.total_amount,
        }
    }
}
impl Into<NoSkipInvoice> for Invoice {
    fn into(self) -> NoSkipInvoice {
        NoSkipInvoice {
            title: self.title,
            description: self.description,
            start_parameter: self.start_parameter,
            currency: self.currency,
            total_amount: self.total_amount,
        }
    }
}
impl NoSkipInvoice {
    pub fn skip(self) -> Invoice {
        self.into()
    }
}
impl Invoice {
    pub fn noskip(self) -> NoSkipInvoice {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object contains basic information about an invoice."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct InvoiceBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name"]
    #[serde(rename = "title")]
    title: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description"]
    #[serde(rename = "description")]
    description: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique bot deep-linking parameter that can be used to generate this invoice"]
    #[serde(rename = "start_parameter")]
    start_parameter: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    #[serde(rename = "currency")]
    currency: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    #[serde(rename = "total_amount")]
    total_amount: i64,
}
impl InvoiceBuilder {
    pub fn new(
        title: String,
        description: String,
        start_parameter: String,
        currency: String,
        total_amount: i64,
    ) -> Self {
        Self {
            title,
            description,
            start_parameter,
            currency,
            total_amount,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name"]
    pub fn set_title(mut self, title: String) -> Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description"]
    pub fn set_description(mut self, description: String) -> Self {
        self.description = description;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique bot deep-linking parameter that can be used to generate this invoice"]
    pub fn set_start_parameter(mut self, start_parameter: String) -> Self {
        self.start_parameter = start_parameter;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn set_currency(mut self, currency: String) -> Self {
        self.currency = currency;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn set_total_amount(mut self, total_amount: i64) -> Self {
        self.total_amount = total_amount;
        self
    }
    pub fn build(self) -> Invoice {
        Invoice {
            title: self.title,
            description: self.description,
            start_parameter: self.start_parameter,
            currency: self.currency,
            total_amount: self.total_amount,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with the reverse side of a document. The error is considered resolved when the file with reverse side of the document changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorReverseSide {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to PassportElementErrorReverseSide that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipPassportElementErrorReverseSide {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl From<NoSkipPassportElementErrorReverseSide> for PassportElementErrorReverseSide {
    fn from(t: NoSkipPassportElementErrorReverseSide) -> Self {
        Self {
            source: t.source,
            tg_type: t.tg_type,
            file_hash: t.file_hash,
            message: t.message,
        }
    }
}
impl Into<NoSkipPassportElementErrorReverseSide> for PassportElementErrorReverseSide {
    fn into(self) -> NoSkipPassportElementErrorReverseSide {
        NoSkipPassportElementErrorReverseSide {
            source: self.source,
            tg_type: self.tg_type,
            file_hash: self.file_hash,
            message: self.message,
        }
    }
}
impl NoSkipPassportElementErrorReverseSide {
    pub fn skip(self) -> PassportElementErrorReverseSide {
        self.into()
    }
}
impl PassportElementErrorReverseSide {
    pub fn noskip(self) -> NoSkipPassportElementErrorReverseSide {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents an issue with the reverse side of a document. The error is considered resolved when the file with reverse side of the document changes."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PassportElementErrorReverseSideBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    #[serde(rename = "source")]
    source: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    #[serde(rename = "file_hash")]
    file_hash: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    #[serde(rename = "message")]
    message: String,
}
impl PassportElementErrorReverseSideBuilder {
    pub fn new(source: String, file_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorReverseSide".to_owned(),
            source,
            file_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    pub fn set_source(mut self, source: String) -> Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    pub fn set_file_hash(mut self, file_hash: String) -> Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message(mut self, message: String) -> Self {
        self.message = message;
        self
    }
    pub fn build(self) -> PassportElementErrorReverseSide {
        PassportElementErrorReverseSide {
            source: self.source,
            tg_type: self.tg_type,
            file_hash: self.file_hash,
            message: self.message,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Upon receiving a message with this object, Telegram clients will remove the current custom keyboard and display the default letter-keyboard. By default, custom keyboards are displayed until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are hidden immediately after the user presses a button (see ReplyKeyboardMarkup)."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ReplyKeyboardRemove {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"]
    #[serde(rename = "remove_keyboard")]
    remove_keyboard: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "selective", default)]
    selective: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to ReplyKeyboardRemove that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipReplyKeyboardRemove {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"]
    #[serde(rename = "remove_keyboard")]
    remove_keyboard: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."]
    selective: Option<bool>,
}
impl From<NoSkipReplyKeyboardRemove> for ReplyKeyboardRemove {
    fn from(t: NoSkipReplyKeyboardRemove) -> Self {
        Self {
            remove_keyboard: t.remove_keyboard,
            selective: t.selective,
        }
    }
}
impl Into<NoSkipReplyKeyboardRemove> for ReplyKeyboardRemove {
    fn into(self) -> NoSkipReplyKeyboardRemove {
        NoSkipReplyKeyboardRemove {
            remove_keyboard: self.remove_keyboard,
            selective: self.selective,
        }
    }
}
impl NoSkipReplyKeyboardRemove {
    pub fn skip(self) -> ReplyKeyboardRemove {
        self.into()
    }
}
impl ReplyKeyboardRemove {
    pub fn noskip(self) -> NoSkipReplyKeyboardRemove {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Upon receiving a message with this object, Telegram clients will remove the current custom keyboard and display the default letter-keyboard. By default, custom keyboards are displayed until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are hidden immediately after the user presses a button (see ReplyKeyboardMarkup)."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ReplyKeyboardRemoveBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"]
    #[serde(rename = "remove_keyboard")]
    remove_keyboard: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."]
    #[serde(skip_serializing_if = "Option::is_none", rename = "selective", default)]
    selective: Option<bool>,
}
impl ReplyKeyboardRemoveBuilder {
    pub fn new(remove_keyboard: bool) -> Self {
        Self {
            remove_keyboard,
            selective: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"]
    pub fn set_remove_keyboard(mut self, remove_keyboard: bool) -> Self {
        self.remove_keyboard = remove_keyboard;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."]
    pub fn set_selective(mut self, selective: bool) -> Self {
        self.selective = Some(selective);
        self
    }
    pub fn build(self) -> ReplyKeyboardRemove {
        ReplyKeyboardRemove {
            remove_keyboard: self.remove_keyboard,
            selective: self.selective,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object defines the criteria used to request a suitable chat. The identifier of the selected chat will be shared with the bot when the corresponding button is pressed. More about requesting chats: https://core.telegram.org/bots/features#chat-and-user-selection"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct KeyboardButtonRequestChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Pass True to request a channel chat, pass False to request a group or a supergroup chat."]
    #[serde(rename = "chat_is_channel")]
    chat_is_channel: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_is_forum",
        default
    )]
    chat_is_forum: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_has_username",
        default
    )]
    chat_has_username: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_is_created",
        default
    )]
    chat_is_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "user_administrator_rights",
        default
    )]
    user_administrator_rights: Option<ChatAdministratorRights>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "bot_administrator_rights",
        default
    )]
    bot_administrator_rights: Option<ChatAdministratorRights>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "bot_is_member",
        default
    )]
    bot_is_member: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to KeyboardButtonRequestChat that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipKeyboardButtonRequestChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Pass True to request a channel chat, pass False to request a group or a supergroup chat."]
    #[serde(rename = "chat_is_channel")]
    chat_is_channel: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."]
    chat_is_forum: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."]
    chat_has_username: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."]
    chat_is_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."]
    user_administrator_rights: Option<ChatAdministratorRights>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."]
    bot_administrator_rights: Option<ChatAdministratorRights>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."]
    bot_is_member: Option<bool>,
}
impl From<NoSkipKeyboardButtonRequestChat> for KeyboardButtonRequestChat {
    fn from(t: NoSkipKeyboardButtonRequestChat) -> Self {
        Self {
            request_id: t.request_id,
            chat_is_channel: t.chat_is_channel,
            chat_is_forum: t.chat_is_forum,
            chat_has_username: t.chat_has_username,
            chat_is_created: t.chat_is_created,
            user_administrator_rights: t.user_administrator_rights,
            bot_administrator_rights: t.bot_administrator_rights,
            bot_is_member: t.bot_is_member,
        }
    }
}
impl Into<NoSkipKeyboardButtonRequestChat> for KeyboardButtonRequestChat {
    fn into(self) -> NoSkipKeyboardButtonRequestChat {
        NoSkipKeyboardButtonRequestChat {
            request_id: self.request_id,
            chat_is_channel: self.chat_is_channel,
            chat_is_forum: self.chat_is_forum,
            chat_has_username: self.chat_has_username,
            chat_is_created: self.chat_is_created,
            user_administrator_rights: self.user_administrator_rights,
            bot_administrator_rights: self.bot_administrator_rights,
            bot_is_member: self.bot_is_member,
        }
    }
}
impl NoSkipKeyboardButtonRequestChat {
    pub fn skip(self) -> KeyboardButtonRequestChat {
        self.into()
    }
}
impl KeyboardButtonRequestChat {
    pub fn noskip(self) -> NoSkipKeyboardButtonRequestChat {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object defines the criteria used to request a suitable chat. The identifier of the selected chat will be shared with the bot when the corresponding button is pressed. More about requesting chats: https://core.telegram.org/bots/features#chat-and-user-selection"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct KeyboardButtonRequestChatBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Pass True to request a channel chat, pass False to request a group or a supergroup chat."]
    #[serde(rename = "chat_is_channel")]
    chat_is_channel: bool,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_is_forum",
        default
    )]
    chat_is_forum: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_has_username",
        default
    )]
    chat_has_username: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "chat_is_created",
        default
    )]
    chat_is_created: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "user_administrator_rights",
        default
    )]
    user_administrator_rights: Option<ChatAdministratorRights>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "bot_administrator_rights",
        default
    )]
    bot_administrator_rights: Option<ChatAdministratorRights>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "bot_is_member",
        default
    )]
    bot_is_member: Option<bool>,
}
impl KeyboardButtonRequestChatBuilder {
    pub fn new(request_id: i64, chat_is_channel: bool) -> Self {
        Self {
            request_id,
            chat_is_channel,
            chat_is_forum: None,
            chat_has_username: None,
            chat_is_created: None,
            user_administrator_rights: None,
            bot_administrator_rights: None,
            bot_is_member: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"]
    pub fn set_request_id(mut self, request_id: i64) -> Self {
        self.request_id = request_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Pass True to request a channel chat, pass False to request a group or a supergroup chat."]
    pub fn set_chat_is_channel(mut self, chat_is_channel: bool) -> Self {
        self.chat_is_channel = chat_is_channel;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."]
    pub fn set_chat_is_forum(mut self, chat_is_forum: bool) -> Self {
        self.chat_is_forum = Some(chat_is_forum);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."]
    pub fn set_chat_has_username(mut self, chat_has_username: bool) -> Self {
        self.chat_has_username = Some(chat_has_username);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."]
    pub fn set_chat_is_created(mut self, chat_is_created: bool) -> Self {
        self.chat_is_created = Some(chat_is_created);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."]
    pub fn set_user_administrator_rights(
        mut self,
        user_administrator_rights: ChatAdministratorRights,
    ) -> Self {
        self.user_administrator_rights = Some(user_administrator_rights);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."]
    pub fn set_bot_administrator_rights(
        mut self,
        bot_administrator_rights: ChatAdministratorRights,
    ) -> Self {
        self.bot_administrator_rights = Some(bot_administrator_rights);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."]
    pub fn set_bot_is_member(mut self, bot_is_member: bool) -> Self {
        self.bot_is_member = Some(bot_is_member);
        self
    }
    pub fn build(self) -> KeyboardButtonRequestChat {
        KeyboardButtonRequestChat {
            request_id: self.request_id,
            chat_is_channel: self.chat_is_channel,
            chat_is_forum: self.chat_is_forum,
            chat_has_username: self.chat_has_username,
            chat_is_created: self.chat_is_created,
            user_administrator_rights: self.user_administrator_rights,
            bot_administrator_rights: self.bot_administrator_rights,
            bot_is_member: self.bot_is_member,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object defines the criteria used to request a suitable user. The identifier of the selected user will be shared with the bot when the corresponding button is pressed. More about requesting users: https://core.telegram.org/bots/features#chat-and-user-selection"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct KeyboardButtonRequestUser {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "user_is_bot",
        default
    )]
    user_is_bot: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "user_is_premium",
        default
    )]
    user_is_premium: Option<bool>,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to KeyboardButtonRequestUser that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipKeyboardButtonRequestUser {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."]
    user_is_bot: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."]
    user_is_premium: Option<bool>,
}
impl From<NoSkipKeyboardButtonRequestUser> for KeyboardButtonRequestUser {
    fn from(t: NoSkipKeyboardButtonRequestUser) -> Self {
        Self {
            request_id: t.request_id,
            user_is_bot: t.user_is_bot,
            user_is_premium: t.user_is_premium,
        }
    }
}
impl Into<NoSkipKeyboardButtonRequestUser> for KeyboardButtonRequestUser {
    fn into(self) -> NoSkipKeyboardButtonRequestUser {
        NoSkipKeyboardButtonRequestUser {
            request_id: self.request_id,
            user_is_bot: self.user_is_bot,
            user_is_premium: self.user_is_premium,
        }
    }
}
impl NoSkipKeyboardButtonRequestUser {
    pub fn skip(self) -> KeyboardButtonRequestUser {
        self.into()
    }
}
impl KeyboardButtonRequestUser {
    pub fn noskip(self) -> NoSkipKeyboardButtonRequestUser {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "This object defines the criteria used to request a suitable user. The identifier of the selected user will be shared with the bot when the corresponding button is pressed. More about requesting users: https://core.telegram.org/bots/features#chat-and-user-selection"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct KeyboardButtonRequestUserBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"]
    #[serde(rename = "request_id")]
    request_id: i64,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "user_is_bot",
        default
    )]
    user_is_bot: Option<bool>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."]
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "user_is_premium",
        default
    )]
    user_is_premium: Option<bool>,
}
impl KeyboardButtonRequestUserBuilder {
    pub fn new(request_id: i64) -> Self {
        Self {
            request_id,
            user_is_bot: None,
            user_is_premium: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"]
    pub fn set_request_id(mut self, request_id: i64) -> Self {
        self.request_id = request_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."]
    pub fn set_user_is_bot(mut self, user_is_bot: bool) -> Self {
        self.user_is_bot = Some(user_is_bot);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."]
    pub fn set_user_is_premium(mut self, user_is_premium: bool) -> Self {
        self.user_is_premium = Some(user_is_premium);
        self
    }
    pub fn build(self) -> KeyboardButtonRequestUser {
        KeyboardButtonRequestUser {
            request_id: self.request_id,
            user_is_bot: self.user_is_bot,
            user_is_premium: self.user_is_premium,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering all group and supergroup chats."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeAllGroupChats {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    #[serde(rename = "type")]
    tg_type: String,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotCommandScopeAllGroupChats that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotCommandScopeAllGroupChats {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl From<NoSkipBotCommandScopeAllGroupChats> for BotCommandScopeAllGroupChats {
    fn from(t: NoSkipBotCommandScopeAllGroupChats) -> Self {
        Self { tg_type: t.tg_type }
    }
}
impl Into<NoSkipBotCommandScopeAllGroupChats> for BotCommandScopeAllGroupChats {
    fn into(self) -> NoSkipBotCommandScopeAllGroupChats {
        NoSkipBotCommandScopeAllGroupChats {
            tg_type: self.tg_type,
        }
    }
}
impl NoSkipBotCommandScopeAllGroupChats {
    pub fn skip(self) -> BotCommandScopeAllGroupChats {
        self.into()
    }
}
impl BotCommandScopeAllGroupChats {
    pub fn noskip(self) -> NoSkipBotCommandScopeAllGroupChats {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering all group and supergroup chats."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeAllGroupChatsBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    #[serde(rename = "type")]
    tg_type: String,
}
impl BotCommandScopeAllGroupChatsBuilder {
    pub fn new() -> Self {
        Self {
            tg_type: "all_group_chats".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    pub fn build(self) -> BotCommandScopeAllGroupChats {
        BotCommandScopeAllGroupChats {
            tg_type: self.tg_type,
        }
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering a specific member of a group or supergroup chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeChatMember {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    #[serde(rename = "chat_id")]
    chat_id: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    #[serde(rename = "user_id")]
    user_id: i64,
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Companion type to BotCommandScopeChatMember that doesn't skip fields when serializing. \n                Used for certain deserializers that use arrays to represent struct members"]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NoSkipBotCommandScopeChatMember {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    #[serde(rename = "chat_id")]
    chat_id: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    #[serde(rename = "user_id")]
    user_id: i64,
}
impl From<NoSkipBotCommandScopeChatMember> for BotCommandScopeChatMember {
    fn from(t: NoSkipBotCommandScopeChatMember) -> Self {
        Self {
            tg_type: t.tg_type,
            chat_id: t.chat_id,
            user_id: t.user_id,
        }
    }
}
impl Into<NoSkipBotCommandScopeChatMember> for BotCommandScopeChatMember {
    fn into(self) -> NoSkipBotCommandScopeChatMember {
        NoSkipBotCommandScopeChatMember {
            tg_type: self.tg_type,
            chat_id: self.chat_id,
            user_id: self.user_id,
        }
    }
}
impl NoSkipBotCommandScopeChatMember {
    pub fn skip(self) -> BotCommandScopeChatMember {
        self.into()
    }
}
impl BotCommandScopeChatMember {
    pub fn noskip(self) -> NoSkipBotCommandScopeChatMember {
        self.into()
    }
}
#[allow(rustdoc::invalid_html_tags)]
#[doc = "Represents the scope of bot commands, covering a specific member of a group or supergroup chat."]
#[derive(Serialize, Deserialize, Debug, Default, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct BotCommandScopeChatMemberBuilder {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    #[serde(rename = "type")]
    tg_type: String,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    #[serde(rename = "chat_id")]
    chat_id: ::ordered_float::OrderedFloat<f64>,
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    #[serde(rename = "user_id")]
    user_id: i64,
}
impl BotCommandScopeChatMemberBuilder {
    pub fn new(chat_id: ::ordered_float::OrderedFloat<f64>, user_id: i64) -> Self {
        Self {
            tg_type: "chat_member".to_owned(),
            chat_id,
            user_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    pub fn set_type(mut self, tg_type: String) -> Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn set_chat_id(mut self, chat_id: ::ordered_float::OrderedFloat<f64>) -> Self {
        self.chat_id = chat_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    pub fn set_user_id(mut self, user_id: i64) -> Self {
        self.user_id = user_id;
        self
    }
    pub fn build(self) -> BotCommandScopeChatMember {
        BotCommandScopeChatMember {
            tg_type: self.tg_type,
            chat_id: self.chat_id,
            user_id: self.user_id,
        }
    }
}
#[allow(dead_code)]
impl LoginUrl {
    pub fn new(url: String) -> Self {
        Self {
            url,
            forward_text: None,
            bot_username: None,
            request_write_access: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (url, forward_text, bot_username, request_write_access)"]
    pub fn into_tuple(self) -> (String, Option<String>, Option<String>, Option<bool>) {
        (
            self.url,
            self.forward_text.map(|forward_text| forward_text),
            self.bot_username.map(|bot_username| bot_username),
            self.request_write_access
                .map(|request_write_access| request_write_access),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."]
    pub fn get_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."]
    pub fn get_url_ref<'a>(&'a self) -> &'a str {
        self.url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."]
    pub fn set_url<'a>(&'a mut self, url: String) -> &'a mut Self {
        self.url = url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New text of the button in forwarded messages."]
    pub fn get_forward_text<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.forward_text
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New text of the button in forwarded messages."]
    pub fn get_forward_text_ref<'a>(&'a self) -> Option<&'a str> {
        self.forward_text.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New text of the button in forwarded messages."]
    pub fn set_forward_text<'a>(&'a mut self, forward_text: Option<String>) -> &'a mut Self {
        self.forward_text = if let Some(forward_text) = forward_text {
            Some(forward_text)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."]
    pub fn get_bot_username<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.bot_username
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."]
    pub fn get_bot_username_ref<'a>(&'a self) -> Option<&'a str> {
        self.bot_username.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."]
    pub fn set_bot_username<'a>(&'a mut self, bot_username: Option<String>) -> &'a mut Self {
        self.bot_username = if let Some(bot_username) = bot_username {
            Some(bot_username)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request the permission for your bot to send messages to the user."]
    pub fn get_request_write_access<'a>(&'a self) -> Option<bool> {
        self.request_write_access.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request the permission for your bot to send messages to the user."]
    pub fn get_request_write_access_ref<'a>(&'a self) -> Option<bool> {
        self.request_write_access.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request the permission for your bot to send messages to the user."]
    pub fn set_request_write_access<'a>(
        &'a mut self,
        request_write_access: Option<bool>,
    ) -> &'a mut Self {
        self.request_write_access = if let Some(request_write_access) = request_write_access {
            Some(request_write_access)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl BotCommandScopeChat {
    pub fn new(chat_id: ::ordered_float::OrderedFloat<f64>) -> Self {
        Self {
            tg_type: "chat".to_owned(),
            chat_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, chat_id)"]
    pub fn into_tuple(self) -> (String, ::ordered_float::OrderedFloat<f64>) {
        (self.tg_type, self.chat_id)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn get_chat_id<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn get_chat_id_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn set_chat_id<'a>(
        &'a mut self,
        chat_id: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.chat_id = chat_id;
        self
    }
}
#[allow(dead_code)]
impl ChatPermissions {
    pub fn new() -> Self {
        Self {
            can_send_messages: None,
            can_send_audios: None,
            can_send_documents: None,
            can_send_photos: None,
            can_send_videos: None,
            can_send_video_notes: None,
            can_send_voice_notes: None,
            can_send_polls: None,
            can_send_other_messages: None,
            can_add_web_page_previews: None,
            can_change_info: None,
            can_invite_users: None,
            can_pin_messages: None,
            can_manage_topics: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, can_send_voice_notes, can_send_polls, can_send_other_messages, can_add_web_page_previews, can_change_info, can_invite_users, can_pin_messages, can_manage_topics)"]
    pub fn into_tuple(
        self,
    ) -> (
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    ) {
        (
            self.can_send_messages
                .map(|can_send_messages| can_send_messages),
            self.can_send_audios.map(|can_send_audios| can_send_audios),
            self.can_send_documents
                .map(|can_send_documents| can_send_documents),
            self.can_send_photos.map(|can_send_photos| can_send_photos),
            self.can_send_videos.map(|can_send_videos| can_send_videos),
            self.can_send_video_notes
                .map(|can_send_video_notes| can_send_video_notes),
            self.can_send_voice_notes
                .map(|can_send_voice_notes| can_send_voice_notes),
            self.can_send_polls.map(|can_send_polls| can_send_polls),
            self.can_send_other_messages
                .map(|can_send_other_messages| can_send_other_messages),
            self.can_add_web_page_previews
                .map(|can_add_web_page_previews| can_add_web_page_previews),
            self.can_change_info.map(|can_change_info| can_change_info),
            self.can_invite_users
                .map(|can_invite_users| can_invite_users),
            self.can_pin_messages
                .map(|can_pin_messages| can_pin_messages),
            self.can_manage_topics
                .map(|can_manage_topics| can_manage_topics),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    pub fn get_can_send_messages<'a>(&'a self) -> Option<bool> {
        self.can_send_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    pub fn get_can_send_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_send_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    pub fn set_can_send_messages<'a>(
        &'a mut self,
        can_send_messages: Option<bool>,
    ) -> &'a mut Self {
        self.can_send_messages = if let Some(can_send_messages) = can_send_messages {
            Some(can_send_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send audios"]
    pub fn get_can_send_audios<'a>(&'a self) -> Option<bool> {
        self.can_send_audios.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send audios"]
    pub fn get_can_send_audios_ref<'a>(&'a self) -> Option<bool> {
        self.can_send_audios.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send audios"]
    pub fn set_can_send_audios<'a>(&'a mut self, can_send_audios: Option<bool>) -> &'a mut Self {
        self.can_send_audios = if let Some(can_send_audios) = can_send_audios {
            Some(can_send_audios)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send documents"]
    pub fn get_can_send_documents<'a>(&'a self) -> Option<bool> {
        self.can_send_documents.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send documents"]
    pub fn get_can_send_documents_ref<'a>(&'a self) -> Option<bool> {
        self.can_send_documents.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send documents"]
    pub fn set_can_send_documents<'a>(
        &'a mut self,
        can_send_documents: Option<bool>,
    ) -> &'a mut Self {
        self.can_send_documents = if let Some(can_send_documents) = can_send_documents {
            Some(can_send_documents)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send photos"]
    pub fn get_can_send_photos<'a>(&'a self) -> Option<bool> {
        self.can_send_photos.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send photos"]
    pub fn get_can_send_photos_ref<'a>(&'a self) -> Option<bool> {
        self.can_send_photos.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send photos"]
    pub fn set_can_send_photos<'a>(&'a mut self, can_send_photos: Option<bool>) -> &'a mut Self {
        self.can_send_photos = if let Some(can_send_photos) = can_send_photos {
            Some(can_send_photos)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send videos"]
    pub fn get_can_send_videos<'a>(&'a self) -> Option<bool> {
        self.can_send_videos.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send videos"]
    pub fn get_can_send_videos_ref<'a>(&'a self) -> Option<bool> {
        self.can_send_videos.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send videos"]
    pub fn set_can_send_videos<'a>(&'a mut self, can_send_videos: Option<bool>) -> &'a mut Self {
        self.can_send_videos = if let Some(can_send_videos) = can_send_videos {
            Some(can_send_videos)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send video notes"]
    pub fn get_can_send_video_notes<'a>(&'a self) -> Option<bool> {
        self.can_send_video_notes.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send video notes"]
    pub fn get_can_send_video_notes_ref<'a>(&'a self) -> Option<bool> {
        self.can_send_video_notes.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send video notes"]
    pub fn set_can_send_video_notes<'a>(
        &'a mut self,
        can_send_video_notes: Option<bool>,
    ) -> &'a mut Self {
        self.can_send_video_notes = if let Some(can_send_video_notes) = can_send_video_notes {
            Some(can_send_video_notes)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send voice notes"]
    pub fn get_can_send_voice_notes<'a>(&'a self) -> Option<bool> {
        self.can_send_voice_notes.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send voice notes"]
    pub fn get_can_send_voice_notes_ref<'a>(&'a self) -> Option<bool> {
        self.can_send_voice_notes.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send voice notes"]
    pub fn set_can_send_voice_notes<'a>(
        &'a mut self,
        can_send_voice_notes: Option<bool>,
    ) -> &'a mut Self {
        self.can_send_voice_notes = if let Some(can_send_voice_notes) = can_send_voice_notes {
            Some(can_send_voice_notes)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send polls"]
    pub fn get_can_send_polls<'a>(&'a self) -> Option<bool> {
        self.can_send_polls.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send polls"]
    pub fn get_can_send_polls_ref<'a>(&'a self) -> Option<bool> {
        self.can_send_polls.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send polls"]
    pub fn set_can_send_polls<'a>(&'a mut self, can_send_polls: Option<bool>) -> &'a mut Self {
        self.can_send_polls = if let Some(can_send_polls) = can_send_polls {
            Some(can_send_polls)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"]
    pub fn get_can_send_other_messages<'a>(&'a self) -> Option<bool> {
        self.can_send_other_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"]
    pub fn get_can_send_other_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_send_other_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"]
    pub fn set_can_send_other_messages<'a>(
        &'a mut self,
        can_send_other_messages: Option<bool>,
    ) -> &'a mut Self {
        self.can_send_other_messages =
            if let Some(can_send_other_messages) = can_send_other_messages {
                Some(can_send_other_messages)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to add web page previews to their messages"]
    pub fn get_can_add_web_page_previews<'a>(&'a self) -> Option<bool> {
        self.can_add_web_page_previews.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to add web page previews to their messages"]
    pub fn get_can_add_web_page_previews_ref<'a>(&'a self) -> Option<bool> {
        self.can_add_web_page_previews.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to add web page previews to their messages"]
    pub fn set_can_add_web_page_previews<'a>(
        &'a mut self,
        can_add_web_page_previews: Option<bool>,
    ) -> &'a mut Self {
        self.can_add_web_page_previews =
            if let Some(can_add_web_page_previews) = can_add_web_page_previews {
                Some(can_add_web_page_previews)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"]
    pub fn get_can_change_info<'a>(&'a self) -> Option<bool> {
        self.can_change_info.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"]
    pub fn get_can_change_info_ref<'a>(&'a self) -> Option<bool> {
        self.can_change_info.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"]
    pub fn set_can_change_info<'a>(&'a mut self, can_change_info: Option<bool>) -> &'a mut Self {
        self.can_change_info = if let Some(can_change_info) = can_change_info {
            Some(can_change_info)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to invite new users to the chat"]
    pub fn get_can_invite_users<'a>(&'a self) -> Option<bool> {
        self.can_invite_users.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to invite new users to the chat"]
    pub fn get_can_invite_users_ref<'a>(&'a self) -> Option<bool> {
        self.can_invite_users.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to invite new users to the chat"]
    pub fn set_can_invite_users<'a>(&'a mut self, can_invite_users: Option<bool>) -> &'a mut Self {
        self.can_invite_users = if let Some(can_invite_users) = can_invite_users {
            Some(can_invite_users)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"]
    pub fn get_can_pin_messages<'a>(&'a self) -> Option<bool> {
        self.can_pin_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"]
    pub fn get_can_pin_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_pin_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"]
    pub fn set_can_pin_messages<'a>(&'a mut self, can_pin_messages: Option<bool>) -> &'a mut Self {
        self.can_pin_messages = if let Some(can_pin_messages) = can_pin_messages {
            Some(can_pin_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"]
    pub fn get_can_manage_topics<'a>(&'a self) -> Option<bool> {
        self.can_manage_topics.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"]
    pub fn get_can_manage_topics_ref<'a>(&'a self) -> Option<bool> {
        self.can_manage_topics.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"]
    pub fn set_can_manage_topics<'a>(
        &'a mut self,
        can_manage_topics: Option<bool>,
    ) -> &'a mut Self {
        self.can_manage_topics = if let Some(can_manage_topics) = can_manage_topics {
            Some(can_manage_topics)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl Audio {
    pub fn new(file_id: String, file_unique_id: String, duration: i64) -> Self {
        Self {
            file_id,
            file_unique_id,
            duration,
            performer: None,
            title: None,
            file_name: None,
            mime_type: None,
            file_size: None,
            thumbnail: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, duration, performer, title, file_name, mime_type, file_size, thumbnail)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        i64,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<i64>,
        Option<PhotoSize>,
    ) {
        (
            self.file_id,
            self.file_unique_id,
            self.duration,
            self.performer.map(|performer| performer),
            self.title.map(|title| title),
            self.file_name.map(|file_name| file_name),
            self.mime_type.map(|mime_type| mime_type),
            self.file_size.map(|file_size| file_size),
            self.thumbnail.map(|thumbnail| thumbnail),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id_ref<'a>(&'a self) -> &'a str {
        self.file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    pub fn get_duration<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    pub fn get_duration_ref<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    pub fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self {
        self.duration = duration;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio as defined by sender or by audio tags"]
    pub fn get_performer<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.performer.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio as defined by sender or by audio tags"]
    pub fn get_performer_ref<'a>(&'a self) -> Option<&'a str> {
        self.performer.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio as defined by sender or by audio tags"]
    pub fn set_performer<'a>(&'a mut self, performer: Option<String>) -> &'a mut Self {
        self.performer = if let Some(performer) = performer {
            Some(performer)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio as defined by sender or by audio tags"]
    pub fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio as defined by sender or by audio tags"]
    pub fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio as defined by sender or by audio tags"]
    pub fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn get_file_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.file_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn get_file_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.file_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn set_file_name<'a>(&'a mut self, file_name: Option<String>) -> &'a mut Self {
        self.file_name = if let Some(file_name) = file_name {
            Some(file_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn get_mime_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.mime_type.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn get_mime_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.mime_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn set_mime_type<'a>(&'a mut self, mime_type: Option<String>) -> &'a mut Self {
        self.mime_type = if let Some(mime_type) = mime_type {
            Some(mime_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size_ref<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self {
        self.file_size = if let Some(file_size) = file_size {
            Some(file_size)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the album cover to which the music file belongs"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the album cover to which the music file belongs"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a PhotoSize> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the album cover to which the music file belongs"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InputContactMessageContent {
    pub fn new(phone_number: String, first_name: String) -> Self {
        Self {
            phone_number,
            first_name,
            last_name: None,
            vcard: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (phone_number, first_name, last_name, vcard)"]
    pub fn into_tuple(self) -> (String, String, Option<String>, Option<String>) {
        (
            self.phone_number,
            self.first_name,
            self.last_name.map(|last_name| last_name),
            self.vcard.map(|vcard| vcard),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn get_phone_number<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.phone_number.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn get_phone_number_ref<'a>(&'a self) -> &'a str {
        self.phone_number.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn set_phone_number<'a>(&'a mut self, phone_number: String) -> &'a mut Self {
        self.phone_number = phone_number;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn get_first_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.first_name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn get_first_name_ref<'a>(&'a self) -> &'a str {
        self.first_name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn set_first_name<'a>(&'a mut self, first_name: String) -> &'a mut Self {
        self.first_name = first_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.last_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn get_last_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.last_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self {
        self.last_name = if let Some(last_name) = last_name {
            Some(last_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    pub fn get_vcard<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.vcard.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    pub fn get_vcard_ref<'a>(&'a self) -> Option<&'a str> {
        self.vcard.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    pub fn set_vcard<'a>(&'a mut self, vcard: Option<String>) -> &'a mut Self {
        self.vcard = if let Some(vcard) = vcard {
            Some(vcard)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InputMediaPhoto {
    pub fn new(media: Option<InputFile>) -> Self {
        Self {
            tg_type: "photo".to_owned(),
            media,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            has_spoiler: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, caption, parse_mode, caption_entities, has_spoiler)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
    ) {
        (
            self.tg_type,
            self.media,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.has_spoiler.map(|has_spoiler| has_spoiler),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>> {
        Cow::Borrowed(&self.media)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_media_ref<'a>(&'a self) -> &'a Option<InputFile> {
        &self.media
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    pub fn get_has_spoiler<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    pub fn get_has_spoiler_ref<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    pub fn set_has_spoiler<'a>(&'a mut self, has_spoiler: Option<bool>) -> &'a mut Self {
        self.has_spoiler = if let Some(has_spoiler) = has_spoiler {
            Some(has_spoiler)
        } else {
            None
        };
        self
    }
    fn to_form(self, data: Form) -> Result<(Form, String)> {
        match self.media {
            Some(InputFile::Bytes(FileBytes {
                name,
                bytes: Some(bytes),
            })) => {
                let attach = format!("attach://{}", name);
                let form = data.part(name, Part::bytes(bytes));
                Ok((form, attach))
            }
            Some(InputFile::String(name)) => Ok((data, name)),
            _ => Err(anyhow!("cry")),
        }
    }
}
#[allow(dead_code)]
impl OrderInfo {
    pub fn new() -> Self {
        Self {
            name: None,
            phone_number: None,
            email: None,
            shipping_address: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (name, phone_number, email, shipping_address)"]
    pub fn into_tuple(
        self,
    ) -> (
        Option<String>,
        Option<String>,
        Option<String>,
        Option<ShippingAddress>,
    ) {
        (
            self.name.map(|name| name),
            self.phone_number.map(|phone_number| phone_number),
            self.email.map(|email| email),
            self.shipping_address
                .map(|shipping_address| shipping_address),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User name"]
    pub fn get_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User name"]
    pub fn get_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User name"]
    pub fn set_name<'a>(&'a mut self, name: Option<String>) -> &'a mut Self {
        self.name = if let Some(name) = name {
            Some(name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's phone number"]
    pub fn get_phone_number<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.phone_number
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's phone number"]
    pub fn get_phone_number_ref<'a>(&'a self) -> Option<&'a str> {
        self.phone_number.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's phone number"]
    pub fn set_phone_number<'a>(&'a mut self, phone_number: Option<String>) -> &'a mut Self {
        self.phone_number = if let Some(phone_number) = phone_number {
            Some(phone_number)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User email"]
    pub fn get_email<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.email.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User email"]
    pub fn get_email_ref<'a>(&'a self) -> Option<&'a str> {
        self.email.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User email"]
    pub fn set_email<'a>(&'a mut self, email: Option<String>) -> &'a mut Self {
        self.email = if let Some(email) = email {
            Some(email)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User shipping address"]
    pub fn get_shipping_address<'a>(&'a self) -> Option<Cow<'a, ShippingAddress>> {
        self.shipping_address.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User shipping address"]
    pub fn get_shipping_address_ref<'a>(&'a self) -> Option<&'a ShippingAddress> {
        self.shipping_address.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User shipping address"]
    pub fn set_shipping_address<'a>(
        &'a mut self,
        shipping_address: Option<ShippingAddress>,
    ) -> &'a mut Self {
        self.shipping_address = if let Some(shipping_address) = shipping_address {
            Some(shipping_address)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ForumTopic {
    pub fn new(message_thread_id: i64, name: String, icon_color: i64) -> Self {
        Self {
            message_thread_id,
            name,
            icon_color,
            icon_custom_emoji_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_thread_id, name, icon_color, icon_custom_emoji_id)"]
    pub fn into_tuple(self) -> (i64, String, i64, Option<String>) {
        (
            self.message_thread_id,
            self.name,
            self.icon_color,
            self.icon_custom_emoji_id
                .map(|icon_custom_emoji_id| icon_custom_emoji_id),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the forum topic"]
    pub fn get_message_thread_id<'a>(&'a self) -> i64 {
        self.message_thread_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the forum topic"]
    pub fn get_message_thread_id_ref<'a>(&'a self) -> i64 {
        self.message_thread_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the forum topic"]
    pub fn set_message_thread_id<'a>(&'a mut self, message_thread_id: i64) -> &'a mut Self {
        self.message_thread_id = message_thread_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    pub fn get_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    pub fn get_name_ref<'a>(&'a self) -> &'a str {
        self.name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    pub fn set_name<'a>(&'a mut self, name: String) -> &'a mut Self {
        self.name = name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    pub fn get_icon_color<'a>(&'a self) -> i64 {
        self.icon_color
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    pub fn get_icon_color_ref<'a>(&'a self) -> i64 {
        self.icon_color
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    pub fn set_icon_color<'a>(&'a mut self, icon_color: i64) -> &'a mut Self {
        self.icon_color = icon_color;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    pub fn get_icon_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.icon_custom_emoji_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    pub fn get_icon_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.icon_custom_emoji_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    pub fn set_icon_custom_emoji_id<'a>(
        &'a mut self,
        icon_custom_emoji_id: Option<String>,
    ) -> &'a mut Self {
        self.icon_custom_emoji_id = if let Some(icon_custom_emoji_id) = icon_custom_emoji_id {
            Some(icon_custom_emoji_id)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl WriteAccessAllowed {
    pub fn new() -> Self {
        Self {
            from_request: None,
            web_app_name: None,
            from_attachment_menu: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (from_request, web_app_name, from_attachment_menu)"]
    pub fn into_tuple(self) -> (Option<bool>, Option<String>, Option<bool>) {
        (
            self.from_request.map(|from_request| from_request),
            self.web_app_name.map(|web_app_name| web_app_name),
            self.from_attachment_menu
                .map(|from_attachment_menu| from_attachment_menu),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"]
    pub fn get_from_request<'a>(&'a self) -> Option<bool> {
        self.from_request.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"]
    pub fn get_from_request_ref<'a>(&'a self) -> Option<bool> {
        self.from_request.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"]
    pub fn set_from_request<'a>(&'a mut self, from_request: Option<bool>) -> &'a mut Self {
        self.from_request = if let Some(from_request) = from_request {
            Some(from_request)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"]
    pub fn get_web_app_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.web_app_name
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"]
    pub fn get_web_app_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.web_app_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"]
    pub fn set_web_app_name<'a>(&'a mut self, web_app_name: Option<String>) -> &'a mut Self {
        self.web_app_name = if let Some(web_app_name) = web_app_name {
            Some(web_app_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted when the bot was added to the attachment or side menu"]
    pub fn get_from_attachment_menu<'a>(&'a self) -> Option<bool> {
        self.from_attachment_menu.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted when the bot was added to the attachment or side menu"]
    pub fn get_from_attachment_menu_ref<'a>(&'a self) -> Option<bool> {
        self.from_attachment_menu.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the access was granted when the bot was added to the attachment or side menu"]
    pub fn set_from_attachment_menu<'a>(
        &'a mut self,
        from_attachment_menu: Option<bool>,
    ) -> &'a mut Self {
        self.from_attachment_menu = if let Some(from_attachment_menu) = from_attachment_menu {
            Some(from_attachment_menu)
        } else {
            None
        };
        self
    }
}
impl TraitBotCommandScopeDefault for BotCommandScopeDefault {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
impl TraitBotCommandScopeAllPrivateChats for BotCommandScopeAllPrivateChats {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
impl TraitBotCommandScopeAllGroupChats for BotCommandScopeAllGroupChats {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
impl TraitBotCommandScopeAllChatAdministrators for BotCommandScopeAllChatAdministrators {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
impl TraitBotCommandScopeChat for BotCommandScopeChat {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, chat_id)"]
    fn into_tuple(self) -> (String, ::ordered_float::OrderedFloat<f64>) {
        (self.tg_type, self.chat_id)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn set_chat_id<'a>(&'a mut self, chat_id: ::ordered_float::OrderedFloat<f64>) -> &'a mut Self {
        self.chat_id = chat_id;
        self
    }
}
impl TraitBotCommandScopeChatAdministrators for BotCommandScopeChatAdministrators {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, chat_id)"]
    fn into_tuple(self) -> (String, ::ordered_float::OrderedFloat<f64>) {
        (self.tg_type, self.chat_id)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn set_chat_id<'a>(&'a mut self, chat_id: ::ordered_float::OrderedFloat<f64>) -> &'a mut Self {
        self.chat_id = chat_id;
        self
    }
}
impl TraitBotCommandScopeChatMember for BotCommandScopeChatMember {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, chat_id, user_id)"]
    fn into_tuple(self) -> (String, ::ordered_float::OrderedFloat<f64>, i64) {
        (self.tg_type, self.chat_id, self.user_id)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn get_chat_id_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    fn set_chat_id<'a>(&'a mut self, chat_id: ::ordered_float::OrderedFloat<f64>) -> &'a mut Self {
        self.chat_id = chat_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    fn get_user_id<'a>(&'a self) -> i64 {
        self.user_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    fn get_user_id_ref<'a>(&'a self) -> i64 {
        self.user_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    fn set_user_id<'a>(&'a mut self, user_id: i64) -> &'a mut Self {
        self.user_id = user_id;
        self
    }
}
#[allow(dead_code)]
impl InputMediaAudio {
    pub fn new(media: Option<InputFile>) -> Self {
        Self {
            tg_type: "audio".to_owned(),
            media,
            thumbnail: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            duration: None,
            performer: None,
            title: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, duration, performer, title)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<String>,
        Option<String>,
    ) {
        (
            self.tg_type,
            self.media,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.duration.map(|duration| duration),
            self.performer.map(|performer| performer),
            self.title.map(|title| title),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>> {
        Cow::Borrowed(&self.media)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_media_ref<'a>(&'a self) -> &'a Option<InputFile> {
        &self.media
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a InputFile> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    pub fn get_duration<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    pub fn get_duration_ref<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    pub fn set_duration<'a>(&'a mut self, duration: Option<i64>) -> &'a mut Self {
        self.duration = if let Some(duration) = duration {
            Some(duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    pub fn get_performer<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.performer.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    pub fn get_performer_ref<'a>(&'a self) -> Option<&'a str> {
        self.performer.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    pub fn set_performer<'a>(&'a mut self, performer: Option<String>) -> &'a mut Self {
        self.performer = if let Some(performer) = performer {
            Some(performer)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    pub fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    pub fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    pub fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    fn to_form(self, data: Form) -> Result<(Form, String)> {
        match self.media {
            Some(InputFile::Bytes(FileBytes {
                name,
                bytes: Some(bytes),
            })) => {
                let attach = format!("attach://{}", name);
                let form = data.part(name, Part::bytes(bytes));
                Ok((form, attach))
            }
            Some(InputFile::String(name)) => Ok((data, name)),
            _ => Err(anyhow!("cry")),
        }
    }
}
impl TraitInputMediaAnimation for InputMediaAnimation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, width, height, duration, has_spoiler)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
    ) {
        (
            self.tg_type,
            self.media,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.width.map(|width| width),
            self.height.map(|height| height),
            self.duration.map(|duration| duration),
            self.has_spoiler.map(|has_spoiler| has_spoiler),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>> {
        Cow::Borrowed(&self.media)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media_ref<'a>(&'a self) -> &'a Option<InputFile> {
        &self.media
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a InputFile> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    fn get_width<'a>(&'a self) -> Option<i64> {
        self.width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    fn get_width_ref<'a>(&'a self) -> Option<i64> {
        self.width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    fn set_width<'a>(&'a mut self, width: Option<i64>) -> &'a mut Self {
        self.width = if let Some(width) = width {
            Some(width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    fn get_height<'a>(&'a self) -> Option<i64> {
        self.height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    fn get_height_ref<'a>(&'a self) -> Option<i64> {
        self.height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    fn set_height<'a>(&'a mut self, height: Option<i64>) -> &'a mut Self {
        self.height = if let Some(height) = height {
            Some(height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    fn get_duration<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    fn get_duration_ref<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    fn set_duration<'a>(&'a mut self, duration: Option<i64>) -> &'a mut Self {
        self.duration = if let Some(duration) = duration {
            Some(duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    fn get_has_spoiler<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    fn get_has_spoiler_ref<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    fn set_has_spoiler<'a>(&'a mut self, has_spoiler: Option<bool>) -> &'a mut Self {
        self.has_spoiler = if let Some(has_spoiler) = has_spoiler {
            Some(has_spoiler)
        } else {
            None
        };
        self
    }
}
impl TraitInputMediaDocument for InputMediaDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, disable_content_type_detection)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
    ) {
        (
            self.tg_type,
            self.media,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.disable_content_type_detection
                .map(|disable_content_type_detection| disable_content_type_detection),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>> {
        Cow::Borrowed(&self.media)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media_ref<'a>(&'a self) -> &'a Option<InputFile> {
        &self.media
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a InputFile> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    fn get_disable_content_type_detection<'a>(&'a self) -> Option<bool> {
        self.disable_content_type_detection.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    fn get_disable_content_type_detection_ref<'a>(&'a self) -> Option<bool> {
        self.disable_content_type_detection.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    fn set_disable_content_type_detection<'a>(
        &'a mut self,
        disable_content_type_detection: Option<bool>,
    ) -> &'a mut Self {
        self.disable_content_type_detection =
            if let Some(disable_content_type_detection) = disable_content_type_detection {
                Some(disable_content_type_detection)
            } else {
                None
            };
        self
    }
}
impl TraitInputMediaAudio for InputMediaAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, duration, performer, title)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<String>,
        Option<String>,
    ) {
        (
            self.tg_type,
            self.media,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.duration.map(|duration| duration),
            self.performer.map(|performer| performer),
            self.title.map(|title| title),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>> {
        Cow::Borrowed(&self.media)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media_ref<'a>(&'a self) -> &'a Option<InputFile> {
        &self.media
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a InputFile> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    fn get_duration<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    fn get_duration_ref<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the audio in seconds"]
    fn set_duration<'a>(&'a mut self, duration: Option<i64>) -> &'a mut Self {
        self.duration = if let Some(duration) = duration {
            Some(duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    fn get_performer<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.performer.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    fn get_performer_ref<'a>(&'a self) -> Option<&'a str> {
        self.performer.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer of the audio"]
    fn set_performer<'a>(&'a mut self, performer: Option<String>) -> &'a mut Self {
        self.performer = if let Some(performer) = performer {
            Some(performer)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title of the audio"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
}
impl TraitInputMediaPhoto for InputMediaPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, caption, parse_mode, caption_entities, has_spoiler)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
    ) {
        (
            self.tg_type,
            self.media,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.has_spoiler.map(|has_spoiler| has_spoiler),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>> {
        Cow::Borrowed(&self.media)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media_ref<'a>(&'a self) -> &'a Option<InputFile> {
        &self.media
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    fn get_has_spoiler<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    fn get_has_spoiler_ref<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the photo needs to be covered with a spoiler animation"]
    fn set_has_spoiler<'a>(&'a mut self, has_spoiler: Option<bool>) -> &'a mut Self {
        self.has_spoiler = if let Some(has_spoiler) = has_spoiler {
            Some(has_spoiler)
        } else {
            None
        };
        self
    }
}
impl TraitInputMediaVideo for InputMediaVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, width, height, duration, supports_streaming, has_spoiler)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
        Option<bool>,
    ) {
        (
            self.tg_type,
            self.media,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.width.map(|width| width),
            self.height.map(|height| height),
            self.duration.map(|duration| duration),
            self.supports_streaming
                .map(|supports_streaming| supports_streaming),
            self.has_spoiler.map(|has_spoiler| has_spoiler),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>> {
        Cow::Borrowed(&self.media)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_media_ref<'a>(&'a self) -> &'a Option<InputFile> {
        &self.media
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a InputFile> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_width<'a>(&'a self) -> Option<i64> {
        self.width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_width_ref<'a>(&'a self) -> Option<i64> {
        self.width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn set_width<'a>(&'a mut self, width: Option<i64>) -> &'a mut Self {
        self.width = if let Some(width) = width {
            Some(width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_height<'a>(&'a self) -> Option<i64> {
        self.height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_height_ref<'a>(&'a self) -> Option<i64> {
        self.height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn set_height<'a>(&'a mut self, height: Option<i64>) -> &'a mut Self {
        self.height = if let Some(height) = height {
            Some(height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_duration<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_duration_ref<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn set_duration<'a>(&'a mut self, duration: Option<i64>) -> &'a mut Self {
        self.duration = if let Some(duration) = duration {
            Some(duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    fn get_supports_streaming<'a>(&'a self) -> Option<bool> {
        self.supports_streaming.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    fn get_supports_streaming_ref<'a>(&'a self) -> Option<bool> {
        self.supports_streaming.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    fn set_supports_streaming<'a>(&'a mut self, supports_streaming: Option<bool>) -> &'a mut Self {
        self.supports_streaming = if let Some(supports_streaming) = supports_streaming {
            Some(supports_streaming)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    fn get_has_spoiler<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    fn get_has_spoiler_ref<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    fn set_has_spoiler<'a>(&'a mut self, has_spoiler: Option<bool>) -> &'a mut Self {
        self.has_spoiler = if let Some(has_spoiler) = has_spoiler {
            Some(has_spoiler)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChosenInlineResult {
    pub fn new(result_id: String, from: User, query: String) -> Self {
        Self {
            result_id,
            from,
            query,
            location: None,
            inline_message_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (result_id, from, location, inline_message_id, query)"]
    pub fn into_tuple(self) -> (String, User, Option<Location>, Option<String>, String) {
        (
            self.result_id,
            self.from,
            self.location.map(|location| location),
            self.inline_message_id
                .map(|inline_message_id| inline_message_id),
            self.query,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    pub fn get_result_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.result_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    pub fn get_result_id_ref<'a>(&'a self) -> &'a str {
        self.result_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The unique identifier for the result that was chosen"]
    pub fn set_result_id<'a>(&'a mut self, result_id: String) -> &'a mut Self {
        self.result_id = result_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The user that chose the result"]
    pub fn get_from<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.from)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The user that chose the result"]
    pub fn get_from_ref<'a>(&'a self) -> &'a User {
        &self.from
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The user that chose the result"]
    pub fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    pub fn get_location<'a>(&'a self) -> Option<Cow<'a, Location>> {
        self.location.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    pub fn get_location_ref<'a>(&'a self) -> Option<&'a Location> {
        self.location.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that require user location"]
    pub fn set_location<'a>(&'a mut self, location: Option<Location>) -> &'a mut Self {
        self.location = if let Some(location) = location {
            Some(location)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    pub fn get_inline_message_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.inline_message_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    pub fn get_inline_message_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.inline_message_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."]
    pub fn set_inline_message_id<'a>(
        &'a mut self,
        inline_message_id: Option<String>,
    ) -> &'a mut Self {
        self.inline_message_id = if let Some(inline_message_id) = inline_message_id {
            Some(inline_message_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    pub fn get_query<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.query.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    pub fn get_query_ref<'a>(&'a self) -> &'a str {
        self.query.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The query that was used to obtain the result"]
    pub fn set_query<'a>(&'a mut self, query: String) -> &'a mut Self {
        self.query = query;
        self
    }
}
#[allow(dead_code)]
impl GeneralForumTopicUnhidden {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    pub fn into_tuple(self) {
        ()
    }
}
#[allow(dead_code)]
impl CallbackQuery {
    pub fn new(id: String, from: User, chat_instance: String) -> Self {
        Self {
            id,
            from,
            chat_instance,
            message: None,
            inline_message_id: None,
            data: None,
            game_short_name: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, from, message, inline_message_id, chat_instance, data, game_short_name)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        User,
        Option<Message>,
        Option<String>,
        String,
        Option<String>,
        Option<String>,
    ) {
        (
            self.id,
            self.from,
            self.message.map(|message| message),
            self.inline_message_id
                .map(|inline_message_id| inline_message_id),
            self.chat_instance,
            self.data.map(|data| data),
            self.game_short_name.map(|game_short_name| game_short_name),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    pub fn get_from<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.from)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    pub fn get_from_ref<'a>(&'a self) -> &'a User {
        &self.from
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    pub fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    pub fn get_message<'a>(&'a self) -> Option<Cow<'a, Message>> {
        self.message.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    pub fn get_message_ref<'a>(&'a self) -> Option<&'a Message> {
        self.message.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"]
    pub fn set_message<'a>(&'a mut self, message: Option<Message>) -> &'a mut Self {
        self.message = if let Some(message) = message {
            Some(message)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."]
    pub fn get_inline_message_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.inline_message_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."]
    pub fn get_inline_message_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.inline_message_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."]
    pub fn set_inline_message_id<'a>(
        &'a mut self,
        inline_message_id: Option<String>,
    ) -> &'a mut Self {
        self.inline_message_id = if let Some(inline_message_id) = inline_message_id {
            Some(inline_message_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    pub fn get_chat_instance<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.chat_instance.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    pub fn get_chat_instance_ref<'a>(&'a self) -> &'a str {
        self.chat_instance.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."]
    pub fn set_chat_instance<'a>(&'a mut self, chat_instance: String) -> &'a mut Self {
        self.chat_instance = chat_instance;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    pub fn get_data<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.data.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    pub fn get_data_ref<'a>(&'a self) -> Option<&'a str> {
        self.data.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."]
    pub fn set_data<'a>(&'a mut self, data: Option<String>) -> &'a mut Self {
        self.data = if let Some(data) = data {
            Some(data)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    pub fn get_game_short_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.game_short_name
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    pub fn get_game_short_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.game_short_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"]
    pub fn set_game_short_name<'a>(&'a mut self, game_short_name: Option<String>) -> &'a mut Self {
        self.game_short_name = if let Some(game_short_name) = game_short_name {
            Some(game_short_name)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl Chat {
    pub fn new(id: i64) -> Self {
        Self {
            tg_type: "Chat".to_owned(),
            id,
            title: None,
            username: None,
            first_name: None,
            last_name: None,
            is_forum: None,
            photo: None,
            active_usernames: None,
            emoji_status_custom_emoji_id: None,
            emoji_status_expiration_date: None,
            bio: None,
            has_private_forwards: None,
            has_restricted_voice_and_video_messages: None,
            join_to_send_messages: None,
            join_by_request: None,
            description: None,
            invite_link: None,
            pinned_message: None,
            permissions: None,
            slow_mode_delay: None,
            message_auto_delete_time: None,
            has_aggressive_anti_spam_enabled: None,
            has_hidden_members: None,
            has_protected_content: None,
            sticker_set_name: None,
            can_set_sticker_set: None,
            linked_chat_id: None,
            location: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, type, title, username, first_name, last_name, is_forum, photo, active_usernames, emoji_status_custom_emoji_id, emoji_status_expiration_date, bio, has_private_forwards, has_restricted_voice_and_video_messages, join_to_send_messages, join_by_request, description, invite_link, pinned_message, permissions, slow_mode_delay, message_auto_delete_time, has_aggressive_anti_spam_enabled, has_hidden_members, has_protected_content, sticker_set_name, can_set_sticker_set, linked_chat_id, location)"]
    pub fn into_tuple(
        self,
    ) -> (
        i64,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<bool>,
        Option<ChatPhoto>,
        Option<Vec<String>>,
        Option<String>,
        Option<i64>,
        Option<String>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<String>,
        Option<String>,
        Option<Message>,
        Option<ChatPermissions>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<String>,
        Option<bool>,
        Option<i64>,
        Option<ChatLocation>,
    ) {
        (
            self.id,
            self.tg_type,
            self.title.map(|title| title),
            self.username.map(|username| username),
            self.first_name.map(|first_name| first_name),
            self.last_name.map(|last_name| last_name),
            self.is_forum.map(|is_forum| is_forum),
            self.photo.map(|photo| photo),
            self.active_usernames
                .map(|active_usernames| active_usernames),
            self.emoji_status_custom_emoji_id
                .map(|emoji_status_custom_emoji_id| emoji_status_custom_emoji_id),
            self.emoji_status_expiration_date
                .map(|emoji_status_expiration_date| emoji_status_expiration_date),
            self.bio.map(|bio| bio),
            self.has_private_forwards
                .map(|has_private_forwards| has_private_forwards),
            self.has_restricted_voice_and_video_messages.map(
                |has_restricted_voice_and_video_messages| has_restricted_voice_and_video_messages,
            ),
            self.join_to_send_messages
                .map(|join_to_send_messages| join_to_send_messages),
            self.join_by_request.map(|join_by_request| join_by_request),
            self.description.map(|description| description),
            self.invite_link.map(|invite_link| invite_link),
            self.pinned_message.map(|pinned_message| pinned_message),
            self.permissions.map(|permissions| permissions),
            self.slow_mode_delay.map(|slow_mode_delay| slow_mode_delay),
            self.message_auto_delete_time
                .map(|message_auto_delete_time| message_auto_delete_time),
            self.has_aggressive_anti_spam_enabled
                .map(|has_aggressive_anti_spam_enabled| has_aggressive_anti_spam_enabled),
            self.has_hidden_members
                .map(|has_hidden_members| has_hidden_members),
            self.has_protected_content
                .map(|has_protected_content| has_protected_content),
            self.sticker_set_name
                .map(|sticker_set_name| sticker_set_name),
            self.can_set_sticker_set
                .map(|can_set_sticker_set| can_set_sticker_set),
            self.linked_chat_id.map(|linked_chat_id| linked_chat_id),
            self.location.map(|location| location),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_id<'a>(&'a self) -> i64 {
        self.id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_id_ref<'a>(&'a self) -> i64 {
        self.id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_id<'a>(&'a mut self, id: i64) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of chat, can be either \"private\", \"group\", \"supergroup\" or \"channel\""]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of chat, can be either \"private\", \"group\", \"supergroup\" or \"channel\""]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of chat, can be either \"private\", \"group\", \"supergroup\" or \"channel\""]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title, for supergroups, channels and group chats"]
    pub fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title, for supergroups, channels and group chats"]
    pub fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title, for supergroups, channels and group chats"]
    pub fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username, for private chats, supergroups and channels if available"]
    pub fn get_username<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.username.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username, for private chats, supergroups and channels if available"]
    pub fn get_username_ref<'a>(&'a self) -> Option<&'a str> {
        self.username.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Username, for private chats, supergroups and channels if available"]
    pub fn set_username<'a>(&'a mut self, username: Option<String>) -> &'a mut Self {
        self.username = if let Some(username) = username {
            Some(username)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. First name of the other party in a private chat"]
    pub fn get_first_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.first_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. First name of the other party in a private chat"]
    pub fn get_first_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.first_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. First name of the other party in a private chat"]
    pub fn set_first_name<'a>(&'a mut self, first_name: Option<String>) -> &'a mut Self {
        self.first_name = if let Some(first_name) = first_name {
            Some(first_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Last name of the other party in a private chat"]
    pub fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.last_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Last name of the other party in a private chat"]
    pub fn get_last_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.last_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Last name of the other party in a private chat"]
    pub fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self {
        self.last_name = if let Some(last_name) = last_name {
            Some(last_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the supergroup chat is a forum (has topics enabled)"]
    pub fn get_is_forum<'a>(&'a self) -> Option<bool> {
        self.is_forum.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the supergroup chat is a forum (has topics enabled)"]
    pub fn get_is_forum_ref<'a>(&'a self) -> Option<bool> {
        self.is_forum.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the supergroup chat is a forum (has topics enabled)"]
    pub fn set_is_forum<'a>(&'a mut self, is_forum: Option<bool>) -> &'a mut Self {
        self.is_forum = if let Some(is_forum) = is_forum {
            Some(is_forum)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat photo. Returned only in getChat."]
    pub fn get_photo<'a>(&'a self) -> Option<Cow<'a, ChatPhoto>> {
        self.photo.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat photo. Returned only in getChat."]
    pub fn get_photo_ref<'a>(&'a self) -> Option<&'a ChatPhoto> {
        self.photo.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat photo. Returned only in getChat."]
    pub fn set_photo<'a>(&'a mut self, photo: Option<ChatPhoto>) -> &'a mut Self {
        self.photo = if let Some(photo) = photo {
            Some(photo)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."]
    pub fn get_active_usernames<'a>(&'a self) -> Option<Cow<'a, Vec<String>>> {
        self.active_usernames.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."]
    pub fn get_active_usernames_ref<'a>(&'a self) -> Option<&'a Vec<String>> {
        self.active_usernames.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."]
    pub fn set_active_usernames<'a>(
        &'a mut self,
        active_usernames: Option<Vec<String>>,
    ) -> &'a mut Self {
        self.active_usernames = if let Some(active_usernames) = active_usernames {
            Some(active_usernames)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."]
    pub fn get_emoji_status_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.emoji_status_custom_emoji_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."]
    pub fn get_emoji_status_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.emoji_status_custom_emoji_id
            .as_ref()
            .map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."]
    pub fn set_emoji_status_custom_emoji_id<'a>(
        &'a mut self,
        emoji_status_custom_emoji_id: Option<String>,
    ) -> &'a mut Self {
        self.emoji_status_custom_emoji_id =
            if let Some(emoji_status_custom_emoji_id) = emoji_status_custom_emoji_id {
                Some(emoji_status_custom_emoji_id)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."]
    pub fn get_emoji_status_expiration_date<'a>(&'a self) -> Option<i64> {
        self.emoji_status_expiration_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."]
    pub fn get_emoji_status_expiration_date_ref<'a>(&'a self) -> Option<i64> {
        self.emoji_status_expiration_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."]
    pub fn set_emoji_status_expiration_date<'a>(
        &'a mut self,
        emoji_status_expiration_date: Option<i64>,
    ) -> &'a mut Self {
        self.emoji_status_expiration_date =
            if let Some(emoji_status_expiration_date) = emoji_status_expiration_date {
                Some(emoji_status_expiration_date)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the other party in a private chat. Returned only in getChat."]
    pub fn get_bio<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.bio.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the other party in a private chat. Returned only in getChat."]
    pub fn get_bio_ref<'a>(&'a self) -> Option<&'a str> {
        self.bio.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the other party in a private chat. Returned only in getChat."]
    pub fn set_bio<'a>(&'a mut self, bio: Option<String>) -> &'a mut Self {
        self.bio = if let Some(bio) = bio { Some(bio) } else { None };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."]
    pub fn get_has_private_forwards<'a>(&'a self) -> Option<bool> {
        self.has_private_forwards.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."]
    pub fn get_has_private_forwards_ref<'a>(&'a self) -> Option<bool> {
        self.has_private_forwards.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."]
    pub fn set_has_private_forwards<'a>(
        &'a mut self,
        has_private_forwards: Option<bool>,
    ) -> &'a mut Self {
        self.has_private_forwards = if let Some(has_private_forwards) = has_private_forwards {
            Some(has_private_forwards)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."]
    pub fn get_has_restricted_voice_and_video_messages<'a>(&'a self) -> Option<bool> {
        self.has_restricted_voice_and_video_messages
            .as_ref()
            .map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."]
    pub fn get_has_restricted_voice_and_video_messages_ref<'a>(&'a self) -> Option<bool> {
        self.has_restricted_voice_and_video_messages
            .as_ref()
            .map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."]
    pub fn set_has_restricted_voice_and_video_messages<'a>(
        &'a mut self,
        has_restricted_voice_and_video_messages: Option<bool>,
    ) -> &'a mut Self {
        self.has_restricted_voice_and_video_messages =
            if let Some(has_restricted_voice_and_video_messages) =
                has_restricted_voice_and_video_messages
            {
                Some(has_restricted_voice_and_video_messages)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."]
    pub fn get_join_to_send_messages<'a>(&'a self) -> Option<bool> {
        self.join_to_send_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."]
    pub fn get_join_to_send_messages_ref<'a>(&'a self) -> Option<bool> {
        self.join_to_send_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."]
    pub fn set_join_to_send_messages<'a>(
        &'a mut self,
        join_to_send_messages: Option<bool>,
    ) -> &'a mut Self {
        self.join_to_send_messages = if let Some(join_to_send_messages) = join_to_send_messages {
            Some(join_to_send_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."]
    pub fn get_join_by_request<'a>(&'a self) -> Option<bool> {
        self.join_by_request.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."]
    pub fn get_join_by_request_ref<'a>(&'a self) -> Option<bool> {
        self.join_by_request.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."]
    pub fn set_join_by_request<'a>(&'a mut self, join_by_request: Option<bool>) -> &'a mut Self {
        self.join_by_request = if let Some(join_by_request) = join_by_request {
            Some(join_by_request)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."]
    pub fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."]
    pub fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."]
    pub fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."]
    pub fn get_invite_link<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.invite_link.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."]
    pub fn get_invite_link_ref<'a>(&'a self) -> Option<&'a str> {
        self.invite_link.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."]
    pub fn set_invite_link<'a>(&'a mut self, invite_link: Option<String>) -> &'a mut Self {
        self.invite_link = if let Some(invite_link) = invite_link {
            Some(invite_link)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The most recent pinned message (by sending date). Returned only in getChat."]
    pub fn get_pinned_message<'a>(&'a self) -> Option<Cow<'a, Message>> {
        self.pinned_message.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The most recent pinned message (by sending date). Returned only in getChat."]
    pub fn get_pinned_message_ref<'a>(&'a self) -> Option<&'a Message> {
        self.pinned_message.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The most recent pinned message (by sending date). Returned only in getChat."]
    pub fn set_pinned_message<'a>(&'a mut self, pinned_message: Option<Message>) -> &'a mut Self {
        self.pinned_message = if let Some(pinned_message) = pinned_message {
            Some(pinned_message)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."]
    pub fn get_permissions<'a>(&'a self) -> Option<Cow<'a, ChatPermissions>> {
        self.permissions.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."]
    pub fn get_permissions_ref<'a>(&'a self) -> Option<&'a ChatPermissions> {
        self.permissions.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."]
    pub fn set_permissions<'a>(&'a mut self, permissions: Option<ChatPermissions>) -> &'a mut Self {
        self.permissions = if let Some(permissions) = permissions {
            Some(permissions)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."]
    pub fn get_slow_mode_delay<'a>(&'a self) -> Option<i64> {
        self.slow_mode_delay.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."]
    pub fn get_slow_mode_delay_ref<'a>(&'a self) -> Option<i64> {
        self.slow_mode_delay.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."]
    pub fn set_slow_mode_delay<'a>(&'a mut self, slow_mode_delay: Option<i64>) -> &'a mut Self {
        self.slow_mode_delay = if let Some(slow_mode_delay) = slow_mode_delay {
            Some(slow_mode_delay)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."]
    pub fn get_message_auto_delete_time<'a>(&'a self) -> Option<i64> {
        self.message_auto_delete_time.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."]
    pub fn get_message_auto_delete_time_ref<'a>(&'a self) -> Option<i64> {
        self.message_auto_delete_time.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."]
    pub fn set_message_auto_delete_time<'a>(
        &'a mut self,
        message_auto_delete_time: Option<i64>,
    ) -> &'a mut Self {
        self.message_auto_delete_time =
            if let Some(message_auto_delete_time) = message_auto_delete_time {
                Some(message_auto_delete_time)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."]
    pub fn get_has_aggressive_anti_spam_enabled<'a>(&'a self) -> Option<bool> {
        self.has_aggressive_anti_spam_enabled.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."]
    pub fn get_has_aggressive_anti_spam_enabled_ref<'a>(&'a self) -> Option<bool> {
        self.has_aggressive_anti_spam_enabled.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."]
    pub fn set_has_aggressive_anti_spam_enabled<'a>(
        &'a mut self,
        has_aggressive_anti_spam_enabled: Option<bool>,
    ) -> &'a mut Self {
        self.has_aggressive_anti_spam_enabled =
            if let Some(has_aggressive_anti_spam_enabled) = has_aggressive_anti_spam_enabled {
                Some(has_aggressive_anti_spam_enabled)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."]
    pub fn get_has_hidden_members<'a>(&'a self) -> Option<bool> {
        self.has_hidden_members.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."]
    pub fn get_has_hidden_members_ref<'a>(&'a self) -> Option<bool> {
        self.has_hidden_members.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."]
    pub fn set_has_hidden_members<'a>(
        &'a mut self,
        has_hidden_members: Option<bool>,
    ) -> &'a mut Self {
        self.has_hidden_members = if let Some(has_hidden_members) = has_hidden_members {
            Some(has_hidden_members)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."]
    pub fn get_has_protected_content<'a>(&'a self) -> Option<bool> {
        self.has_protected_content.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."]
    pub fn get_has_protected_content_ref<'a>(&'a self) -> Option<bool> {
        self.has_protected_content.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."]
    pub fn set_has_protected_content<'a>(
        &'a mut self,
        has_protected_content: Option<bool>,
    ) -> &'a mut Self {
        self.has_protected_content = if let Some(has_protected_content) = has_protected_content {
            Some(has_protected_content)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, name of group sticker set. Returned only in getChat."]
    pub fn get_sticker_set_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.sticker_set_name
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, name of group sticker set. Returned only in getChat."]
    pub fn get_sticker_set_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.sticker_set_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, name of group sticker set. Returned only in getChat."]
    pub fn set_sticker_set_name<'a>(
        &'a mut self,
        sticker_set_name: Option<String>,
    ) -> &'a mut Self {
        self.sticker_set_name = if let Some(sticker_set_name) = sticker_set_name {
            Some(sticker_set_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can change the group sticker set. Returned only in getChat."]
    pub fn get_can_set_sticker_set<'a>(&'a self) -> Option<bool> {
        self.can_set_sticker_set.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can change the group sticker set. Returned only in getChat."]
    pub fn get_can_set_sticker_set_ref<'a>(&'a self) -> Option<bool> {
        self.can_set_sticker_set.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can change the group sticker set. Returned only in getChat."]
    pub fn set_can_set_sticker_set<'a>(
        &'a mut self,
        can_set_sticker_set: Option<bool>,
    ) -> &'a mut Self {
        self.can_set_sticker_set = if let Some(can_set_sticker_set) = can_set_sticker_set {
            Some(can_set_sticker_set)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."]
    pub fn get_linked_chat_id<'a>(&'a self) -> Option<i64> {
        self.linked_chat_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."]
    pub fn get_linked_chat_id_ref<'a>(&'a self) -> Option<i64> {
        self.linked_chat_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."]
    pub fn set_linked_chat_id<'a>(&'a mut self, linked_chat_id: Option<i64>) -> &'a mut Self {
        self.linked_chat_id = if let Some(linked_chat_id) = linked_chat_id {
            Some(linked_chat_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."]
    pub fn get_location<'a>(&'a self) -> Option<Cow<'a, ChatLocation>> {
        self.location.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."]
    pub fn get_location_ref<'a>(&'a self) -> Option<&'a ChatLocation> {
        self.location.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."]
    pub fn set_location<'a>(&'a mut self, location: Option<ChatLocation>) -> &'a mut Self {
        self.location = if let Some(location) = location {
            Some(location)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatMemberUpdated {
    pub fn new(
        chat: Box<Chat>,
        from: User,
        date: i64,
        old_chat_member: ChatMember,
        new_chat_member: ChatMember,
    ) -> Self {
        Self {
            chat,
            from,
            date,
            old_chat_member,
            new_chat_member,
            invite_link: None,
            via_chat_folder_invite_link: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (chat, from, date, old_chat_member, new_chat_member, invite_link, via_chat_folder_invite_link)"]
    pub fn into_tuple(
        self,
    ) -> (
        Chat,
        User,
        i64,
        ChatMember,
        ChatMember,
        Option<ChatInviteLink>,
        Option<bool>,
    ) {
        (
            (*self.chat),
            self.from,
            self.date,
            self.old_chat_member,
            self.new_chat_member,
            self.invite_link.map(|invite_link| invite_link),
            self.via_chat_folder_invite_link
                .map(|via_chat_folder_invite_link| via_chat_folder_invite_link),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat the user belongs to"]
    pub fn get_chat<'a>(&'a self) -> Cow<'a, Chat> {
        Cow::Borrowed(self.chat.as_ref())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat the user belongs to"]
    pub fn get_chat_ref<'a>(&'a self) -> &'a Chat {
        self.chat.as_ref()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat the user belongs to"]
    pub fn set_chat<'a>(&'a mut self, chat: Chat) -> &'a mut Self {
        self.chat = Box::new(chat);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Performer of the action, which resulted in the change"]
    pub fn get_from<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.from)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Performer of the action, which resulted in the change"]
    pub fn get_from_ref<'a>(&'a self) -> &'a User {
        &self.from
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Performer of the action, which resulted in the change"]
    pub fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the change was done in Unix time"]
    pub fn get_date<'a>(&'a self) -> i64 {
        self.date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the change was done in Unix time"]
    pub fn get_date_ref<'a>(&'a self) -> i64 {
        self.date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the change was done in Unix time"]
    pub fn set_date<'a>(&'a mut self, date: i64) -> &'a mut Self {
        self.date = date;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    pub fn get_old_chat_member<'a>(&'a self) -> Cow<'a, ChatMember> {
        Cow::Borrowed(&self.old_chat_member)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    pub fn get_old_chat_member_ref<'a>(&'a self) -> &'a ChatMember {
        &self.old_chat_member
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Previous information about the chat member"]
    pub fn set_old_chat_member<'a>(&'a mut self, old_chat_member: ChatMember) -> &'a mut Self {
        self.old_chat_member = old_chat_member;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    pub fn get_new_chat_member<'a>(&'a self) -> Cow<'a, ChatMember> {
        Cow::Borrowed(&self.new_chat_member)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    pub fn get_new_chat_member_ref<'a>(&'a self) -> &'a ChatMember {
        &self.new_chat_member
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New information about the chat member"]
    pub fn set_new_chat_member<'a>(&'a mut self, new_chat_member: ChatMember) -> &'a mut Self {
        self.new_chat_member = new_chat_member;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."]
    pub fn get_invite_link<'a>(&'a self) -> Option<Cow<'a, ChatInviteLink>> {
        self.invite_link.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."]
    pub fn get_invite_link_ref<'a>(&'a self) -> Option<&'a ChatInviteLink> {
        self.invite_link.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."]
    pub fn set_invite_link<'a>(&'a mut self, invite_link: Option<ChatInviteLink>) -> &'a mut Self {
        self.invite_link = if let Some(invite_link) = invite_link {
            Some(invite_link)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    pub fn get_via_chat_folder_invite_link<'a>(&'a self) -> Option<bool> {
        self.via_chat_folder_invite_link.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    pub fn get_via_chat_folder_invite_link_ref<'a>(&'a self) -> Option<bool> {
        self.via_chat_folder_invite_link.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user joined the chat via a chat folder invite link"]
    pub fn set_via_chat_folder_invite_link<'a>(
        &'a mut self,
        via_chat_folder_invite_link: Option<bool>,
    ) -> &'a mut Self {
        self.via_chat_folder_invite_link =
            if let Some(via_chat_folder_invite_link) = via_chat_folder_invite_link {
                Some(via_chat_folder_invite_link)
            } else {
                None
            };
        self
    }
}
#[allow(dead_code)]
impl BotDescription {
    pub fn new(description: String) -> Self {
        Self { description }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (description)"]
    pub fn into_tuple(self) -> String {
        self.description
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's description"]
    pub fn get_description<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.description.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's description"]
    pub fn get_description_ref<'a>(&'a self) -> &'a str {
        self.description.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's description"]
    pub fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self {
        self.description = description;
        self
    }
}
#[allow(dead_code)]
impl InputLocationMessageContent {
    pub fn new(
        latitude: ::ordered_float::OrderedFloat<f64>,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> Self {
        Self {
            latitude,
            longitude,
            horizontal_accuracy: None,
            live_period: None,
            heading: None,
            proximity_alert_radius: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (latitude, longitude, horizontal_accuracy, live_period, heading, proximity_alert_radius)"]
    pub fn into_tuple(
        self,
    ) -> (
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        Option<::ordered_float::OrderedFloat<f64>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.latitude,
            self.longitude,
            self.horizontal_accuracy
                .map(|horizontal_accuracy| horizontal_accuracy),
            self.live_period.map(|live_period| live_period),
            self.heading.map(|heading| heading),
            self.proximity_alert_radius
                .map(|proximity_alert_radius| proximity_alert_radius),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    pub fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    pub fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    pub fn set_latitude<'a>(
        &'a mut self,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    pub fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    pub fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    pub fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn get_horizontal_accuracy<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>> {
        self.horizontal_accuracy.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn get_horizontal_accuracy_ref<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>> {
        self.horizontal_accuracy.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn set_horizontal_accuracy<'a>(
        &'a mut self,
        horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    ) -> &'a mut Self {
        self.horizontal_accuracy = if let Some(horizontal_accuracy) = horizontal_accuracy {
            Some(horizontal_accuracy)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    pub fn get_live_period<'a>(&'a self) -> Option<i64> {
        self.live_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    pub fn get_live_period_ref<'a>(&'a self) -> Option<i64> {
        self.live_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    pub fn set_live_period<'a>(&'a mut self, live_period: Option<i64>) -> &'a mut Self {
        self.live_period = if let Some(live_period) = live_period {
            Some(live_period)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    pub fn get_heading<'a>(&'a self) -> Option<i64> {
        self.heading.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    pub fn get_heading_ref<'a>(&'a self) -> Option<i64> {
        self.heading.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    pub fn set_heading<'a>(&'a mut self, heading: Option<i64>) -> &'a mut Self {
        self.heading = if let Some(heading) = heading {
            Some(heading)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    pub fn get_proximity_alert_radius<'a>(&'a self) -> Option<i64> {
        self.proximity_alert_radius.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    pub fn get_proximity_alert_radius_ref<'a>(&'a self) -> Option<i64> {
        self.proximity_alert_radius.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    pub fn set_proximity_alert_radius<'a>(
        &'a mut self,
        proximity_alert_radius: Option<i64>,
    ) -> &'a mut Self {
        self.proximity_alert_radius = if let Some(proximity_alert_radius) = proximity_alert_radius {
            Some(proximity_alert_radius)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ReplyKeyboardMarkup {
    pub fn new(keyboard: Vec<Vec<KeyboardButton>>) -> Self {
        Self {
            keyboard,
            is_persistent: None,
            resize_keyboard: None,
            one_time_keyboard: None,
            input_field_placeholder: None,
            selective: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (keyboard, is_persistent, resize_keyboard, one_time_keyboard, input_field_placeholder, selective)"]
    pub fn into_tuple(
        self,
    ) -> (
        Vec<Vec<KeyboardButton>>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<String>,
        Option<bool>,
    ) {
        (
            self.keyboard,
            self.is_persistent.map(|is_persistent| is_persistent),
            self.resize_keyboard.map(|resize_keyboard| resize_keyboard),
            self.one_time_keyboard
                .map(|one_time_keyboard| one_time_keyboard),
            self.input_field_placeholder
                .map(|input_field_placeholder| input_field_placeholder),
            self.selective.map(|selective| selective),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of KeyboardButton objects"]
    pub fn get_keyboard<'a>(&'a self) -> Cow<'a, Vec<Vec<KeyboardButton>>> {
        Cow::Borrowed(&self.keyboard)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of KeyboardButton objects"]
    pub fn get_keyboard_ref<'a>(&'a self) -> &'a Vec<Vec<KeyboardButton>> {
        &self.keyboard
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of KeyboardButton objects"]
    pub fn set_keyboard<'a>(&'a mut self, keyboard: Vec<Vec<KeyboardButton>>) -> &'a mut Self {
        self.keyboard = keyboard;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."]
    pub fn get_is_persistent<'a>(&'a self) -> Option<bool> {
        self.is_persistent.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."]
    pub fn get_is_persistent_ref<'a>(&'a self) -> Option<bool> {
        self.is_persistent.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."]
    pub fn set_is_persistent<'a>(&'a mut self, is_persistent: Option<bool>) -> &'a mut Self {
        self.is_persistent = if let Some(is_persistent) = is_persistent {
            Some(is_persistent)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."]
    pub fn get_resize_keyboard<'a>(&'a self) -> Option<bool> {
        self.resize_keyboard.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."]
    pub fn get_resize_keyboard_ref<'a>(&'a self) -> Option<bool> {
        self.resize_keyboard.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."]
    pub fn set_resize_keyboard<'a>(&'a mut self, resize_keyboard: Option<bool>) -> &'a mut Self {
        self.resize_keyboard = if let Some(resize_keyboard) = resize_keyboard {
            Some(resize_keyboard)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."]
    pub fn get_one_time_keyboard<'a>(&'a self) -> Option<bool> {
        self.one_time_keyboard.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."]
    pub fn get_one_time_keyboard_ref<'a>(&'a self) -> Option<bool> {
        self.one_time_keyboard.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."]
    pub fn set_one_time_keyboard<'a>(
        &'a mut self,
        one_time_keyboard: Option<bool>,
    ) -> &'a mut Self {
        self.one_time_keyboard = if let Some(one_time_keyboard) = one_time_keyboard {
            Some(one_time_keyboard)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"]
    pub fn get_input_field_placeholder<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.input_field_placeholder
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"]
    pub fn get_input_field_placeholder_ref<'a>(&'a self) -> Option<&'a str> {
        self.input_field_placeholder.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"]
    pub fn set_input_field_placeholder<'a>(
        &'a mut self,
        input_field_placeholder: Option<String>,
    ) -> &'a mut Self {
        self.input_field_placeholder =
            if let Some(input_field_placeholder) = input_field_placeholder {
                Some(input_field_placeholder)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."]
    pub fn get_selective<'a>(&'a self) -> Option<bool> {
        self.selective.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."]
    pub fn get_selective_ref<'a>(&'a self) -> Option<bool> {
        self.selective.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."]
    pub fn set_selective<'a>(&'a mut self, selective: Option<bool>) -> &'a mut Self {
        self.selective = if let Some(selective) = selective {
            Some(selective)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl MessageId {
    pub fn new(message_id: i64) -> Self {
        Self { message_id }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_id)"]
    pub fn into_tuple(self) -> i64 {
        self.message_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier"]
    pub fn get_message_id<'a>(&'a self) -> i64 {
        self.message_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier"]
    pub fn get_message_id_ref<'a>(&'a self) -> i64 {
        self.message_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier"]
    pub fn set_message_id<'a>(&'a mut self, message_id: i64) -> &'a mut Self {
        self.message_id = message_id;
        self
    }
}
#[allow(dead_code)]
impl PollOption {
    pub fn new(text: String, voter_count: i64) -> Self {
        Self { text, voter_count }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (text, voter_count)"]
    pub fn into_tuple(self) -> (String, i64) {
        (self.text, self.voter_count)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option text, 1-100 characters"]
    pub fn get_text<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.text.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option text, 1-100 characters"]
    pub fn get_text_ref<'a>(&'a self) -> &'a str {
        self.text.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option text, 1-100 characters"]
    pub fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of users that voted for this option"]
    pub fn get_voter_count<'a>(&'a self) -> i64 {
        self.voter_count
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of users that voted for this option"]
    pub fn get_voter_count_ref<'a>(&'a self) -> i64 {
        self.voter_count
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of users that voted for this option"]
    pub fn set_voter_count<'a>(&'a mut self, voter_count: i64) -> &'a mut Self {
        self.voter_count = voter_count;
        self
    }
}
#[allow(dead_code)]
impl BotShortDescription {
    pub fn new(short_description: String) -> Self {
        Self { short_description }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (short_description)"]
    pub fn into_tuple(self) -> String {
        self.short_description
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's short description"]
    pub fn get_short_description<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.short_description.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's short description"]
    pub fn get_short_description_ref<'a>(&'a self) -> &'a str {
        self.short_description.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's short description"]
    pub fn set_short_description<'a>(&'a mut self, short_description: String) -> &'a mut Self {
        self.short_description = short_description;
        self
    }
}
#[allow(dead_code)]
impl InputMediaVideo {
    pub fn new(media: Option<InputFile>) -> Self {
        Self {
            tg_type: "video".to_owned(),
            media,
            thumbnail: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            width: None,
            height: None,
            duration: None,
            supports_streaming: None,
            has_spoiler: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, width, height, duration, supports_streaming, has_spoiler)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
        Option<bool>,
    ) {
        (
            self.tg_type,
            self.media,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.width.map(|width| width),
            self.height.map(|height| height),
            self.duration.map(|duration| duration),
            self.supports_streaming
                .map(|supports_streaming| supports_streaming),
            self.has_spoiler.map(|has_spoiler| has_spoiler),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>> {
        Cow::Borrowed(&self.media)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_media_ref<'a>(&'a self) -> &'a Option<InputFile> {
        &self.media
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a InputFile> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn get_width<'a>(&'a self) -> Option<i64> {
        self.width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn get_width_ref<'a>(&'a self) -> Option<i64> {
        self.width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn set_width<'a>(&'a mut self, width: Option<i64>) -> &'a mut Self {
        self.width = if let Some(width) = width {
            Some(width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn get_height<'a>(&'a self) -> Option<i64> {
        self.height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn get_height_ref<'a>(&'a self) -> Option<i64> {
        self.height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn set_height<'a>(&'a mut self, height: Option<i64>) -> &'a mut Self {
        self.height = if let Some(height) = height {
            Some(height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn get_duration<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn get_duration_ref<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn set_duration<'a>(&'a mut self, duration: Option<i64>) -> &'a mut Self {
        self.duration = if let Some(duration) = duration {
            Some(duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    pub fn get_supports_streaming<'a>(&'a self) -> Option<bool> {
        self.supports_streaming.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    pub fn get_supports_streaming_ref<'a>(&'a self) -> Option<bool> {
        self.supports_streaming.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the uploaded video is suitable for streaming"]
    pub fn set_supports_streaming<'a>(
        &'a mut self,
        supports_streaming: Option<bool>,
    ) -> &'a mut Self {
        self.supports_streaming = if let Some(supports_streaming) = supports_streaming {
            Some(supports_streaming)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    pub fn get_has_spoiler<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    pub fn get_has_spoiler_ref<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the video needs to be covered with a spoiler animation"]
    pub fn set_has_spoiler<'a>(&'a mut self, has_spoiler: Option<bool>) -> &'a mut Self {
        self.has_spoiler = if let Some(has_spoiler) = has_spoiler {
            Some(has_spoiler)
        } else {
            None
        };
        self
    }
    fn to_form(self, data: Form) -> Result<(Form, String)> {
        match self.media {
            Some(InputFile::Bytes(FileBytes {
                name,
                bytes: Some(bytes),
            })) => {
                let attach = format!("attach://{}", name);
                let form = data.part(name, Part::bytes(bytes));
                Ok((form, attach))
            }
            Some(InputFile::String(name)) => Ok((data, name)),
            _ => Err(anyhow!("cry")),
        }
    }
}
#[allow(dead_code)]
impl PassportElementErrorFrontSide {
    pub fn new(source: String, file_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorFrontSide".to_owned(),
            source,
            file_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    pub fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.file_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    pub fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    pub fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    pub fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    pub fn get_file_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    pub fn get_file_hash_ref<'a>(&'a self) -> &'a str {
        self.file_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    pub fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
#[allow(dead_code)]
impl MenuButtonDefault {
    pub fn new() -> Self {
        Self {
            tg_type: "default".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    pub fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
#[allow(dead_code)]
impl EncryptedCredentials {
    pub fn new(data: String, hash: String, secret: String) -> Self {
        Self { data, hash, secret }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (data, hash, secret)"]
    pub fn into_tuple(self) -> (String, String, String) {
        (self.data, self.hash, self.secret)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"]
    pub fn get_data<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.data.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"]
    pub fn get_data_ref<'a>(&'a self) -> &'a str {
        self.data.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"]
    pub fn set_data<'a>(&'a mut self, data: String) -> &'a mut Self {
        self.data = data;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash for data authentication"]
    pub fn get_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash for data authentication"]
    pub fn get_hash_ref<'a>(&'a self) -> &'a str {
        self.hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash for data authentication"]
    pub fn set_hash<'a>(&'a mut self, hash: String) -> &'a mut Self {
        self.hash = hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"]
    pub fn get_secret<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.secret.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"]
    pub fn get_secret_ref<'a>(&'a self) -> &'a str {
        self.secret.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"]
    pub fn set_secret<'a>(&'a mut self, secret: String) -> &'a mut Self {
        self.secret = secret;
        self
    }
}
#[allow(dead_code)]
impl PassportElementErrorFile {
    pub fn new(source: String, file_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorFile".to_owned(),
            source,
            file_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    pub fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.file_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    pub fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    pub fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    pub fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    pub fn get_file_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    pub fn get_file_hash_ref<'a>(&'a self) -> &'a str {
        self.file_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    pub fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
#[allow(dead_code)]
impl GameHighScore {
    pub fn new(position: i64, user: User, score: i64) -> Self {
        Self {
            position,
            user,
            score,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (position, user, score)"]
    pub fn into_tuple(self) -> (i64, User, i64) {
        (self.position, self.user, self.score)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Position in high score table for the game"]
    pub fn get_position<'a>(&'a self) -> i64 {
        self.position
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Position in high score table for the game"]
    pub fn get_position_ref<'a>(&'a self) -> i64 {
        self.position
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Position in high score table for the game"]
    pub fn set_position<'a>(&'a mut self, position: i64) -> &'a mut Self {
        self.position = position;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User"]
    pub fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User"]
    pub fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User"]
    pub fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Score"]
    pub fn get_score<'a>(&'a self) -> i64 {
        self.score
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Score"]
    pub fn get_score_ref<'a>(&'a self) -> i64 {
        self.score
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Score"]
    pub fn set_score<'a>(&'a mut self, score: i64) -> &'a mut Self {
        self.score = score;
        self
    }
}
#[allow(dead_code)]
impl ShippingQuery {
    pub fn new(
        id: String,
        from: User,
        invoice_payload: String,
        shipping_address: ShippingAddress,
    ) -> Self {
        Self {
            id,
            from,
            invoice_payload,
            shipping_address,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, from, invoice_payload, shipping_address)"]
    pub fn into_tuple(self) -> (String, User, String, ShippingAddress) {
        (
            self.id,
            self.from,
            self.invoice_payload,
            self.shipping_address,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    pub fn get_from<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.from)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    pub fn get_from_ref<'a>(&'a self) -> &'a User {
        &self.from
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    pub fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn get_invoice_payload<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.invoice_payload.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn get_invoice_payload_ref<'a>(&'a self) -> &'a str {
        self.invoice_payload.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn set_invoice_payload<'a>(&'a mut self, invoice_payload: String) -> &'a mut Self {
        self.invoice_payload = invoice_payload;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    pub fn get_shipping_address<'a>(&'a self) -> Cow<'a, ShippingAddress> {
        Cow::Borrowed(&self.shipping_address)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    pub fn get_shipping_address_ref<'a>(&'a self) -> &'a ShippingAddress {
        &self.shipping_address
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User specified shipping address"]
    pub fn set_shipping_address<'a>(
        &'a mut self,
        shipping_address: ShippingAddress,
    ) -> &'a mut Self {
        self.shipping_address = shipping_address;
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultVideo {
    pub fn new(
        id: String,
        video_url: String,
        mime_type: String,
        thumbnail_url: String,
        title: String,
    ) -> Self {
        Self {
            tg_type: "video".to_owned(),
            id,
            video_url,
            mime_type,
            thumbnail_url,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            video_width: None,
            video_height: None,
            video_duration: None,
            description: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, video_url, mime_type, thumbnail_url, title, caption, parse_mode, caption_entities, video_width, video_height, video_duration, description, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.video_url,
            self.mime_type,
            self.thumbnail_url,
            self.title,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.video_width.map(|video_width| video_width),
            self.video_height.map(|video_height| video_height),
            self.video_duration.map(|video_duration| video_duration),
            self.description.map(|description| description),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    pub fn get_video_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.video_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    pub fn get_video_url_ref<'a>(&'a self) -> &'a str {
        self.video_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    pub fn set_video_url<'a>(&'a mut self, video_url: String) -> &'a mut Self {
        self.video_url = video_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    pub fn get_mime_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.mime_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    pub fn get_mime_type_ref<'a>(&'a self) -> &'a str {
        self.mime_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    pub fn set_mime_type<'a>(&'a mut self, mime_type: String) -> &'a mut Self {
        self.mime_type = mime_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    pub fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.thumbnail_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    pub fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str {
        self.thumbnail_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    pub fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn get_video_width<'a>(&'a self) -> Option<i64> {
        self.video_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn get_video_width_ref<'a>(&'a self) -> Option<i64> {
        self.video_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn set_video_width<'a>(&'a mut self, video_width: Option<i64>) -> &'a mut Self {
        self.video_width = if let Some(video_width) = video_width {
            Some(video_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn get_video_height<'a>(&'a self) -> Option<i64> {
        self.video_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn get_video_height_ref<'a>(&'a self) -> Option<i64> {
        self.video_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn set_video_height<'a>(&'a mut self, video_height: Option<i64>) -> &'a mut Self {
        self.video_height = if let Some(video_height) = video_height {
            Some(video_height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn get_video_duration<'a>(&'a self) -> Option<i64> {
        self.video_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn get_video_duration_ref<'a>(&'a self) -> Option<i64> {
        self.video_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn set_video_duration<'a>(&'a mut self, video_duration: Option<i64>) -> &'a mut Self {
        self.video_duration = if let Some(video_duration) = video_duration {
            Some(video_duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl SwitchInlineQueryChosenChat {
    pub fn new() -> Self {
        Self {
            query: None,
            allow_user_chats: None,
            allow_bot_chats: None,
            allow_group_chats: None,
            allow_channel_chats: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (query, allow_user_chats, allow_bot_chats, allow_group_chats, allow_channel_chats)"]
    pub fn into_tuple(
        self,
    ) -> (
        Option<String>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    ) {
        (
            self.query.map(|query| query),
            self.allow_user_chats
                .map(|allow_user_chats| allow_user_chats),
            self.allow_bot_chats.map(|allow_bot_chats| allow_bot_chats),
            self.allow_group_chats
                .map(|allow_group_chats| allow_group_chats),
            self.allow_channel_chats
                .map(|allow_channel_chats| allow_channel_chats),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"]
    pub fn get_query<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.query.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"]
    pub fn get_query_ref<'a>(&'a self) -> Option<&'a str> {
        self.query.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"]
    pub fn set_query<'a>(&'a mut self, query: Option<String>) -> &'a mut Self {
        self.query = if let Some(query) = query {
            Some(query)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with users can be chosen"]
    pub fn get_allow_user_chats<'a>(&'a self) -> Option<bool> {
        self.allow_user_chats.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with users can be chosen"]
    pub fn get_allow_user_chats_ref<'a>(&'a self) -> Option<bool> {
        self.allow_user_chats.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with users can be chosen"]
    pub fn set_allow_user_chats<'a>(&'a mut self, allow_user_chats: Option<bool>) -> &'a mut Self {
        self.allow_user_chats = if let Some(allow_user_chats) = allow_user_chats {
            Some(allow_user_chats)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with bots can be chosen"]
    pub fn get_allow_bot_chats<'a>(&'a self) -> Option<bool> {
        self.allow_bot_chats.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with bots can be chosen"]
    pub fn get_allow_bot_chats_ref<'a>(&'a self) -> Option<bool> {
        self.allow_bot_chats.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if private chats with bots can be chosen"]
    pub fn set_allow_bot_chats<'a>(&'a mut self, allow_bot_chats: Option<bool>) -> &'a mut Self {
        self.allow_bot_chats = if let Some(allow_bot_chats) = allow_bot_chats {
            Some(allow_bot_chats)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if group and supergroup chats can be chosen"]
    pub fn get_allow_group_chats<'a>(&'a self) -> Option<bool> {
        self.allow_group_chats.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if group and supergroup chats can be chosen"]
    pub fn get_allow_group_chats_ref<'a>(&'a self) -> Option<bool> {
        self.allow_group_chats.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if group and supergroup chats can be chosen"]
    pub fn set_allow_group_chats<'a>(
        &'a mut self,
        allow_group_chats: Option<bool>,
    ) -> &'a mut Self {
        self.allow_group_chats = if let Some(allow_group_chats) = allow_group_chats {
            Some(allow_group_chats)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if channel chats can be chosen"]
    pub fn get_allow_channel_chats<'a>(&'a self) -> Option<bool> {
        self.allow_channel_chats.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if channel chats can be chosen"]
    pub fn get_allow_channel_chats_ref<'a>(&'a self) -> Option<bool> {
        self.allow_channel_chats.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if channel chats can be chosen"]
    pub fn set_allow_channel_chats<'a>(
        &'a mut self,
        allow_channel_chats: Option<bool>,
    ) -> &'a mut Self {
        self.allow_channel_chats = if let Some(allow_channel_chats) = allow_channel_chats {
            Some(allow_channel_chats)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl Document {
    pub fn new(file_id: String, file_unique_id: String) -> Self {
        Self {
            file_id,
            file_unique_id,
            thumbnail: None,
            file_name: None,
            mime_type: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, thumbnail, file_name, mime_type, file_size)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        Option<PhotoSize>,
        Option<String>,
        Option<String>,
        Option<i64>,
    ) {
        (
            self.file_id,
            self.file_unique_id,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.file_name.map(|file_name| file_name),
            self.mime_type.map(|mime_type| mime_type),
            self.file_size.map(|file_size| file_size),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id_ref<'a>(&'a self) -> &'a str {
        self.file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Document thumbnail as defined by sender"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Document thumbnail as defined by sender"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a PhotoSize> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Document thumbnail as defined by sender"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn get_file_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.file_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn get_file_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.file_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn set_file_name<'a>(&'a mut self, file_name: Option<String>) -> &'a mut Self {
        self.file_name = if let Some(file_name) = file_name {
            Some(file_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn get_mime_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.mime_type.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn get_mime_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.mime_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn set_mime_type<'a>(&'a mut self, mime_type: Option<String>) -> &'a mut Self {
        self.mime_type = if let Some(mime_type) = mime_type {
            Some(mime_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size_ref<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self {
        self.file_size = if let Some(file_size) = file_size {
            Some(file_size)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl PassportElementErrorTranslationFiles {
    pub fn new(source: String, file_hashes: Vec<String>, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorTranslationFiles".to_owned(),
            source,
            file_hashes,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hashes, message)"]
    pub fn into_tuple(self) -> (String, String, Vec<String>, String) {
        (self.source, self.tg_type, self.file_hashes, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    pub fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    pub fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    pub fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    pub fn get_file_hashes<'a>(&'a self) -> Cow<'a, Vec<String>> {
        Cow::Borrowed(&self.file_hashes)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    pub fn get_file_hashes_ref<'a>(&'a self) -> &'a Vec<String> {
        &self.file_hashes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    pub fn set_file_hashes<'a>(&'a mut self, file_hashes: Vec<String>) -> &'a mut Self {
        self.file_hashes = file_hashes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
#[allow(dead_code)]
impl MessageEntity {
    pub fn new(offset: i64, length: i64) -> Self {
        Self {
            tg_type: "MessageEntity".to_owned(),
            offset,
            length,
            url: None,
            user: None,
            language: None,
            custom_emoji_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, offset, length, url, user, language, custom_emoji_id)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        i64,
        i64,
        Option<String>,
        Option<User>,
        Option<String>,
        Option<String>,
    ) {
        (
            self.tg_type,
            self.offset,
            self.length,
            self.url.map(|url| url),
            self.user.map(|user| user),
            self.language.map(|language| language),
            self.custom_emoji_id.map(|custom_emoji_id| custom_emoji_id),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the entity. Currently, can be \"mention\" (@username), \"hashtag\" (#hashtag), \"cashtag\" ($USD), \"bot_command\" (/start@jobs_bot), \"url\" (https://telegram.org), \"email\" (do-not-reply@telegram.org), \"phone_number\" (+1-212-555-0123), \"bold\" (bold text), \"italic\" (italic text), \"underline\" (underlined text), \"strikethrough\" (strikethrough text), \"spoiler\" (spoiler message), \"code\" (monowidth string), \"pre\" (monowidth block), \"text_link\" (for clickable text URLs), \"text_mention\" (for users without usernames), \"custom_emoji\" (for inline custom emoji stickers)"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the entity. Currently, can be \"mention\" (@username), \"hashtag\" (#hashtag), \"cashtag\" ($USD), \"bot_command\" (/start@jobs_bot), \"url\" (https://telegram.org), \"email\" (do-not-reply@telegram.org), \"phone_number\" (+1-212-555-0123), \"bold\" (bold text), \"italic\" (italic text), \"underline\" (underlined text), \"strikethrough\" (strikethrough text), \"spoiler\" (spoiler message), \"code\" (monowidth string), \"pre\" (monowidth block), \"text_link\" (for clickable text URLs), \"text_mention\" (for users without usernames), \"custom_emoji\" (for inline custom emoji stickers)"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the entity. Currently, can be \"mention\" (@username), \"hashtag\" (#hashtag), \"cashtag\" ($USD), \"bot_command\" (/start@jobs_bot), \"url\" (https://telegram.org), \"email\" (do-not-reply@telegram.org), \"phone_number\" (+1-212-555-0123), \"bold\" (bold text), \"italic\" (italic text), \"underline\" (underlined text), \"strikethrough\" (strikethrough text), \"spoiler\" (spoiler message), \"code\" (monowidth string), \"pre\" (monowidth block), \"text_link\" (for clickable text URLs), \"text_mention\" (for users without usernames), \"custom_emoji\" (for inline custom emoji stickers)"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset in UTF-16 code units to the start of the entity"]
    pub fn get_offset<'a>(&'a self) -> i64 {
        self.offset
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset in UTF-16 code units to the start of the entity"]
    pub fn get_offset_ref<'a>(&'a self) -> i64 {
        self.offset
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset in UTF-16 code units to the start of the entity"]
    pub fn set_offset<'a>(&'a mut self, offset: i64) -> &'a mut Self {
        self.offset = offset;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Length of the entity in UTF-16 code units"]
    pub fn get_length<'a>(&'a self) -> i64 {
        self.length
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Length of the entity in UTF-16 code units"]
    pub fn get_length_ref<'a>(&'a self) -> i64 {
        self.length
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Length of the entity in UTF-16 code units"]
    pub fn set_length<'a>(&'a mut self, length: i64) -> &'a mut Self {
        self.length = length;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_link\" only, URL that will be opened after user taps on the text"]
    pub fn get_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.url.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_link\" only, URL that will be opened after user taps on the text"]
    pub fn get_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_link\" only, URL that will be opened after user taps on the text"]
    pub fn set_url<'a>(&'a mut self, url: Option<String>) -> &'a mut Self {
        self.url = if let Some(url) = url { Some(url) } else { None };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_mention\" only, the mentioned user"]
    pub fn get_user<'a>(&'a self) -> Option<Cow<'a, User>> {
        self.user.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_mention\" only, the mentioned user"]
    pub fn get_user_ref<'a>(&'a self) -> Option<&'a User> {
        self.user.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"text_mention\" only, the mentioned user"]
    pub fn set_user<'a>(&'a mut self, user: Option<User>) -> &'a mut Self {
        self.user = if let Some(user) = user {
            Some(user)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"pre\" only, the programming language of the entity text"]
    pub fn get_language<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.language.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"pre\" only, the programming language of the entity text"]
    pub fn get_language_ref<'a>(&'a self) -> Option<&'a str> {
        self.language.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"pre\" only, the programming language of the entity text"]
    pub fn set_language<'a>(&'a mut self, language: Option<String>) -> &'a mut Self {
        self.language = if let Some(language) = language {
            Some(language)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"custom_emoji\" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker"]
    pub fn get_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.custom_emoji_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"custom_emoji\" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker"]
    pub fn get_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.custom_emoji_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For \"custom_emoji\" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker"]
    pub fn set_custom_emoji_id<'a>(&'a mut self, custom_emoji_id: Option<String>) -> &'a mut Self {
        self.custom_emoji_id = if let Some(custom_emoji_id) = custom_emoji_id {
            Some(custom_emoji_id)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatMemberAdministrator {
    pub fn new(
        user: User,
        can_be_edited: bool,
        is_anonymous: bool,
        can_manage_chat: bool,
        can_delete_messages: bool,
        can_manage_video_chats: bool,
        can_restrict_members: bool,
        can_promote_members: bool,
        can_change_info: bool,
        can_invite_users: bool,
    ) -> Self {
        Self {
            user,
            can_be_edited,
            is_anonymous,
            can_manage_chat,
            can_delete_messages,
            can_manage_video_chats,
            can_restrict_members,
            can_promote_members,
            can_change_info,
            can_invite_users,
            can_post_messages: None,
            can_edit_messages: None,
            can_pin_messages: None,
            can_post_stories: None,
            can_edit_stories: None,
            can_delete_stories: None,
            can_manage_topics: None,
            custom_title: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, can_be_edited, is_anonymous, can_manage_chat, can_delete_messages, can_manage_video_chats, can_restrict_members, can_promote_members, can_change_info, can_invite_users, can_post_messages, can_edit_messages, can_pin_messages, can_post_stories, can_edit_stories, can_delete_stories, can_manage_topics, custom_title)"]
    pub fn into_tuple(
        self,
    ) -> (
        User,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<String>,
    ) {
        (
            self.user,
            self.can_be_edited,
            self.is_anonymous,
            self.can_manage_chat,
            self.can_delete_messages,
            self.can_manage_video_chats,
            self.can_restrict_members,
            self.can_promote_members,
            self.can_change_info,
            self.can_invite_users,
            self.can_post_messages
                .map(|can_post_messages| can_post_messages),
            self.can_edit_messages
                .map(|can_edit_messages| can_edit_messages),
            self.can_pin_messages
                .map(|can_pin_messages| can_pin_messages),
            self.can_post_stories
                .map(|can_post_stories| can_post_stories),
            self.can_edit_stories
                .map(|can_edit_stories| can_edit_stories),
            self.can_delete_stories
                .map(|can_delete_stories| can_delete_stories),
            self.can_manage_topics
                .map(|can_manage_topics| can_manage_topics),
            self.custom_title.map(|custom_title| custom_title),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    pub fn get_can_be_edited<'a>(&'a self) -> bool {
        self.can_be_edited
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    pub fn get_can_be_edited_ref<'a>(&'a self) -> bool {
        self.can_be_edited
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    pub fn set_can_be_edited<'a>(&'a mut self, can_be_edited: bool) -> &'a mut Self {
        self.can_be_edited = can_be_edited;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn get_is_anonymous<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn get_is_anonymous_ref<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn set_is_anonymous<'a>(&'a mut self, is_anonymous: bool) -> &'a mut Self {
        self.is_anonymous = is_anonymous;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    pub fn get_can_manage_chat<'a>(&'a self) -> bool {
        self.can_manage_chat
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    pub fn get_can_manage_chat_ref<'a>(&'a self) -> bool {
        self.can_manage_chat
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    pub fn set_can_manage_chat<'a>(&'a mut self, can_manage_chat: bool) -> &'a mut Self {
        self.can_manage_chat = can_manage_chat;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    pub fn get_can_delete_messages<'a>(&'a self) -> bool {
        self.can_delete_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    pub fn get_can_delete_messages_ref<'a>(&'a self) -> bool {
        self.can_delete_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    pub fn set_can_delete_messages<'a>(&'a mut self, can_delete_messages: bool) -> &'a mut Self {
        self.can_delete_messages = can_delete_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    pub fn get_can_manage_video_chats<'a>(&'a self) -> bool {
        self.can_manage_video_chats
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    pub fn get_can_manage_video_chats_ref<'a>(&'a self) -> bool {
        self.can_manage_video_chats
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    pub fn set_can_manage_video_chats<'a>(
        &'a mut self,
        can_manage_video_chats: bool,
    ) -> &'a mut Self {
        self.can_manage_video_chats = can_manage_video_chats;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    pub fn get_can_restrict_members<'a>(&'a self) -> bool {
        self.can_restrict_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    pub fn get_can_restrict_members_ref<'a>(&'a self) -> bool {
        self.can_restrict_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    pub fn set_can_restrict_members<'a>(&'a mut self, can_restrict_members: bool) -> &'a mut Self {
        self.can_restrict_members = can_restrict_members;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    pub fn get_can_promote_members<'a>(&'a self) -> bool {
        self.can_promote_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    pub fn get_can_promote_members_ref<'a>(&'a self) -> bool {
        self.can_promote_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    pub fn set_can_promote_members<'a>(&'a mut self, can_promote_members: bool) -> &'a mut Self {
        self.can_promote_members = can_promote_members;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn get_can_change_info<'a>(&'a self) -> bool {
        self.can_change_info
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn get_can_change_info_ref<'a>(&'a self) -> bool {
        self.can_change_info
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn set_can_change_info<'a>(&'a mut self, can_change_info: bool) -> &'a mut Self {
        self.can_change_info = can_change_info;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn get_can_invite_users<'a>(&'a self) -> bool {
        self.can_invite_users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn get_can_invite_users_ref<'a>(&'a self) -> bool {
        self.can_invite_users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn set_can_invite_users<'a>(&'a mut self, can_invite_users: bool) -> &'a mut Self {
        self.can_invite_users = can_invite_users;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    pub fn get_can_post_messages<'a>(&'a self) -> Option<bool> {
        self.can_post_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    pub fn get_can_post_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_post_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    pub fn set_can_post_messages<'a>(
        &'a mut self,
        can_post_messages: Option<bool>,
    ) -> &'a mut Self {
        self.can_post_messages = if let Some(can_post_messages) = can_post_messages {
            Some(can_post_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    pub fn get_can_edit_messages<'a>(&'a self) -> Option<bool> {
        self.can_edit_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    pub fn get_can_edit_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_edit_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    pub fn set_can_edit_messages<'a>(
        &'a mut self,
        can_edit_messages: Option<bool>,
    ) -> &'a mut Self {
        self.can_edit_messages = if let Some(can_edit_messages) = can_edit_messages {
            Some(can_edit_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    pub fn get_can_pin_messages<'a>(&'a self) -> Option<bool> {
        self.can_pin_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    pub fn get_can_pin_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_pin_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    pub fn set_can_pin_messages<'a>(&'a mut self, can_pin_messages: Option<bool>) -> &'a mut Self {
        self.can_pin_messages = if let Some(can_pin_messages) = can_pin_messages {
            Some(can_pin_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    pub fn get_can_post_stories<'a>(&'a self) -> Option<bool> {
        self.can_post_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    pub fn get_can_post_stories_ref<'a>(&'a self) -> Option<bool> {
        self.can_post_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    pub fn set_can_post_stories<'a>(&'a mut self, can_post_stories: Option<bool>) -> &'a mut Self {
        self.can_post_stories = if let Some(can_post_stories) = can_post_stories {
            Some(can_post_stories)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    pub fn get_can_edit_stories<'a>(&'a self) -> Option<bool> {
        self.can_edit_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    pub fn get_can_edit_stories_ref<'a>(&'a self) -> Option<bool> {
        self.can_edit_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    pub fn set_can_edit_stories<'a>(&'a mut self, can_edit_stories: Option<bool>) -> &'a mut Self {
        self.can_edit_stories = if let Some(can_edit_stories) = can_edit_stories {
            Some(can_edit_stories)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    pub fn get_can_delete_stories<'a>(&'a self) -> Option<bool> {
        self.can_delete_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    pub fn get_can_delete_stories_ref<'a>(&'a self) -> Option<bool> {
        self.can_delete_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    pub fn set_can_delete_stories<'a>(
        &'a mut self,
        can_delete_stories: Option<bool>,
    ) -> &'a mut Self {
        self.can_delete_stories = if let Some(can_delete_stories) = can_delete_stories {
            Some(can_delete_stories)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    pub fn get_can_manage_topics<'a>(&'a self) -> Option<bool> {
        self.can_manage_topics.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    pub fn get_can_manage_topics_ref<'a>(&'a self) -> Option<bool> {
        self.can_manage_topics.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    pub fn set_can_manage_topics<'a>(
        &'a mut self,
        can_manage_topics: Option<bool>,
    ) -> &'a mut Self {
        self.can_manage_topics = if let Some(can_manage_topics) = can_manage_topics {
            Some(can_manage_topics)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    pub fn get_custom_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.custom_title
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    pub fn get_custom_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.custom_title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    pub fn set_custom_title<'a>(&'a mut self, custom_title: Option<String>) -> &'a mut Self {
        self.custom_title = if let Some(custom_title) = custom_title {
            Some(custom_title)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultVenue {
    pub fn new(
        id: String,
        latitude: ::ordered_float::OrderedFloat<f64>,
        longitude: ::ordered_float::OrderedFloat<f64>,
        title: String,
        address: String,
    ) -> Self {
        Self {
            tg_type: "venue".to_owned(),
            id,
            latitude,
            longitude,
            title,
            address,
            foursquare_id: None,
            foursquare_type: None,
            google_place_id: None,
            google_place_type: None,
            reply_markup: None,
            input_message_content: None,
            thumbnail_url: None,
            thumbnail_width: None,
            thumbnail_height: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, latitude, longitude, title, address, foursquare_id, foursquare_type, google_place_id, google_place_type, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.tg_type,
            self.id,
            self.latitude,
            self.longitude,
            self.title,
            self.address,
            self.foursquare_id.map(|foursquare_id| foursquare_id),
            self.foursquare_type.map(|foursquare_type| foursquare_type),
            self.google_place_id.map(|google_place_id| google_place_id),
            self.google_place_type
                .map(|google_place_type| google_place_type),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
            self.thumbnail_url.map(|thumbnail_url| thumbnail_url),
            self.thumbnail_width.map(|thumbnail_width| thumbnail_width),
            self.thumbnail_height
                .map(|thumbnail_height| thumbnail_height),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    pub fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    pub fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    pub fn set_latitude<'a>(
        &'a mut self,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    pub fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    pub fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    pub fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn get_address<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.address.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn get_address_ref<'a>(&'a self) -> &'a str {
        self.address.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn set_address<'a>(&'a mut self, address: String) -> &'a mut Self {
        self.address = address;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    pub fn get_foursquare_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.foursquare_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    pub fn get_foursquare_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.foursquare_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    pub fn set_foursquare_id<'a>(&'a mut self, foursquare_id: Option<String>) -> &'a mut Self {
        self.foursquare_id = if let Some(foursquare_id) = foursquare_id {
            Some(foursquare_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn get_foursquare_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.foursquare_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn get_foursquare_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.foursquare_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn set_foursquare_type<'a>(&'a mut self, foursquare_type: Option<String>) -> &'a mut Self {
        self.foursquare_type = if let Some(foursquare_type) = foursquare_type {
            Some(foursquare_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn get_google_place_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.google_place_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn get_google_place_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.google_place_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn set_google_place_id<'a>(&'a mut self, google_place_id: Option<String>) -> &'a mut Self {
        self.google_place_id = if let Some(google_place_id) = google_place_id {
            Some(google_place_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn get_google_place_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.google_place_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn get_google_place_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.google_place_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn set_google_place_type<'a>(
        &'a mut self,
        google_place_type: Option<String>,
    ) -> &'a mut Self {
        self.google_place_type = if let Some(google_place_type) = google_place_type {
            Some(google_place_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_url
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self {
        self.thumbnail_url = if let Some(thumbnail_url) = thumbnail_url {
            Some(thumbnail_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn get_thumbnail_width<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self {
        self.thumbnail_width = if let Some(thumbnail_width) = thumbnail_width {
            Some(thumbnail_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn get_thumbnail_height<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self {
        self.thumbnail_height = if let Some(thumbnail_height) = thumbnail_height {
            Some(thumbnail_height)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl Contact {
    pub fn new(phone_number: String, first_name: String) -> Self {
        Self {
            phone_number,
            first_name,
            last_name: None,
            user_id: None,
            vcard: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (phone_number, first_name, last_name, user_id, vcard)"]
    pub fn into_tuple(self) -> (String, String, Option<String>, Option<i64>, Option<String>) {
        (
            self.phone_number,
            self.first_name,
            self.last_name.map(|last_name| last_name),
            self.user_id.map(|user_id| user_id),
            self.vcard.map(|vcard| vcard),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn get_phone_number<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.phone_number.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn get_phone_number_ref<'a>(&'a self) -> &'a str {
        self.phone_number.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn set_phone_number<'a>(&'a mut self, phone_number: String) -> &'a mut Self {
        self.phone_number = phone_number;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn get_first_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.first_name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn get_first_name_ref<'a>(&'a self) -> &'a str {
        self.first_name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn set_first_name<'a>(&'a mut self, first_name: String) -> &'a mut Self {
        self.first_name = first_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.last_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn get_last_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.last_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self {
        self.last_name = if let Some(last_name) = last_name {
            Some(last_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_user_id<'a>(&'a self) -> Option<i64> {
        self.user_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_user_id_ref<'a>(&'a self) -> Option<i64> {
        self.user_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_user_id<'a>(&'a mut self, user_id: Option<i64>) -> &'a mut Self {
        self.user_id = if let Some(user_id) = user_id {
            Some(user_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard"]
    pub fn get_vcard<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.vcard.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard"]
    pub fn get_vcard_ref<'a>(&'a self) -> Option<&'a str> {
        self.vcard.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard"]
    pub fn set_vcard<'a>(&'a mut self, vcard: Option<String>) -> &'a mut Self {
        self.vcard = if let Some(vcard) = vcard {
            Some(vcard)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultGame {
    pub fn new(id: String, game_short_name: String) -> Self {
        Self {
            tg_type: "game".to_owned(),
            id,
            game_short_name,
            reply_markup: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, game_short_name, reply_markup)"]
    pub fn into_tuple(self) -> (String, String, String, Option<InlineKeyboardMarkup>) {
        (
            self.tg_type,
            self.id,
            self.game_short_name,
            self.reply_markup.map(|reply_markup| reply_markup),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    pub fn get_game_short_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.game_short_name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    pub fn get_game_short_name_ref<'a>(&'a self) -> &'a str {
        self.game_short_name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    pub fn set_game_short_name<'a>(&'a mut self, game_short_name: String) -> &'a mut Self {
        self.game_short_name = game_short_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl BotCommandScopeAllPrivateChats {
    pub fn new() -> Self {
        Self {
            tg_type: "all_private_chats".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    pub fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_private_chats"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
#[allow(dead_code)]
impl ForumTopicReopened {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    pub fn into_tuple(self) {
        ()
    }
}
#[allow(dead_code)]
impl UserProfilePhotos {
    pub fn new(total_count: i64, photos: Vec<Vec<PhotoSize>>) -> Self {
        Self {
            total_count,
            photos,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (total_count, photos)"]
    pub fn into_tuple(self) -> (i64, Vec<Vec<PhotoSize>>) {
        (self.total_count, self.photos)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of profile pictures the target user has"]
    pub fn get_total_count<'a>(&'a self) -> i64 {
        self.total_count
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of profile pictures the target user has"]
    pub fn get_total_count_ref<'a>(&'a self) -> i64 {
        self.total_count
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of profile pictures the target user has"]
    pub fn set_total_count<'a>(&'a mut self, total_count: i64) -> &'a mut Self {
        self.total_count = total_count;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requested profile pictures (in up to 4 sizes each)"]
    pub fn get_photos<'a>(&'a self) -> Cow<'a, Vec<Vec<PhotoSize>>> {
        Cow::Borrowed(&self.photos)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requested profile pictures (in up to 4 sizes each)"]
    pub fn get_photos_ref<'a>(&'a self) -> &'a Vec<Vec<PhotoSize>> {
        &self.photos
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requested profile pictures (in up to 4 sizes each)"]
    pub fn set_photos<'a>(&'a mut self, photos: Vec<Vec<PhotoSize>>) -> &'a mut Self {
        self.photos = photos;
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultsButton {
    pub fn new(text: String) -> Self {
        Self {
            text,
            web_app: None,
            start_parameter: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (text, web_app, start_parameter)"]
    pub fn into_tuple(self) -> (String, Option<WebAppInfo>, Option<String>) {
        (
            self.text,
            self.web_app.map(|web_app| web_app),
            self.start_parameter.map(|start_parameter| start_parameter),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    pub fn get_text<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.text.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    pub fn get_text_ref<'a>(&'a self) -> &'a str {
        self.text.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    pub fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."]
    pub fn get_web_app<'a>(&'a self) -> Option<Cow<'a, WebAppInfo>> {
        self.web_app.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."]
    pub fn get_web_app_ref<'a>(&'a self) -> Option<&'a WebAppInfo> {
        self.web_app.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."]
    pub fn set_web_app<'a>(&'a mut self, web_app: Option<WebAppInfo>) -> &'a mut Self {
        self.web_app = if let Some(web_app) = web_app {
            Some(web_app)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."]
    pub fn get_start_parameter<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.start_parameter
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."]
    pub fn get_start_parameter_ref<'a>(&'a self) -> Option<&'a str> {
        self.start_parameter.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."]
    pub fn set_start_parameter<'a>(&'a mut self, start_parameter: Option<String>) -> &'a mut Self {
        self.start_parameter = if let Some(start_parameter) = start_parameter {
            Some(start_parameter)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl Message {
    pub fn new(message_id: i64, date: i64, chat: Box<Chat>) -> Self {
        Self {
            message_id,
            date,
            chat,
            message_thread_id: None,
            from: None,
            sender_chat: None,
            forward_from: None,
            forward_from_chat: None,
            forward_from_message_id: None,
            forward_signature: None,
            forward_sender_name: None,
            forward_date: None,
            is_topic_message: None,
            is_automatic_forward: None,
            reply_to_message: None,
            via_bot: None,
            edit_date: None,
            has_protected_content: None,
            media_group_id: None,
            author_signature: None,
            text: None,
            entities: None,
            animation: None,
            audio: None,
            document: None,
            photo: None,
            sticker: None,
            story: None,
            video: None,
            video_note: None,
            voice: None,
            caption: None,
            caption_entities: None,
            has_media_spoiler: None,
            contact: None,
            dice: None,
            game: None,
            poll: None,
            venue: None,
            location: None,
            new_chat_members: None,
            left_chat_member: None,
            new_chat_title: None,
            new_chat_photo: None,
            delete_chat_photo: None,
            group_chat_created: None,
            supergroup_chat_created: None,
            channel_chat_created: None,
            message_auto_delete_timer_changed: None,
            migrate_to_chat_id: None,
            migrate_from_chat_id: None,
            pinned_message: None,
            invoice: None,
            successful_payment: None,
            user_shared: None,
            chat_shared: None,
            connected_website: None,
            write_access_allowed: None,
            passport_data: None,
            proximity_alert_triggered: None,
            forum_topic_created: None,
            forum_topic_edited: None,
            forum_topic_closed: None,
            forum_topic_reopened: None,
            general_forum_topic_hidden: None,
            general_forum_topic_unhidden: None,
            video_chat_scheduled: None,
            video_chat_started: None,
            video_chat_ended: None,
            video_chat_participants_invited: None,
            web_app_data: None,
            reply_markup: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_id, message_thread_id, from, sender_chat, date, chat, forward_from, forward_from_chat, forward_from_message_id, forward_signature, forward_sender_name, forward_date, is_topic_message, is_automatic_forward, reply_to_message, via_bot, edit_date, has_protected_content, media_group_id, author_signature, text, entities, animation, audio, document, photo, sticker, story, video, video_note, voice, caption, caption_entities, has_media_spoiler, contact, dice, game, poll, venue, location, new_chat_members, left_chat_member, new_chat_title, new_chat_photo, delete_chat_photo, group_chat_created, supergroup_chat_created, channel_chat_created, message_auto_delete_timer_changed, migrate_to_chat_id, migrate_from_chat_id, pinned_message, invoice, successful_payment, user_shared, chat_shared, connected_website, write_access_allowed, passport_data, proximity_alert_triggered, forum_topic_created, forum_topic_edited, forum_topic_closed, forum_topic_reopened, general_forum_topic_hidden, general_forum_topic_unhidden, video_chat_scheduled, video_chat_started, video_chat_ended, video_chat_participants_invited, web_app_data, reply_markup)"]
    pub fn into_tuple(
        self,
    ) -> (
        i64,
        Option<i64>,
        Option<User>,
        Option<Chat>,
        i64,
        Chat,
        Option<User>,
        Option<Chat>,
        Option<i64>,
        Option<String>,
        Option<String>,
        Option<i64>,
        Option<bool>,
        Option<bool>,
        Option<Message>,
        Option<User>,
        Option<i64>,
        Option<bool>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<Animation>,
        Option<Audio>,
        Option<Document>,
        Option<Vec<PhotoSize>>,
        Option<Sticker>,
        Option<Story>,
        Option<Video>,
        Option<VideoNote>,
        Option<Voice>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
        Option<Contact>,
        Option<Dice>,
        Option<Game>,
        Option<Poll>,
        Option<Venue>,
        Option<Location>,
        Option<Vec<User>>,
        Option<User>,
        Option<String>,
        Option<Vec<PhotoSize>>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<MessageAutoDeleteTimerChanged>,
        Option<i64>,
        Option<i64>,
        Option<Message>,
        Option<Invoice>,
        Option<SuccessfulPayment>,
        Option<UserShared>,
        Option<ChatShared>,
        Option<String>,
        Option<WriteAccessAllowed>,
        Option<PassportData>,
        Option<ProximityAlertTriggered>,
        Option<ForumTopicCreated>,
        Option<ForumTopicEdited>,
        Option<ForumTopicClosed>,
        Option<ForumTopicReopened>,
        Option<GeneralForumTopicHidden>,
        Option<GeneralForumTopicUnhidden>,
        Option<VideoChatScheduled>,
        Option<VideoChatStarted>,
        Option<VideoChatEnded>,
        Option<VideoChatParticipantsInvited>,
        Option<WebAppData>,
        Option<InlineKeyboardMarkup>,
    ) {
        (
            self.message_id,
            self.message_thread_id
                .map(|message_thread_id| message_thread_id),
            self.from.map(|from| from),
            self.sender_chat.map(|sender_chat| (*sender_chat)),
            self.date,
            (*self.chat),
            self.forward_from.map(|forward_from| forward_from),
            self.forward_from_chat
                .map(|forward_from_chat| (*forward_from_chat)),
            self.forward_from_message_id
                .map(|forward_from_message_id| forward_from_message_id),
            self.forward_signature
                .map(|forward_signature| forward_signature),
            self.forward_sender_name
                .map(|forward_sender_name| forward_sender_name),
            self.forward_date.map(|forward_date| forward_date),
            self.is_topic_message
                .map(|is_topic_message| is_topic_message),
            self.is_automatic_forward
                .map(|is_automatic_forward| is_automatic_forward),
            self.reply_to_message
                .map(|reply_to_message| (*reply_to_message)),
            self.via_bot.map(|via_bot| via_bot),
            self.edit_date.map(|edit_date| edit_date),
            self.has_protected_content
                .map(|has_protected_content| has_protected_content),
            self.media_group_id.map(|media_group_id| media_group_id),
            self.author_signature
                .map(|author_signature| author_signature),
            self.text.map(|text| text),
            self.entities.map(|entities| entities),
            self.animation.map(|animation| animation),
            self.audio.map(|audio| audio),
            self.document.map(|document| document),
            self.photo.map(|photo| photo),
            self.sticker.map(|sticker| sticker),
            self.story.map(|story| story),
            self.video.map(|video| video),
            self.video_note.map(|video_note| video_note),
            self.voice.map(|voice| voice),
            self.caption.map(|caption| caption),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.has_media_spoiler
                .map(|has_media_spoiler| has_media_spoiler),
            self.contact.map(|contact| contact),
            self.dice.map(|dice| dice),
            self.game.map(|game| game),
            self.poll.map(|poll| poll),
            self.venue.map(|venue| venue),
            self.location.map(|location| location),
            self.new_chat_members
                .map(|new_chat_members| new_chat_members),
            self.left_chat_member
                .map(|left_chat_member| left_chat_member),
            self.new_chat_title.map(|new_chat_title| new_chat_title),
            self.new_chat_photo.map(|new_chat_photo| new_chat_photo),
            self.delete_chat_photo
                .map(|delete_chat_photo| delete_chat_photo),
            self.group_chat_created
                .map(|group_chat_created| group_chat_created),
            self.supergroup_chat_created
                .map(|supergroup_chat_created| supergroup_chat_created),
            self.channel_chat_created
                .map(|channel_chat_created| channel_chat_created),
            self.message_auto_delete_timer_changed
                .map(|message_auto_delete_timer_changed| message_auto_delete_timer_changed),
            self.migrate_to_chat_id
                .map(|migrate_to_chat_id| migrate_to_chat_id),
            self.migrate_from_chat_id
                .map(|migrate_from_chat_id| migrate_from_chat_id),
            self.pinned_message.map(|pinned_message| (*pinned_message)),
            self.invoice.map(|invoice| invoice),
            self.successful_payment
                .map(|successful_payment| successful_payment),
            self.user_shared.map(|user_shared| user_shared),
            self.chat_shared.map(|chat_shared| chat_shared),
            self.connected_website
                .map(|connected_website| connected_website),
            self.write_access_allowed
                .map(|write_access_allowed| write_access_allowed),
            self.passport_data.map(|passport_data| passport_data),
            self.proximity_alert_triggered
                .map(|proximity_alert_triggered| proximity_alert_triggered),
            self.forum_topic_created
                .map(|forum_topic_created| forum_topic_created),
            self.forum_topic_edited
                .map(|forum_topic_edited| forum_topic_edited),
            self.forum_topic_closed
                .map(|forum_topic_closed| forum_topic_closed),
            self.forum_topic_reopened
                .map(|forum_topic_reopened| forum_topic_reopened),
            self.general_forum_topic_hidden
                .map(|general_forum_topic_hidden| general_forum_topic_hidden),
            self.general_forum_topic_unhidden
                .map(|general_forum_topic_unhidden| general_forum_topic_unhidden),
            self.video_chat_scheduled
                .map(|video_chat_scheduled| video_chat_scheduled),
            self.video_chat_started
                .map(|video_chat_started| video_chat_started),
            self.video_chat_ended
                .map(|video_chat_ended| video_chat_ended),
            self.video_chat_participants_invited
                .map(|video_chat_participants_invited| video_chat_participants_invited),
            self.web_app_data.map(|web_app_data| web_app_data),
            self.reply_markup.map(|reply_markup| reply_markup),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    pub fn get_message_id<'a>(&'a self) -> i64 {
        self.message_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    pub fn get_message_id_ref<'a>(&'a self) -> i64 {
        self.message_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique message identifier inside this chat"]
    pub fn set_message_id<'a>(&'a mut self, message_id: i64) -> &'a mut Self {
        self.message_id = message_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    pub fn get_message_thread_id<'a>(&'a self) -> Option<i64> {
        self.message_thread_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    pub fn get_message_thread_id_ref<'a>(&'a self) -> Option<i64> {
        self.message_thread_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"]
    pub fn set_message_thread_id<'a>(&'a mut self, message_thread_id: Option<i64>) -> &'a mut Self {
        self.message_thread_id = if let Some(message_thread_id) = message_thread_id {
            Some(message_thread_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    pub fn get_from<'a>(&'a self) -> Option<Cow<'a, User>> {
        self.from.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    pub fn get_from_ref<'a>(&'a self) -> Option<&'a User> {
        self.from.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    pub fn set_from<'a>(&'a mut self, from: Option<User>) -> &'a mut Self {
        self.from = if let Some(from) = from {
            Some(from)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    pub fn get_sender_chat<'a>(&'a self) -> Option<Cow<'a, Chat>> {
        self.sender_chat.as_ref().map(|v| Cow::Borrowed(v.as_ref()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    pub fn get_sender_chat_ref<'a>(&'a self) -> Option<&'a Chat> {
        self.sender_chat.as_ref().map(|v| v.as_ref())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."]
    pub fn set_sender_chat<'a>(&'a mut self, sender_chat: Option<Chat>) -> &'a mut Self {
        self.sender_chat = if let Some(sender_chat) = sender_chat {
            Some(Box::new(sender_chat))
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    pub fn get_date<'a>(&'a self) -> i64 {
        self.date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    pub fn get_date_ref<'a>(&'a self) -> i64 {
        self.date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the message was sent in Unix time"]
    pub fn set_date<'a>(&'a mut self, date: i64) -> &'a mut Self {
        self.date = date;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    pub fn get_chat<'a>(&'a self) -> Cow<'a, Chat> {
        Cow::Borrowed(self.chat.as_ref())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    pub fn get_chat_ref<'a>(&'a self) -> &'a Chat {
        self.chat.as_ref()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Conversation the message belongs to"]
    pub fn set_chat<'a>(&'a mut self, chat: Chat) -> &'a mut Self {
        self.chat = Box::new(chat);
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    pub fn get_forward_from<'a>(&'a self) -> Option<Cow<'a, User>> {
        self.forward_from.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    pub fn get_forward_from_ref<'a>(&'a self) -> Option<&'a User> {
        self.forward_from.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, sender of the original message"]
    pub fn set_forward_from<'a>(&'a mut self, forward_from: Option<User>) -> &'a mut Self {
        self.forward_from = if let Some(forward_from) = forward_from {
            Some(forward_from)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    pub fn get_forward_from_chat<'a>(&'a self) -> Option<Cow<'a, Chat>> {
        self.forward_from_chat
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_ref()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    pub fn get_forward_from_chat_ref<'a>(&'a self) -> Option<&'a Chat> {
        self.forward_from_chat.as_ref().map(|v| v.as_ref())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"]
    pub fn set_forward_from_chat<'a>(
        &'a mut self,
        forward_from_chat: Option<Chat>,
    ) -> &'a mut Self {
        self.forward_from_chat = if let Some(forward_from_chat) = forward_from_chat {
            Some(Box::new(forward_from_chat))
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    pub fn get_forward_from_message_id<'a>(&'a self) -> Option<i64> {
        self.forward_from_message_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    pub fn get_forward_from_message_id_ref<'a>(&'a self) -> Option<i64> {
        self.forward_from_message_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages forwarded from channels, identifier of the original message in the channel"]
    pub fn set_forward_from_message_id<'a>(
        &'a mut self,
        forward_from_message_id: Option<i64>,
    ) -> &'a mut Self {
        self.forward_from_message_id =
            if let Some(forward_from_message_id) = forward_from_message_id {
                Some(forward_from_message_id)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    pub fn get_forward_signature<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.forward_signature
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    pub fn get_forward_signature_ref<'a>(&'a self) -> Option<&'a str> {
        self.forward_signature.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"]
    pub fn set_forward_signature<'a>(
        &'a mut self,
        forward_signature: Option<String>,
    ) -> &'a mut Self {
        self.forward_signature = if let Some(forward_signature) = forward_signature {
            Some(forward_signature)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    pub fn get_forward_sender_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.forward_sender_name
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    pub fn get_forward_sender_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.forward_sender_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"]
    pub fn set_forward_sender_name<'a>(
        &'a mut self,
        forward_sender_name: Option<String>,
    ) -> &'a mut Self {
        self.forward_sender_name = if let Some(forward_sender_name) = forward_sender_name {
            Some(forward_sender_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    pub fn get_forward_date<'a>(&'a self) -> Option<i64> {
        self.forward_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    pub fn get_forward_date_ref<'a>(&'a self) -> Option<i64> {
        self.forward_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For forwarded messages, date the original message was sent in Unix time"]
    pub fn set_forward_date<'a>(&'a mut self, forward_date: Option<i64>) -> &'a mut Self {
        self.forward_date = if let Some(forward_date) = forward_date {
            Some(forward_date)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    pub fn get_is_topic_message<'a>(&'a self) -> Option<bool> {
        self.is_topic_message.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    pub fn get_is_topic_message_ref<'a>(&'a self) -> Option<bool> {
        self.is_topic_message.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is sent to a forum topic"]
    pub fn set_is_topic_message<'a>(&'a mut self, is_topic_message: Option<bool>) -> &'a mut Self {
        self.is_topic_message = if let Some(is_topic_message) = is_topic_message {
            Some(is_topic_message)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    pub fn get_is_automatic_forward<'a>(&'a self) -> Option<bool> {
        self.is_automatic_forward.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    pub fn get_is_automatic_forward_ref<'a>(&'a self) -> Option<bool> {
        self.is_automatic_forward.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"]
    pub fn set_is_automatic_forward<'a>(
        &'a mut self,
        is_automatic_forward: Option<bool>,
    ) -> &'a mut Self {
        self.is_automatic_forward = if let Some(is_automatic_forward) = is_automatic_forward {
            Some(is_automatic_forward)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    pub fn get_reply_to_message<'a>(&'a self) -> Option<Cow<'a, Message>> {
        self.reply_to_message
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_ref()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    pub fn get_reply_to_message_ref<'a>(&'a self) -> Option<&'a Message> {
        self.reply_to_message.as_ref().map(|v| v.as_ref())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."]
    pub fn set_reply_to_message<'a>(
        &'a mut self,
        reply_to_message: Option<Message>,
    ) -> &'a mut Self {
        self.reply_to_message = if let Some(reply_to_message) = reply_to_message {
            Some(Box::new(reply_to_message))
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    pub fn get_via_bot<'a>(&'a self) -> Option<Cow<'a, User>> {
        self.via_bot.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    pub fn get_via_bot_ref<'a>(&'a self) -> Option<&'a User> {
        self.via_bot.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bot through which the message was sent"]
    pub fn set_via_bot<'a>(&'a mut self, via_bot: Option<User>) -> &'a mut Self {
        self.via_bot = if let Some(via_bot) = via_bot {
            Some(via_bot)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    pub fn get_edit_date<'a>(&'a self) -> Option<i64> {
        self.edit_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    pub fn get_edit_date_ref<'a>(&'a self) -> Option<i64> {
        self.edit_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Date the message was last edited in Unix time"]
    pub fn set_edit_date<'a>(&'a mut self, edit_date: Option<i64>) -> &'a mut Self {
        self.edit_date = if let Some(edit_date) = edit_date {
            Some(edit_date)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    pub fn get_has_protected_content<'a>(&'a self) -> Option<bool> {
        self.has_protected_content.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    pub fn get_has_protected_content_ref<'a>(&'a self) -> Option<bool> {
        self.has_protected_content.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message can't be forwarded"]
    pub fn set_has_protected_content<'a>(
        &'a mut self,
        has_protected_content: Option<bool>,
    ) -> &'a mut Self {
        self.has_protected_content = if let Some(has_protected_content) = has_protected_content {
            Some(has_protected_content)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    pub fn get_media_group_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.media_group_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    pub fn get_media_group_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.media_group_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The unique identifier of a media message group this message belongs to"]
    pub fn set_media_group_id<'a>(&'a mut self, media_group_id: Option<String>) -> &'a mut Self {
        self.media_group_id = if let Some(media_group_id) = media_group_id {
            Some(media_group_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    pub fn get_author_signature<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.author_signature
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    pub fn get_author_signature_ref<'a>(&'a self) -> Option<&'a str> {
        self.author_signature.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"]
    pub fn set_author_signature<'a>(
        &'a mut self,
        author_signature: Option<String>,
    ) -> &'a mut Self {
        self.author_signature = if let Some(author_signature) = author_signature {
            Some(author_signature)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    pub fn get_text<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.text.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    pub fn get_text_ref<'a>(&'a self) -> Option<&'a str> {
        self.text.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, the actual UTF-8 text of the message"]
    pub fn set_text<'a>(&'a mut self, text: Option<String>) -> &'a mut Self {
        self.text = if let Some(text) = text {
            Some(text)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    pub fn get_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    pub fn get_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"]
    pub fn set_entities<'a>(&'a mut self, entities: Option<Vec<MessageEntity>>) -> &'a mut Self {
        self.entities = if let Some(entities) = entities {
            Some(entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    pub fn get_animation<'a>(&'a self) -> Option<Cow<'a, Animation>> {
        self.animation.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    pub fn get_animation_ref<'a>(&'a self) -> Option<&'a Animation> {
        self.animation.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"]
    pub fn set_animation<'a>(&'a mut self, animation: Option<Animation>) -> &'a mut Self {
        self.animation = if let Some(animation) = animation {
            Some(animation)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    pub fn get_audio<'a>(&'a self) -> Option<Cow<'a, Audio>> {
        self.audio.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    pub fn get_audio_ref<'a>(&'a self) -> Option<&'a Audio> {
        self.audio.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an audio file, information about the file"]
    pub fn set_audio<'a>(&'a mut self, audio: Option<Audio>) -> &'a mut Self {
        self.audio = if let Some(audio) = audio {
            Some(audio)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    pub fn get_document<'a>(&'a self) -> Option<Cow<'a, Document>> {
        self.document.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    pub fn get_document_ref<'a>(&'a self) -> Option<&'a Document> {
        self.document.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a general file, information about the file"]
    pub fn set_document<'a>(&'a mut self, document: Option<Document>) -> &'a mut Self {
        self.document = if let Some(document) = document {
            Some(document)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    pub fn get_photo<'a>(&'a self) -> Option<Cow<'a, Vec<PhotoSize>>> {
        self.photo.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    pub fn get_photo_ref<'a>(&'a self) -> Option<&'a Vec<PhotoSize>> {
        self.photo.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a photo, available sizes of the photo"]
    pub fn set_photo<'a>(&'a mut self, photo: Option<Vec<PhotoSize>>) -> &'a mut Self {
        self.photo = if let Some(photo) = photo {
            Some(photo)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    pub fn get_sticker<'a>(&'a self) -> Option<Cow<'a, Sticker>> {
        self.sticker.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    pub fn get_sticker_ref<'a>(&'a self) -> Option<&'a Sticker> {
        self.sticker.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a sticker, information about the sticker"]
    pub fn set_sticker<'a>(&'a mut self, sticker: Option<Sticker>) -> &'a mut Self {
        self.sticker = if let Some(sticker) = sticker {
            Some(sticker)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    pub fn get_story<'a>(&'a self) -> Option<Cow<'a, Story>> {
        self.story.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    pub fn get_story_ref<'a>(&'a self) -> Option<&'a Story> {
        self.story.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a forwarded story"]
    pub fn set_story<'a>(&'a mut self, story: Option<Story>) -> &'a mut Self {
        self.story = if let Some(story) = story {
            Some(story)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    pub fn get_video<'a>(&'a self) -> Option<Cow<'a, Video>> {
        self.video.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    pub fn get_video_ref<'a>(&'a self) -> Option<&'a Video> {
        self.video.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video, information about the video"]
    pub fn set_video<'a>(&'a mut self, video: Option<Video>) -> &'a mut Self {
        self.video = if let Some(video) = video {
            Some(video)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    pub fn get_video_note<'a>(&'a self) -> Option<Cow<'a, VideoNote>> {
        self.video_note.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    pub fn get_video_note_ref<'a>(&'a self) -> Option<&'a VideoNote> {
        self.video_note.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a video note, information about the video message"]
    pub fn set_video_note<'a>(&'a mut self, video_note: Option<VideoNote>) -> &'a mut Self {
        self.video_note = if let Some(video_note) = video_note {
            Some(video_note)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    pub fn get_voice<'a>(&'a self) -> Option<Cow<'a, Voice>> {
        self.voice.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    pub fn get_voice_ref<'a>(&'a self) -> Option<&'a Voice> {
        self.voice.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a voice message, information about the file"]
    pub fn set_voice<'a>(&'a mut self, voice: Option<Voice>) -> &'a mut Self {
        self.voice = if let Some(voice) = voice {
            Some(voice)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption for the animation, audio, document, photo, video or voice"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    pub fn get_has_media_spoiler<'a>(&'a self) -> Option<bool> {
        self.has_media_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    pub fn get_has_media_spoiler_ref<'a>(&'a self) -> Option<bool> {
        self.has_media_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the message media is covered by a spoiler animation"]
    pub fn set_has_media_spoiler<'a>(
        &'a mut self,
        has_media_spoiler: Option<bool>,
    ) -> &'a mut Self {
        self.has_media_spoiler = if let Some(has_media_spoiler) = has_media_spoiler {
            Some(has_media_spoiler)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    pub fn get_contact<'a>(&'a self) -> Option<Cow<'a, Contact>> {
        self.contact.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    pub fn get_contact_ref<'a>(&'a self) -> Option<&'a Contact> {
        self.contact.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared contact, information about the contact"]
    pub fn set_contact<'a>(&'a mut self, contact: Option<Contact>) -> &'a mut Self {
        self.contact = if let Some(contact) = contact {
            Some(contact)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    pub fn get_dice<'a>(&'a self) -> Option<Cow<'a, Dice>> {
        self.dice.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    pub fn get_dice_ref<'a>(&'a self) -> Option<&'a Dice> {
        self.dice.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a dice with random value"]
    pub fn set_dice<'a>(&'a mut self, dice: Option<Dice>) -> &'a mut Self {
        self.dice = if let Some(dice) = dice {
            Some(dice)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    pub fn get_game<'a>(&'a self) -> Option<Cow<'a, Game>> {
        self.game.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    pub fn get_game_ref<'a>(&'a self) -> Option<&'a Game> {
        self.game.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"]
    pub fn set_game<'a>(&'a mut self, game: Option<Game>) -> &'a mut Self {
        self.game = if let Some(game) = game {
            Some(game)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    pub fn get_poll<'a>(&'a self) -> Option<Cow<'a, Poll>> {
        self.poll.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    pub fn get_poll_ref<'a>(&'a self) -> Option<&'a Poll> {
        self.poll.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a native poll, information about the poll"]
    pub fn set_poll<'a>(&'a mut self, poll: Option<Poll>) -> &'a mut Self {
        self.poll = if let Some(poll) = poll {
            Some(poll)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    pub fn get_venue<'a>(&'a self) -> Option<Cow<'a, Venue>> {
        self.venue.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    pub fn get_venue_ref<'a>(&'a self) -> Option<&'a Venue> {
        self.venue.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"]
    pub fn set_venue<'a>(&'a mut self, venue: Option<Venue>) -> &'a mut Self {
        self.venue = if let Some(venue) = venue {
            Some(venue)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared location, information about the location"]
    pub fn get_location<'a>(&'a self) -> Option<Cow<'a, Location>> {
        self.location.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared location, information about the location"]
    pub fn get_location_ref<'a>(&'a self) -> Option<&'a Location> {
        self.location.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a shared location, information about the location"]
    pub fn set_location<'a>(&'a mut self, location: Option<Location>) -> &'a mut Self {
        self.location = if let Some(location) = location {
            Some(location)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    pub fn get_new_chat_members<'a>(&'a self) -> Option<Cow<'a, Vec<User>>> {
        self.new_chat_members.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    pub fn get_new_chat_members_ref<'a>(&'a self) -> Option<&'a Vec<User>> {
        self.new_chat_members.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"]
    pub fn set_new_chat_members<'a>(
        &'a mut self,
        new_chat_members: Option<Vec<User>>,
    ) -> &'a mut Self {
        self.new_chat_members = if let Some(new_chat_members) = new_chat_members {
            Some(new_chat_members)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    pub fn get_left_chat_member<'a>(&'a self) -> Option<Cow<'a, User>> {
        self.left_chat_member.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    pub fn get_left_chat_member_ref<'a>(&'a self) -> Option<&'a User> {
        self.left_chat_member.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A member was removed from the group, information about them (this member may be the bot itself)"]
    pub fn set_left_chat_member<'a>(&'a mut self, left_chat_member: Option<User>) -> &'a mut Self {
        self.left_chat_member = if let Some(left_chat_member) = left_chat_member {
            Some(left_chat_member)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    pub fn get_new_chat_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.new_chat_title
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    pub fn get_new_chat_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.new_chat_title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat title was changed to this value"]
    pub fn set_new_chat_title<'a>(&'a mut self, new_chat_title: Option<String>) -> &'a mut Self {
        self.new_chat_title = if let Some(new_chat_title) = new_chat_title {
            Some(new_chat_title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    pub fn get_new_chat_photo<'a>(&'a self) -> Option<Cow<'a, Vec<PhotoSize>>> {
        self.new_chat_photo.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    pub fn get_new_chat_photo_ref<'a>(&'a self) -> Option<&'a Vec<PhotoSize>> {
        self.new_chat_photo.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat photo was change to this value"]
    pub fn set_new_chat_photo<'a>(
        &'a mut self,
        new_chat_photo: Option<Vec<PhotoSize>>,
    ) -> &'a mut Self {
        self.new_chat_photo = if let Some(new_chat_photo) = new_chat_photo {
            Some(new_chat_photo)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    pub fn get_delete_chat_photo<'a>(&'a self) -> Option<bool> {
        self.delete_chat_photo.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    pub fn get_delete_chat_photo_ref<'a>(&'a self) -> Option<bool> {
        self.delete_chat_photo.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the chat photo was deleted"]
    pub fn set_delete_chat_photo<'a>(
        &'a mut self,
        delete_chat_photo: Option<bool>,
    ) -> &'a mut Self {
        self.delete_chat_photo = if let Some(delete_chat_photo) = delete_chat_photo {
            Some(delete_chat_photo)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    pub fn get_group_chat_created<'a>(&'a self) -> Option<bool> {
        self.group_chat_created.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    pub fn get_group_chat_created_ref<'a>(&'a self) -> Option<bool> {
        self.group_chat_created.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the group has been created"]
    pub fn set_group_chat_created<'a>(
        &'a mut self,
        group_chat_created: Option<bool>,
    ) -> &'a mut Self {
        self.group_chat_created = if let Some(group_chat_created) = group_chat_created {
            Some(group_chat_created)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    pub fn get_supergroup_chat_created<'a>(&'a self) -> Option<bool> {
        self.supergroup_chat_created.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    pub fn get_supergroup_chat_created_ref<'a>(&'a self) -> Option<bool> {
        self.supergroup_chat_created.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."]
    pub fn set_supergroup_chat_created<'a>(
        &'a mut self,
        supergroup_chat_created: Option<bool>,
    ) -> &'a mut Self {
        self.supergroup_chat_created =
            if let Some(supergroup_chat_created) = supergroup_chat_created {
                Some(supergroup_chat_created)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    pub fn get_channel_chat_created<'a>(&'a self) -> Option<bool> {
        self.channel_chat_created.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    pub fn get_channel_chat_created_ref<'a>(&'a self) -> Option<bool> {
        self.channel_chat_created.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."]
    pub fn set_channel_chat_created<'a>(
        &'a mut self,
        channel_chat_created: Option<bool>,
    ) -> &'a mut Self {
        self.channel_chat_created = if let Some(channel_chat_created) = channel_chat_created {
            Some(channel_chat_created)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    pub fn get_message_auto_delete_timer_changed<'a>(
        &'a self,
    ) -> Option<Cow<'a, MessageAutoDeleteTimerChanged>> {
        self.message_auto_delete_timer_changed
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    pub fn get_message_auto_delete_timer_changed_ref<'a>(
        &'a self,
    ) -> Option<&'a MessageAutoDeleteTimerChanged> {
        self.message_auto_delete_timer_changed.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: auto-delete timer settings changed in the chat"]
    pub fn set_message_auto_delete_timer_changed<'a>(
        &'a mut self,
        message_auto_delete_timer_changed: Option<MessageAutoDeleteTimerChanged>,
    ) -> &'a mut Self {
        self.message_auto_delete_timer_changed =
            if let Some(message_auto_delete_timer_changed) = message_auto_delete_timer_changed {
                Some(message_auto_delete_timer_changed)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_migrate_to_chat_id<'a>(&'a self) -> Option<i64> {
        self.migrate_to_chat_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_migrate_to_chat_id_ref<'a>(&'a self) -> Option<i64> {
        self.migrate_to_chat_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_migrate_to_chat_id<'a>(
        &'a mut self,
        migrate_to_chat_id: Option<i64>,
    ) -> &'a mut Self {
        self.migrate_to_chat_id = if let Some(migrate_to_chat_id) = migrate_to_chat_id {
            Some(migrate_to_chat_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_migrate_from_chat_id<'a>(&'a self) -> Option<i64> {
        self.migrate_from_chat_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_migrate_from_chat_id_ref<'a>(&'a self) -> Option<i64> {
        self.migrate_from_chat_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_migrate_from_chat_id<'a>(
        &'a mut self,
        migrate_from_chat_id: Option<i64>,
    ) -> &'a mut Self {
        self.migrate_from_chat_id = if let Some(migrate_from_chat_id) = migrate_from_chat_id {
            Some(migrate_from_chat_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    pub fn get_pinned_message<'a>(&'a self) -> Option<Cow<'a, Message>> {
        self.pinned_message
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_ref()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    pub fn get_pinned_message_ref<'a>(&'a self) -> Option<&'a Message> {
        self.pinned_message.as_ref().map(|v| v.as_ref())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."]
    pub fn set_pinned_message<'a>(&'a mut self, pinned_message: Option<Message>) -> &'a mut Self {
        self.pinned_message = if let Some(pinned_message) = pinned_message {
            Some(Box::new(pinned_message))
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    pub fn get_invoice<'a>(&'a self) -> Option<Cow<'a, Invoice>> {
        self.invoice.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    pub fn get_invoice_ref<'a>(&'a self) -> Option<&'a Invoice> {
        self.invoice.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"]
    pub fn set_invoice<'a>(&'a mut self, invoice: Option<Invoice>) -> &'a mut Self {
        self.invoice = if let Some(invoice) = invoice {
            Some(invoice)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    pub fn get_successful_payment<'a>(&'a self) -> Option<Cow<'a, SuccessfulPayment>> {
        self.successful_payment.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    pub fn get_successful_payment_ref<'a>(&'a self) -> Option<&'a SuccessfulPayment> {
        self.successful_payment.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"]
    pub fn set_successful_payment<'a>(
        &'a mut self,
        successful_payment: Option<SuccessfulPayment>,
    ) -> &'a mut Self {
        self.successful_payment = if let Some(successful_payment) = successful_payment {
            Some(successful_payment)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    pub fn get_user_shared<'a>(&'a self) -> Option<Cow<'a, UserShared>> {
        self.user_shared.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    pub fn get_user_shared_ref<'a>(&'a self) -> Option<&'a UserShared> {
        self.user_shared.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a user was shared with the bot"]
    pub fn set_user_shared<'a>(&'a mut self, user_shared: Option<UserShared>) -> &'a mut Self {
        self.user_shared = if let Some(user_shared) = user_shared {
            Some(user_shared)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    pub fn get_chat_shared<'a>(&'a self) -> Option<Cow<'a, ChatShared>> {
        self.chat_shared.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    pub fn get_chat_shared_ref<'a>(&'a self) -> Option<&'a ChatShared> {
        self.chat_shared.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: a chat was shared with the bot"]
    pub fn set_chat_shared<'a>(&'a mut self, chat_shared: Option<ChatShared>) -> &'a mut Self {
        self.chat_shared = if let Some(chat_shared) = chat_shared {
            Some(chat_shared)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    pub fn get_connected_website<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.connected_website
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    pub fn get_connected_website_ref<'a>(&'a self) -> Option<&'a str> {
        self.connected_website.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"]
    pub fn set_connected_website<'a>(
        &'a mut self,
        connected_website: Option<String>,
    ) -> &'a mut Self {
        self.connected_website = if let Some(connected_website) = connected_website {
            Some(connected_website)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    pub fn get_write_access_allowed<'a>(&'a self) -> Option<Cow<'a, WriteAccessAllowed>> {
        self.write_access_allowed.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    pub fn get_write_access_allowed_ref<'a>(&'a self) -> Option<&'a WriteAccessAllowed> {
        self.write_access_allowed.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"]
    pub fn set_write_access_allowed<'a>(
        &'a mut self,
        write_access_allowed: Option<WriteAccessAllowed>,
    ) -> &'a mut Self {
        self.write_access_allowed = if let Some(write_access_allowed) = write_access_allowed {
            Some(write_access_allowed)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    pub fn get_passport_data<'a>(&'a self) -> Option<Cow<'a, PassportData>> {
        self.passport_data.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    pub fn get_passport_data_ref<'a>(&'a self) -> Option<&'a PassportData> {
        self.passport_data.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Telegram Passport data"]
    pub fn set_passport_data<'a>(
        &'a mut self,
        passport_data: Option<PassportData>,
    ) -> &'a mut Self {
        self.passport_data = if let Some(passport_data) = passport_data {
            Some(passport_data)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    pub fn get_proximity_alert_triggered<'a>(&'a self) -> Option<Cow<'a, ProximityAlertTriggered>> {
        self.proximity_alert_triggered
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    pub fn get_proximity_alert_triggered_ref<'a>(&'a self) -> Option<&'a ProximityAlertTriggered> {
        self.proximity_alert_triggered.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."]
    pub fn set_proximity_alert_triggered<'a>(
        &'a mut self,
        proximity_alert_triggered: Option<ProximityAlertTriggered>,
    ) -> &'a mut Self {
        self.proximity_alert_triggered =
            if let Some(proximity_alert_triggered) = proximity_alert_triggered {
                Some(proximity_alert_triggered)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    pub fn get_forum_topic_created<'a>(&'a self) -> Option<Cow<'a, ForumTopicCreated>> {
        self.forum_topic_created.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    pub fn get_forum_topic_created_ref<'a>(&'a self) -> Option<&'a ForumTopicCreated> {
        self.forum_topic_created.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic created"]
    pub fn set_forum_topic_created<'a>(
        &'a mut self,
        forum_topic_created: Option<ForumTopicCreated>,
    ) -> &'a mut Self {
        self.forum_topic_created = if let Some(forum_topic_created) = forum_topic_created {
            Some(forum_topic_created)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    pub fn get_forum_topic_edited<'a>(&'a self) -> Option<Cow<'a, ForumTopicEdited>> {
        self.forum_topic_edited.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    pub fn get_forum_topic_edited_ref<'a>(&'a self) -> Option<&'a ForumTopicEdited> {
        self.forum_topic_edited.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic edited"]
    pub fn set_forum_topic_edited<'a>(
        &'a mut self,
        forum_topic_edited: Option<ForumTopicEdited>,
    ) -> &'a mut Self {
        self.forum_topic_edited = if let Some(forum_topic_edited) = forum_topic_edited {
            Some(forum_topic_edited)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    pub fn get_forum_topic_closed<'a>(&'a self) -> Option<Cow<'a, ForumTopicClosed>> {
        self.forum_topic_closed.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    pub fn get_forum_topic_closed_ref<'a>(&'a self) -> Option<&'a ForumTopicClosed> {
        self.forum_topic_closed.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic closed"]
    pub fn set_forum_topic_closed<'a>(
        &'a mut self,
        forum_topic_closed: Option<ForumTopicClosed>,
    ) -> &'a mut Self {
        self.forum_topic_closed = if let Some(forum_topic_closed) = forum_topic_closed {
            Some(forum_topic_closed)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    pub fn get_forum_topic_reopened<'a>(&'a self) -> Option<Cow<'a, ForumTopicReopened>> {
        self.forum_topic_reopened.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    pub fn get_forum_topic_reopened_ref<'a>(&'a self) -> Option<&'a ForumTopicReopened> {
        self.forum_topic_reopened.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: forum topic reopened"]
    pub fn set_forum_topic_reopened<'a>(
        &'a mut self,
        forum_topic_reopened: Option<ForumTopicReopened>,
    ) -> &'a mut Self {
        self.forum_topic_reopened = if let Some(forum_topic_reopened) = forum_topic_reopened {
            Some(forum_topic_reopened)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    pub fn get_general_forum_topic_hidden<'a>(
        &'a self,
    ) -> Option<Cow<'a, GeneralForumTopicHidden>> {
        self.general_forum_topic_hidden
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    pub fn get_general_forum_topic_hidden_ref<'a>(&'a self) -> Option<&'a GeneralForumTopicHidden> {
        self.general_forum_topic_hidden.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic hidden"]
    pub fn set_general_forum_topic_hidden<'a>(
        &'a mut self,
        general_forum_topic_hidden: Option<GeneralForumTopicHidden>,
    ) -> &'a mut Self {
        self.general_forum_topic_hidden =
            if let Some(general_forum_topic_hidden) = general_forum_topic_hidden {
                Some(general_forum_topic_hidden)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    pub fn get_general_forum_topic_unhidden<'a>(
        &'a self,
    ) -> Option<Cow<'a, GeneralForumTopicUnhidden>> {
        self.general_forum_topic_unhidden
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    pub fn get_general_forum_topic_unhidden_ref<'a>(
        &'a self,
    ) -> Option<&'a GeneralForumTopicUnhidden> {
        self.general_forum_topic_unhidden.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: the 'General' forum topic unhidden"]
    pub fn set_general_forum_topic_unhidden<'a>(
        &'a mut self,
        general_forum_topic_unhidden: Option<GeneralForumTopicUnhidden>,
    ) -> &'a mut Self {
        self.general_forum_topic_unhidden =
            if let Some(general_forum_topic_unhidden) = general_forum_topic_unhidden {
                Some(general_forum_topic_unhidden)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    pub fn get_video_chat_scheduled<'a>(&'a self) -> Option<Cow<'a, VideoChatScheduled>> {
        self.video_chat_scheduled.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    pub fn get_video_chat_scheduled_ref<'a>(&'a self) -> Option<&'a VideoChatScheduled> {
        self.video_chat_scheduled.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat scheduled"]
    pub fn set_video_chat_scheduled<'a>(
        &'a mut self,
        video_chat_scheduled: Option<VideoChatScheduled>,
    ) -> &'a mut Self {
        self.video_chat_scheduled = if let Some(video_chat_scheduled) = video_chat_scheduled {
            Some(video_chat_scheduled)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    pub fn get_video_chat_started<'a>(&'a self) -> Option<Cow<'a, VideoChatStarted>> {
        self.video_chat_started.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    pub fn get_video_chat_started_ref<'a>(&'a self) -> Option<&'a VideoChatStarted> {
        self.video_chat_started.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat started"]
    pub fn set_video_chat_started<'a>(
        &'a mut self,
        video_chat_started: Option<VideoChatStarted>,
    ) -> &'a mut Self {
        self.video_chat_started = if let Some(video_chat_started) = video_chat_started {
            Some(video_chat_started)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    pub fn get_video_chat_ended<'a>(&'a self) -> Option<Cow<'a, VideoChatEnded>> {
        self.video_chat_ended.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    pub fn get_video_chat_ended_ref<'a>(&'a self) -> Option<&'a VideoChatEnded> {
        self.video_chat_ended.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: video chat ended"]
    pub fn set_video_chat_ended<'a>(
        &'a mut self,
        video_chat_ended: Option<VideoChatEnded>,
    ) -> &'a mut Self {
        self.video_chat_ended = if let Some(video_chat_ended) = video_chat_ended {
            Some(video_chat_ended)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    pub fn get_video_chat_participants_invited<'a>(
        &'a self,
    ) -> Option<Cow<'a, VideoChatParticipantsInvited>> {
        self.video_chat_participants_invited
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    pub fn get_video_chat_participants_invited_ref<'a>(
        &'a self,
    ) -> Option<&'a VideoChatParticipantsInvited> {
        self.video_chat_participants_invited.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: new participants invited to a video chat"]
    pub fn set_video_chat_participants_invited<'a>(
        &'a mut self,
        video_chat_participants_invited: Option<VideoChatParticipantsInvited>,
    ) -> &'a mut Self {
        self.video_chat_participants_invited =
            if let Some(video_chat_participants_invited) = video_chat_participants_invited {
                Some(video_chat_participants_invited)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    pub fn get_web_app_data<'a>(&'a self) -> Option<Cow<'a, WebAppData>> {
        self.web_app_data.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    pub fn get_web_app_data_ref<'a>(&'a self) -> Option<&'a WebAppData> {
        self.web_app_data.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Service message: data sent by a Web App"]
    pub fn set_web_app_data<'a>(&'a mut self, web_app_data: Option<WebAppData>) -> &'a mut Self {
        self.web_app_data = if let Some(web_app_data) = web_app_data {
            Some(web_app_data)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl PreCheckoutQuery {
    pub fn new(
        id: String,
        from: User,
        currency: String,
        total_amount: i64,
        invoice_payload: String,
    ) -> Self {
        Self {
            id,
            from,
            currency,
            total_amount,
            invoice_payload,
            shipping_option_id: None,
            order_info: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, from, currency, total_amount, invoice_payload, shipping_option_id, order_info)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        User,
        String,
        i64,
        String,
        Option<String>,
        Option<OrderInfo>,
    ) {
        (
            self.id,
            self.from,
            self.currency,
            self.total_amount,
            self.invoice_payload,
            self.shipping_option_id
                .map(|shipping_option_id| shipping_option_id),
            self.order_info.map(|order_info| order_info),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique query identifier"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    pub fn get_from<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.from)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    pub fn get_from_ref<'a>(&'a self) -> &'a User {
        &self.from
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User who sent the query"]
    pub fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn get_currency<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.currency.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn get_currency_ref<'a>(&'a self) -> &'a str {
        self.currency.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn set_currency<'a>(&'a mut self, currency: String) -> &'a mut Self {
        self.currency = currency;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn get_total_amount<'a>(&'a self) -> i64 {
        self.total_amount
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn get_total_amount_ref<'a>(&'a self) -> i64 {
        self.total_amount
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn set_total_amount<'a>(&'a mut self, total_amount: i64) -> &'a mut Self {
        self.total_amount = total_amount;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn get_invoice_payload<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.invoice_payload.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn get_invoice_payload_ref<'a>(&'a self) -> &'a str {
        self.invoice_payload.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn set_invoice_payload<'a>(&'a mut self, invoice_payload: String) -> &'a mut Self {
        self.invoice_payload = invoice_payload;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    pub fn get_shipping_option_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.shipping_option_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    pub fn get_shipping_option_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.shipping_option_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    pub fn set_shipping_option_id<'a>(
        &'a mut self,
        shipping_option_id: Option<String>,
    ) -> &'a mut Self {
        self.shipping_option_id = if let Some(shipping_option_id) = shipping_option_id {
            Some(shipping_option_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    pub fn get_order_info<'a>(&'a self) -> Option<Cow<'a, OrderInfo>> {
        self.order_info.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    pub fn get_order_info_ref<'a>(&'a self) -> Option<&'a OrderInfo> {
        self.order_info.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    pub fn set_order_info<'a>(&'a mut self, order_info: Option<OrderInfo>) -> &'a mut Self {
        self.order_info = if let Some(order_info) = order_info {
            Some(order_info)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ForumTopicEdited {
    pub fn new() -> Self {
        Self {
            name: None,
            icon_custom_emoji_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (name, icon_custom_emoji_id)"]
    pub fn into_tuple(self) -> (Option<String>, Option<String>) {
        (
            self.name.map(|name| name),
            self.icon_custom_emoji_id
                .map(|icon_custom_emoji_id| icon_custom_emoji_id),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New name of the topic, if it was edited"]
    pub fn get_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New name of the topic, if it was edited"]
    pub fn get_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New name of the topic, if it was edited"]
    pub fn set_name<'a>(&'a mut self, name: Option<String>) -> &'a mut Self {
        self.name = if let Some(name) = name {
            Some(name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"]
    pub fn get_icon_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.icon_custom_emoji_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"]
    pub fn get_icon_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.icon_custom_emoji_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"]
    pub fn set_icon_custom_emoji_id<'a>(
        &'a mut self,
        icon_custom_emoji_id: Option<String>,
    ) -> &'a mut Self {
        self.icon_custom_emoji_id = if let Some(icon_custom_emoji_id) = icon_custom_emoji_id {
            Some(icon_custom_emoji_id)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl File {
    pub fn new(file_id: String, file_unique_id: String) -> Self {
        Self {
            file_id,
            file_unique_id,
            file_size: None,
            file_path: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, file_size, file_path)"]
    pub fn into_tuple(self) -> (String, String, Option<i64>, Option<String>) {
        (
            self.file_id,
            self.file_unique_id,
            self.file_size.map(|file_size| file_size),
            self.file_path.map(|file_path| file_path),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id_ref<'a>(&'a self) -> &'a str {
        self.file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size_ref<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self {
        self.file_size = if let Some(file_size) = file_size {
            Some(file_size)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."]
    pub fn get_file_path<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.file_path.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."]
    pub fn get_file_path_ref<'a>(&'a self) -> Option<&'a str> {
        self.file_path.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."]
    pub fn set_file_path<'a>(&'a mut self, file_path: Option<String>) -> &'a mut Self {
        self.file_path = if let Some(file_path) = file_path {
            Some(file_path)
        } else {
            None
        };
        self
    }
}
impl TraitChatMemberOwner for ChatMemberOwner {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, is_anonymous, custom_title)"]
    fn into_tuple(self) -> (User, bool, Option<String>) {
        (
            self.user,
            self.is_anonymous,
            self.custom_title.map(|custom_title| custom_title),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn get_is_anonymous<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn get_is_anonymous_ref<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn set_is_anonymous<'a>(&'a mut self, is_anonymous: bool) -> &'a mut Self {
        self.is_anonymous = is_anonymous;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn get_custom_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.custom_title
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn get_custom_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.custom_title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn set_custom_title<'a>(&'a mut self, custom_title: Option<String>) -> &'a mut Self {
        self.custom_title = if let Some(custom_title) = custom_title {
            Some(custom_title)
        } else {
            None
        };
        self
    }
}
impl TraitChatMemberAdministrator for ChatMemberAdministrator {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, can_be_edited, is_anonymous, can_manage_chat, can_delete_messages, can_manage_video_chats, can_restrict_members, can_promote_members, can_change_info, can_invite_users, can_post_messages, can_edit_messages, can_pin_messages, can_post_stories, can_edit_stories, can_delete_stories, can_manage_topics, custom_title)"]
    fn into_tuple(
        self,
    ) -> (
        User,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<String>,
    ) {
        (
            self.user,
            self.can_be_edited,
            self.is_anonymous,
            self.can_manage_chat,
            self.can_delete_messages,
            self.can_manage_video_chats,
            self.can_restrict_members,
            self.can_promote_members,
            self.can_change_info,
            self.can_invite_users,
            self.can_post_messages
                .map(|can_post_messages| can_post_messages),
            self.can_edit_messages
                .map(|can_edit_messages| can_edit_messages),
            self.can_pin_messages
                .map(|can_pin_messages| can_pin_messages),
            self.can_post_stories
                .map(|can_post_stories| can_post_stories),
            self.can_edit_stories
                .map(|can_edit_stories| can_edit_stories),
            self.can_delete_stories
                .map(|can_delete_stories| can_delete_stories),
            self.can_manage_topics
                .map(|can_manage_topics| can_manage_topics),
            self.custom_title.map(|custom_title| custom_title),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    fn get_can_be_edited<'a>(&'a self) -> bool {
        self.can_be_edited
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    fn get_can_be_edited_ref<'a>(&'a self) -> bool {
        self.can_be_edited
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the bot is allowed to edit administrator privileges of that user"]
    fn set_can_be_edited<'a>(&'a mut self, can_be_edited: bool) -> &'a mut Self {
        self.can_be_edited = can_be_edited;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn get_is_anonymous<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn get_is_anonymous_ref<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    fn set_is_anonymous<'a>(&'a mut self, is_anonymous: bool) -> &'a mut Self {
        self.is_anonymous = is_anonymous;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    fn get_can_manage_chat<'a>(&'a self) -> bool {
        self.can_manage_chat
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    fn get_can_manage_chat_ref<'a>(&'a self) -> bool {
        self.can_manage_chat
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    fn set_can_manage_chat<'a>(&'a mut self, can_manage_chat: bool) -> &'a mut Self {
        self.can_manage_chat = can_manage_chat;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    fn get_can_delete_messages<'a>(&'a self) -> bool {
        self.can_delete_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    fn get_can_delete_messages_ref<'a>(&'a self) -> bool {
        self.can_delete_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    fn set_can_delete_messages<'a>(&'a mut self, can_delete_messages: bool) -> &'a mut Self {
        self.can_delete_messages = can_delete_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    fn get_can_manage_video_chats<'a>(&'a self) -> bool {
        self.can_manage_video_chats
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    fn get_can_manage_video_chats_ref<'a>(&'a self) -> bool {
        self.can_manage_video_chats
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    fn set_can_manage_video_chats<'a>(&'a mut self, can_manage_video_chats: bool) -> &'a mut Self {
        self.can_manage_video_chats = can_manage_video_chats;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    fn get_can_restrict_members<'a>(&'a self) -> bool {
        self.can_restrict_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    fn get_can_restrict_members_ref<'a>(&'a self) -> bool {
        self.can_restrict_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    fn set_can_restrict_members<'a>(&'a mut self, can_restrict_members: bool) -> &'a mut Self {
        self.can_restrict_members = can_restrict_members;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    fn get_can_promote_members<'a>(&'a self) -> bool {
        self.can_promote_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    fn get_can_promote_members_ref<'a>(&'a self) -> bool {
        self.can_promote_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    fn set_can_promote_members<'a>(&'a mut self, can_promote_members: bool) -> &'a mut Self {
        self.can_promote_members = can_promote_members;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn get_can_change_info<'a>(&'a self) -> bool {
        self.can_change_info
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn get_can_change_info_ref<'a>(&'a self) -> bool {
        self.can_change_info
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn set_can_change_info<'a>(&'a mut self, can_change_info: bool) -> &'a mut Self {
        self.can_change_info = can_change_info;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users<'a>(&'a self) -> bool {
        self.can_invite_users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users_ref<'a>(&'a self) -> bool {
        self.can_invite_users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn set_can_invite_users<'a>(&'a mut self, can_invite_users: bool) -> &'a mut Self {
        self.can_invite_users = can_invite_users;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    fn get_can_post_messages<'a>(&'a self) -> Option<bool> {
        self.can_post_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    fn get_can_post_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_post_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    fn set_can_post_messages<'a>(&'a mut self, can_post_messages: Option<bool>) -> &'a mut Self {
        self.can_post_messages = if let Some(can_post_messages) = can_post_messages {
            Some(can_post_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    fn get_can_edit_messages<'a>(&'a self) -> Option<bool> {
        self.can_edit_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    fn get_can_edit_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_edit_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    fn set_can_edit_messages<'a>(&'a mut self, can_edit_messages: Option<bool>) -> &'a mut Self {
        self.can_edit_messages = if let Some(can_edit_messages) = can_edit_messages {
            Some(can_edit_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    fn get_can_pin_messages<'a>(&'a self) -> Option<bool> {
        self.can_pin_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    fn get_can_pin_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_pin_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    fn set_can_pin_messages<'a>(&'a mut self, can_pin_messages: Option<bool>) -> &'a mut Self {
        self.can_pin_messages = if let Some(can_pin_messages) = can_pin_messages {
            Some(can_pin_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    fn get_can_post_stories<'a>(&'a self) -> Option<bool> {
        self.can_post_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    fn get_can_post_stories_ref<'a>(&'a self) -> Option<bool> {
        self.can_post_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    fn set_can_post_stories<'a>(&'a mut self, can_post_stories: Option<bool>) -> &'a mut Self {
        self.can_post_stories = if let Some(can_post_stories) = can_post_stories {
            Some(can_post_stories)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    fn get_can_edit_stories<'a>(&'a self) -> Option<bool> {
        self.can_edit_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    fn get_can_edit_stories_ref<'a>(&'a self) -> Option<bool> {
        self.can_edit_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    fn set_can_edit_stories<'a>(&'a mut self, can_edit_stories: Option<bool>) -> &'a mut Self {
        self.can_edit_stories = if let Some(can_edit_stories) = can_edit_stories {
            Some(can_edit_stories)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    fn get_can_delete_stories<'a>(&'a self) -> Option<bool> {
        self.can_delete_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    fn get_can_delete_stories_ref<'a>(&'a self) -> Option<bool> {
        self.can_delete_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    fn set_can_delete_stories<'a>(&'a mut self, can_delete_stories: Option<bool>) -> &'a mut Self {
        self.can_delete_stories = if let Some(can_delete_stories) = can_delete_stories {
            Some(can_delete_stories)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    fn get_can_manage_topics<'a>(&'a self) -> Option<bool> {
        self.can_manage_topics.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    fn get_can_manage_topics_ref<'a>(&'a self) -> Option<bool> {
        self.can_manage_topics.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    fn set_can_manage_topics<'a>(&'a mut self, can_manage_topics: Option<bool>) -> &'a mut Self {
        self.can_manage_topics = if let Some(can_manage_topics) = can_manage_topics {
            Some(can_manage_topics)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn get_custom_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.custom_title
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn get_custom_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.custom_title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    fn set_custom_title<'a>(&'a mut self, custom_title: Option<String>) -> &'a mut Self {
        self.custom_title = if let Some(custom_title) = custom_title {
            Some(custom_title)
        } else {
            None
        };
        self
    }
}
impl TraitChatMemberMember for ChatMemberMember {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user)"]
    fn into_tuple(self) -> User {
        self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
}
impl TraitChatMemberRestricted for ChatMemberRestricted {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, is_member, can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, can_send_voice_notes, can_send_polls, can_send_other_messages, can_add_web_page_previews, can_change_info, can_invite_users, can_pin_messages, can_manage_topics, until_date)"]
    fn into_tuple(
        self,
    ) -> (
        User,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        i64,
    ) {
        (
            self.user,
            self.is_member,
            self.can_send_messages,
            self.can_send_audios,
            self.can_send_documents,
            self.can_send_photos,
            self.can_send_videos,
            self.can_send_video_notes,
            self.can_send_voice_notes,
            self.can_send_polls,
            self.can_send_other_messages,
            self.can_add_web_page_previews,
            self.can_change_info,
            self.can_invite_users,
            self.can_pin_messages,
            self.can_manage_topics,
            self.until_date,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    fn get_is_member<'a>(&'a self) -> bool {
        self.is_member
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    fn get_is_member_ref<'a>(&'a self) -> bool {
        self.is_member
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    fn set_is_member<'a>(&'a mut self, is_member: bool) -> &'a mut Self {
        self.is_member = is_member;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    fn get_can_send_messages<'a>(&'a self) -> bool {
        self.can_send_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    fn get_can_send_messages_ref<'a>(&'a self) -> bool {
        self.can_send_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    fn set_can_send_messages<'a>(&'a mut self, can_send_messages: bool) -> &'a mut Self {
        self.can_send_messages = can_send_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    fn get_can_send_audios<'a>(&'a self) -> bool {
        self.can_send_audios
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    fn get_can_send_audios_ref<'a>(&'a self) -> bool {
        self.can_send_audios
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    fn set_can_send_audios<'a>(&'a mut self, can_send_audios: bool) -> &'a mut Self {
        self.can_send_audios = can_send_audios;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    fn get_can_send_documents<'a>(&'a self) -> bool {
        self.can_send_documents
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    fn get_can_send_documents_ref<'a>(&'a self) -> bool {
        self.can_send_documents
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    fn set_can_send_documents<'a>(&'a mut self, can_send_documents: bool) -> &'a mut Self {
        self.can_send_documents = can_send_documents;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    fn get_can_send_photos<'a>(&'a self) -> bool {
        self.can_send_photos
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    fn get_can_send_photos_ref<'a>(&'a self) -> bool {
        self.can_send_photos
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    fn set_can_send_photos<'a>(&'a mut self, can_send_photos: bool) -> &'a mut Self {
        self.can_send_photos = can_send_photos;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    fn get_can_send_videos<'a>(&'a self) -> bool {
        self.can_send_videos
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    fn get_can_send_videos_ref<'a>(&'a self) -> bool {
        self.can_send_videos
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    fn set_can_send_videos<'a>(&'a mut self, can_send_videos: bool) -> &'a mut Self {
        self.can_send_videos = can_send_videos;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    fn get_can_send_video_notes<'a>(&'a self) -> bool {
        self.can_send_video_notes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    fn get_can_send_video_notes_ref<'a>(&'a self) -> bool {
        self.can_send_video_notes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    fn set_can_send_video_notes<'a>(&'a mut self, can_send_video_notes: bool) -> &'a mut Self {
        self.can_send_video_notes = can_send_video_notes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    fn get_can_send_voice_notes<'a>(&'a self) -> bool {
        self.can_send_voice_notes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    fn get_can_send_voice_notes_ref<'a>(&'a self) -> bool {
        self.can_send_voice_notes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    fn set_can_send_voice_notes<'a>(&'a mut self, can_send_voice_notes: bool) -> &'a mut Self {
        self.can_send_voice_notes = can_send_voice_notes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    fn get_can_send_polls<'a>(&'a self) -> bool {
        self.can_send_polls
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    fn get_can_send_polls_ref<'a>(&'a self) -> bool {
        self.can_send_polls
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    fn set_can_send_polls<'a>(&'a mut self, can_send_polls: bool) -> &'a mut Self {
        self.can_send_polls = can_send_polls;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    fn get_can_send_other_messages<'a>(&'a self) -> bool {
        self.can_send_other_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    fn get_can_send_other_messages_ref<'a>(&'a self) -> bool {
        self.can_send_other_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    fn set_can_send_other_messages<'a>(
        &'a mut self,
        can_send_other_messages: bool,
    ) -> &'a mut Self {
        self.can_send_other_messages = can_send_other_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    fn get_can_add_web_page_previews<'a>(&'a self) -> bool {
        self.can_add_web_page_previews
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    fn get_can_add_web_page_previews_ref<'a>(&'a self) -> bool {
        self.can_add_web_page_previews
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    fn set_can_add_web_page_previews<'a>(
        &'a mut self,
        can_add_web_page_previews: bool,
    ) -> &'a mut Self {
        self.can_add_web_page_previews = can_add_web_page_previews;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn get_can_change_info<'a>(&'a self) -> bool {
        self.can_change_info
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn get_can_change_info_ref<'a>(&'a self) -> bool {
        self.can_change_info
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    fn set_can_change_info<'a>(&'a mut self, can_change_info: bool) -> &'a mut Self {
        self.can_change_info = can_change_info;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users<'a>(&'a self) -> bool {
        self.can_invite_users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn get_can_invite_users_ref<'a>(&'a self) -> bool {
        self.can_invite_users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    fn set_can_invite_users<'a>(&'a mut self, can_invite_users: bool) -> &'a mut Self {
        self.can_invite_users = can_invite_users;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    fn get_can_pin_messages<'a>(&'a self) -> bool {
        self.can_pin_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    fn get_can_pin_messages_ref<'a>(&'a self) -> bool {
        self.can_pin_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    fn set_can_pin_messages<'a>(&'a mut self, can_pin_messages: bool) -> &'a mut Self {
        self.can_pin_messages = can_pin_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    fn get_can_manage_topics<'a>(&'a self) -> bool {
        self.can_manage_topics
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    fn get_can_manage_topics_ref<'a>(&'a self) -> bool {
        self.can_manage_topics
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    fn set_can_manage_topics<'a>(&'a mut self, can_manage_topics: bool) -> &'a mut Self {
        self.can_manage_topics = can_manage_topics;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    fn get_until_date<'a>(&'a self) -> i64 {
        self.until_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    fn get_until_date_ref<'a>(&'a self) -> i64 {
        self.until_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    fn set_until_date<'a>(&'a mut self, until_date: i64) -> &'a mut Self {
        self.until_date = until_date;
        self
    }
}
impl TraitChatMemberLeft for ChatMemberLeft {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user)"]
    fn into_tuple(self) -> User {
        self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
}
impl TraitChatMemberBanned for ChatMemberBanned {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, until_date)"]
    fn into_tuple(self) -> (User, i64) {
        (self.user, self.until_date)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    fn get_until_date<'a>(&'a self) -> i64 {
        self.until_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    fn get_until_date_ref<'a>(&'a self) -> i64 {
        self.until_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    fn set_until_date<'a>(&'a mut self, until_date: i64) -> &'a mut Self {
        self.until_date = until_date;
        self
    }
}
#[allow(dead_code)]
impl Poll {
    pub fn new(
        id: String,
        question: String,
        options: Vec<PollOption>,
        total_voter_count: i64,
        is_closed: bool,
        is_anonymous: bool,
        allows_multiple_answers: bool,
    ) -> Self {
        Self {
            tg_type: "Poll".to_owned(),
            id,
            question,
            options,
            total_voter_count,
            is_closed,
            is_anonymous,
            allows_multiple_answers,
            correct_option_id: None,
            explanation: None,
            explanation_entities: None,
            open_period: None,
            close_date: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, question, options, total_voter_count, is_closed, is_anonymous, type, allows_multiple_answers, correct_option_id, explanation, explanation_entities, open_period, close_date)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        Vec<PollOption>,
        i64,
        bool,
        bool,
        String,
        bool,
        Option<i64>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.id,
            self.question,
            self.options,
            self.total_voter_count,
            self.is_closed,
            self.is_anonymous,
            self.tg_type,
            self.allows_multiple_answers,
            self.correct_option_id
                .map(|correct_option_id| correct_option_id),
            self.explanation.map(|explanation| explanation),
            self.explanation_entities
                .map(|explanation_entities| explanation_entities),
            self.open_period.map(|open_period| open_period),
            self.close_date.map(|close_date| close_date),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    pub fn get_question<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.question.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    pub fn get_question_ref<'a>(&'a self) -> &'a str {
        self.question.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll question, 1-300 characters"]
    pub fn set_question<'a>(&'a mut self, question: String) -> &'a mut Self {
        self.question = question;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    pub fn get_options<'a>(&'a self) -> Cow<'a, Vec<PollOption>> {
        Cow::Borrowed(&self.options)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    pub fn get_options_ref<'a>(&'a self) -> &'a Vec<PollOption> {
        &self.options
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of poll options"]
    pub fn set_options<'a>(&'a mut self, options: Vec<PollOption>) -> &'a mut Self {
        self.options = options;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    pub fn get_total_voter_count<'a>(&'a self) -> i64 {
        self.total_voter_count
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    pub fn get_total_voter_count_ref<'a>(&'a self) -> i64 {
        self.total_voter_count
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total number of users that voted in the poll"]
    pub fn set_total_voter_count<'a>(&'a mut self, total_voter_count: i64) -> &'a mut Self {
        self.total_voter_count = total_voter_count;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    pub fn get_is_closed<'a>(&'a self) -> bool {
        self.is_closed
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    pub fn get_is_closed_ref<'a>(&'a self) -> bool {
        self.is_closed
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is closed"]
    pub fn set_is_closed<'a>(&'a mut self, is_closed: bool) -> &'a mut Self {
        self.is_closed = is_closed;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    pub fn get_is_anonymous<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    pub fn get_is_anonymous_ref<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll is anonymous"]
    pub fn set_is_anonymous<'a>(&'a mut self, is_anonymous: bool) -> &'a mut Self {
        self.is_anonymous = is_anonymous;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Poll type, currently can be \"regular\" or \"quiz\""]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    pub fn get_allows_multiple_answers<'a>(&'a self) -> bool {
        self.allows_multiple_answers
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    pub fn get_allows_multiple_answers_ref<'a>(&'a self) -> bool {
        self.allows_multiple_answers
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the poll allows multiple answers"]
    pub fn set_allows_multiple_answers<'a>(
        &'a mut self,
        allows_multiple_answers: bool,
    ) -> &'a mut Self {
        self.allows_multiple_answers = allows_multiple_answers;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    pub fn get_correct_option_id<'a>(&'a self) -> Option<i64> {
        self.correct_option_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    pub fn get_correct_option_id_ref<'a>(&'a self) -> Option<i64> {
        self.correct_option_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."]
    pub fn set_correct_option_id<'a>(&'a mut self, correct_option_id: Option<i64>) -> &'a mut Self {
        self.correct_option_id = if let Some(correct_option_id) = correct_option_id {
            Some(correct_option_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    pub fn get_explanation<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.explanation.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    pub fn get_explanation_ref<'a>(&'a self) -> Option<&'a str> {
        self.explanation.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"]
    pub fn set_explanation<'a>(&'a mut self, explanation: Option<String>) -> &'a mut Self {
        self.explanation = if let Some(explanation) = explanation {
            Some(explanation)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    pub fn get_explanation_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.explanation_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    pub fn get_explanation_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.explanation_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"]
    pub fn set_explanation_entities<'a>(
        &'a mut self,
        explanation_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.explanation_entities = if let Some(explanation_entities) = explanation_entities {
            Some(explanation_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    pub fn get_open_period<'a>(&'a self) -> Option<i64> {
        self.open_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    pub fn get_open_period_ref<'a>(&'a self) -> Option<i64> {
        self.open_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Amount of time in seconds the poll will be active after creation"]
    pub fn set_open_period<'a>(&'a mut self, open_period: Option<i64>) -> &'a mut Self {
        self.open_period = if let Some(open_period) = open_period {
            Some(open_period)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    pub fn get_close_date<'a>(&'a self) -> Option<i64> {
        self.close_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    pub fn get_close_date_ref<'a>(&'a self) -> Option<i64> {
        self.close_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"]
    pub fn set_close_date<'a>(&'a mut self, close_date: Option<i64>) -> &'a mut Self {
        self.close_date = if let Some(close_date) = close_date {
            Some(close_date)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultCachedVoice {
    pub fn new(id: String, voice_file_id: String, title: String) -> Self {
        Self {
            tg_type: "voice".to_owned(),
            id,
            voice_file_id,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, voice_file_id, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.voice_file_id,
            self.title,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    pub fn get_voice_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.voice_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    pub fn get_voice_file_id_ref<'a>(&'a self) -> &'a str {
        self.voice_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    pub fn set_voice_file_id<'a>(&'a mut self, voice_file_id: String) -> &'a mut Self {
        self.voice_file_id = voice_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl SuccessfulPayment {
    pub fn new(
        currency: String,
        total_amount: i64,
        invoice_payload: String,
        telegram_payment_charge_id: String,
        provider_payment_charge_id: String,
    ) -> Self {
        Self {
            currency,
            total_amount,
            invoice_payload,
            telegram_payment_charge_id,
            provider_payment_charge_id,
            shipping_option_id: None,
            order_info: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (currency, total_amount, invoice_payload, shipping_option_id, order_info, telegram_payment_charge_id, provider_payment_charge_id)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        i64,
        String,
        Option<String>,
        Option<OrderInfo>,
        String,
        String,
    ) {
        (
            self.currency,
            self.total_amount,
            self.invoice_payload,
            self.shipping_option_id
                .map(|shipping_option_id| shipping_option_id),
            self.order_info.map(|order_info| (*order_info)),
            self.telegram_payment_charge_id,
            self.provider_payment_charge_id,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn get_currency<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.currency.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn get_currency_ref<'a>(&'a self) -> &'a str {
        self.currency.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn set_currency<'a>(&'a mut self, currency: String) -> &'a mut Self {
        self.currency = currency;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn get_total_amount<'a>(&'a self) -> i64 {
        self.total_amount
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn get_total_amount_ref<'a>(&'a self) -> i64 {
        self.total_amount
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn set_total_amount<'a>(&'a mut self, total_amount: i64) -> &'a mut Self {
        self.total_amount = total_amount;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn get_invoice_payload<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.invoice_payload.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn get_invoice_payload_ref<'a>(&'a self) -> &'a str {
        self.invoice_payload.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot specified invoice payload"]
    pub fn set_invoice_payload<'a>(&'a mut self, invoice_payload: String) -> &'a mut Self {
        self.invoice_payload = invoice_payload;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    pub fn get_shipping_option_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.shipping_option_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    pub fn get_shipping_option_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.shipping_option_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the shipping option chosen by the user"]
    pub fn set_shipping_option_id<'a>(
        &'a mut self,
        shipping_option_id: Option<String>,
    ) -> &'a mut Self {
        self.shipping_option_id = if let Some(shipping_option_id) = shipping_option_id {
            Some(shipping_option_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    pub fn get_order_info<'a>(&'a self) -> Option<Cow<'a, OrderInfo>> {
        self.order_info.as_ref().map(|v| Cow::Borrowed(v.as_ref()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    pub fn get_order_info_ref<'a>(&'a self) -> Option<&'a OrderInfo> {
        self.order_info.as_ref().map(|v| v.as_ref())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Order information provided by the user"]
    pub fn set_order_info<'a>(&'a mut self, order_info: Option<OrderInfo>) -> &'a mut Self {
        self.order_info = if let Some(order_info) = order_info {
            Some(Box::new(order_info))
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Telegram payment identifier"]
    pub fn get_telegram_payment_charge_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.telegram_payment_charge_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Telegram payment identifier"]
    pub fn get_telegram_payment_charge_id_ref<'a>(&'a self) -> &'a str {
        self.telegram_payment_charge_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Telegram payment identifier"]
    pub fn set_telegram_payment_charge_id<'a>(
        &'a mut self,
        telegram_payment_charge_id: String,
    ) -> &'a mut Self {
        self.telegram_payment_charge_id = telegram_payment_charge_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Provider payment identifier"]
    pub fn get_provider_payment_charge_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.provider_payment_charge_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Provider payment identifier"]
    pub fn get_provider_payment_charge_id_ref<'a>(&'a self) -> &'a str {
        self.provider_payment_charge_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Provider payment identifier"]
    pub fn set_provider_payment_charge_id<'a>(
        &'a mut self,
        provider_payment_charge_id: String,
    ) -> &'a mut Self {
        self.provider_payment_charge_id = provider_payment_charge_id;
        self
    }
}
#[allow(dead_code)]
impl InputMediaDocument {
    pub fn new(media: Option<InputFile>) -> Self {
        Self {
            tg_type: "document".to_owned(),
            media,
            thumbnail: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            disable_content_type_detection: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, disable_content_type_detection)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
    ) {
        (
            self.tg_type,
            self.media,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.disable_content_type_detection
                .map(|disable_content_type_detection| disable_content_type_detection),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>> {
        Cow::Borrowed(&self.media)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_media_ref<'a>(&'a self) -> &'a Option<InputFile> {
        &self.media
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a InputFile> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    pub fn get_disable_content_type_detection<'a>(&'a self) -> Option<bool> {
        self.disable_content_type_detection.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    pub fn get_disable_content_type_detection_ref<'a>(&'a self) -> Option<bool> {
        self.disable_content_type_detection.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."]
    pub fn set_disable_content_type_detection<'a>(
        &'a mut self,
        disable_content_type_detection: Option<bool>,
    ) -> &'a mut Self {
        self.disable_content_type_detection =
            if let Some(disable_content_type_detection) = disable_content_type_detection {
                Some(disable_content_type_detection)
            } else {
                None
            };
        self
    }
    fn to_form(self, data: Form) -> Result<(Form, String)> {
        match self.media {
            Some(InputFile::Bytes(FileBytes {
                name,
                bytes: Some(bytes),
            })) => {
                let attach = format!("attach://{}", name);
                let form = data.part(name, Part::bytes(bytes));
                Ok((form, attach))
            }
            Some(InputFile::String(name)) => Ok((data, name)),
            _ => Err(anyhow!("cry")),
        }
    }
}
#[allow(dead_code)]
impl Location {
    pub fn new(
        longitude: ::ordered_float::OrderedFloat<f64>,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> Self {
        Self {
            longitude,
            latitude,
            horizontal_accuracy: None,
            live_period: None,
            heading: None,
            proximity_alert_radius: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (longitude, latitude, horizontal_accuracy, live_period, heading, proximity_alert_radius)"]
    pub fn into_tuple(
        self,
    ) -> (
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        Option<::ordered_float::OrderedFloat<f64>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.longitude,
            self.latitude,
            self.horizontal_accuracy
                .map(|horizontal_accuracy| horizontal_accuracy),
            self.live_period.map(|live_period| live_period),
            self.heading.map(|heading| heading),
            self.proximity_alert_radius
                .map(|proximity_alert_radius| proximity_alert_radius),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude as defined by sender"]
    pub fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude as defined by sender"]
    pub fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude as defined by sender"]
    pub fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude as defined by sender"]
    pub fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude as defined by sender"]
    pub fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude as defined by sender"]
    pub fn set_latitude<'a>(
        &'a mut self,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn get_horizontal_accuracy<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>> {
        self.horizontal_accuracy.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn get_horizontal_accuracy_ref<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>> {
        self.horizontal_accuracy.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn set_horizontal_accuracy<'a>(
        &'a mut self,
        horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    ) -> &'a mut Self {
        self.horizontal_accuracy = if let Some(horizontal_accuracy) = horizontal_accuracy {
            Some(horizontal_accuracy)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."]
    pub fn get_live_period<'a>(&'a self) -> Option<i64> {
        self.live_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."]
    pub fn get_live_period_ref<'a>(&'a self) -> Option<i64> {
        self.live_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."]
    pub fn set_live_period<'a>(&'a mut self, live_period: Option<i64>) -> &'a mut Self {
        self.live_period = if let Some(live_period) = live_period {
            Some(live_period)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."]
    pub fn get_heading<'a>(&'a self) -> Option<i64> {
        self.heading.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."]
    pub fn get_heading_ref<'a>(&'a self) -> Option<i64> {
        self.heading.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."]
    pub fn set_heading<'a>(&'a mut self, heading: Option<i64>) -> &'a mut Self {
        self.heading = if let Some(heading) = heading {
            Some(heading)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."]
    pub fn get_proximity_alert_radius<'a>(&'a self) -> Option<i64> {
        self.proximity_alert_radius.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."]
    pub fn get_proximity_alert_radius_ref<'a>(&'a self) -> Option<i64> {
        self.proximity_alert_radius.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."]
    pub fn set_proximity_alert_radius<'a>(
        &'a mut self,
        proximity_alert_radius: Option<i64>,
    ) -> &'a mut Self {
        self.proximity_alert_radius = if let Some(proximity_alert_radius) = proximity_alert_radius {
            Some(proximity_alert_radius)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl KeyboardButton {
    pub fn new(text: String) -> Self {
        Self {
            text,
            request_user: None,
            request_chat: None,
            request_contact: None,
            request_location: None,
            request_poll: None,
            web_app: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (text, request_user, request_chat, request_contact, request_location, request_poll, web_app)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        Option<KeyboardButtonRequestUser>,
        Option<KeyboardButtonRequestChat>,
        Option<bool>,
        Option<bool>,
        Option<KeyboardButtonPollType>,
        Option<WebAppInfo>,
    ) {
        (
            self.text,
            self.request_user.map(|request_user| request_user),
            self.request_chat.map(|request_chat| request_chat),
            self.request_contact.map(|request_contact| request_contact),
            self.request_location
                .map(|request_location| request_location),
            self.request_poll.map(|request_poll| request_poll),
            self.web_app.map(|web_app| web_app),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"]
    pub fn get_text<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.text.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"]
    pub fn get_text_ref<'a>(&'a self) -> &'a str {
        self.text.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"]
    pub fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a \"user_shared\" service message. Available in private chats only."]
    pub fn get_request_user<'a>(&'a self) -> Option<Cow<'a, KeyboardButtonRequestUser>> {
        self.request_user.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a \"user_shared\" service message. Available in private chats only."]
    pub fn get_request_user_ref<'a>(&'a self) -> Option<&'a KeyboardButtonRequestUser> {
        self.request_user.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a \"user_shared\" service message. Available in private chats only."]
    pub fn set_request_user<'a>(
        &'a mut self,
        request_user: Option<KeyboardButtonRequestUser>,
    ) -> &'a mut Self {
        self.request_user = if let Some(request_user) = request_user {
            Some(request_user)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a \"chat_shared\" service message. Available in private chats only."]
    pub fn get_request_chat<'a>(&'a self) -> Option<Cow<'a, KeyboardButtonRequestChat>> {
        self.request_chat.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a \"chat_shared\" service message. Available in private chats only."]
    pub fn get_request_chat_ref<'a>(&'a self) -> Option<&'a KeyboardButtonRequestChat> {
        self.request_chat.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a \"chat_shared\" service message. Available in private chats only."]
    pub fn set_request_chat<'a>(
        &'a mut self,
        request_chat: Option<KeyboardButtonRequestChat>,
    ) -> &'a mut Self {
        self.request_chat = if let Some(request_chat) = request_chat {
            Some(request_chat)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."]
    pub fn get_request_contact<'a>(&'a self) -> Option<bool> {
        self.request_contact.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."]
    pub fn get_request_contact_ref<'a>(&'a self) -> Option<bool> {
        self.request_contact.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."]
    pub fn set_request_contact<'a>(&'a mut self, request_contact: Option<bool>) -> &'a mut Self {
        self.request_contact = if let Some(request_contact) = request_contact {
            Some(request_contact)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."]
    pub fn get_request_location<'a>(&'a self) -> Option<bool> {
        self.request_location.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."]
    pub fn get_request_location_ref<'a>(&'a self) -> Option<bool> {
        self.request_location.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."]
    pub fn set_request_location<'a>(&'a mut self, request_location: Option<bool>) -> &'a mut Self {
        self.request_location = if let Some(request_location) = request_location {
            Some(request_location)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."]
    pub fn get_request_poll<'a>(&'a self) -> Option<Cow<'a, KeyboardButtonPollType>> {
        self.request_poll.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."]
    pub fn get_request_poll_ref<'a>(&'a self) -> Option<&'a KeyboardButtonPollType> {
        self.request_poll.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."]
    pub fn set_request_poll<'a>(
        &'a mut self,
        request_poll: Option<KeyboardButtonPollType>,
    ) -> &'a mut Self {
        self.request_poll = if let Some(request_poll) = request_poll {
            Some(request_poll)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a \"web_app_data\" service message. Available in private chats only."]
    pub fn get_web_app<'a>(&'a self) -> Option<Cow<'a, WebAppInfo>> {
        self.web_app.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a \"web_app_data\" service message. Available in private chats only."]
    pub fn get_web_app_ref<'a>(&'a self) -> Option<&'a WebAppInfo> {
        self.web_app.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a \"web_app_data\" service message. Available in private chats only."]
    pub fn set_web_app<'a>(&'a mut self, web_app: Option<WebAppInfo>) -> &'a mut Self {
        self.web_app = if let Some(web_app) = web_app {
            Some(web_app)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatMemberLeft {
    pub fn new(user: User) -> Self {
        Self { user }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user)"]
    pub fn into_tuple(self) -> User {
        self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
}
#[allow(dead_code)]
impl BotCommand {
    pub fn new(command: String, description: String) -> Self {
        Self {
            command,
            description,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (command, description)"]
    pub fn into_tuple(self) -> (String, String) {
        (self.command, self.description)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."]
    pub fn get_command<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.command.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."]
    pub fn get_command_ref<'a>(&'a self) -> &'a str {
        self.command.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."]
    pub fn set_command<'a>(&'a mut self, command: String) -> &'a mut Self {
        self.command = command;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the command; 1-256 characters."]
    pub fn get_description<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.description.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the command; 1-256 characters."]
    pub fn get_description_ref<'a>(&'a self) -> &'a str {
        self.description.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the command; 1-256 characters."]
    pub fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self {
        self.description = description;
        self
    }
}
#[allow(dead_code)]
impl Venue {
    pub fn new(location: Location, title: String, address: String) -> Self {
        Self {
            location,
            title,
            address,
            foursquare_id: None,
            foursquare_type: None,
            google_place_id: None,
            google_place_type: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (location, title, address, foursquare_id, foursquare_type, google_place_id, google_place_type)"]
    pub fn into_tuple(
        self,
    ) -> (
        Location,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
    ) {
        (
            self.location,
            self.title,
            self.address,
            self.foursquare_id.map(|foursquare_id| foursquare_id),
            self.foursquare_type.map(|foursquare_type| foursquare_type),
            self.google_place_id.map(|google_place_id| google_place_id),
            self.google_place_type
                .map(|google_place_type| google_place_type),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Venue location. Can't be a live location"]
    pub fn get_location<'a>(&'a self) -> Cow<'a, Location> {
        Cow::Borrowed(&self.location)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Venue location. Can't be a live location"]
    pub fn get_location_ref<'a>(&'a self) -> &'a Location {
        &self.location
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Venue location. Can't be a live location"]
    pub fn set_location<'a>(&'a mut self, location: Location) -> &'a mut Self {
        self.location = location;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn get_address<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.address.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn get_address_ref<'a>(&'a self) -> &'a str {
        self.address.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn set_address<'a>(&'a mut self, address: String) -> &'a mut Self {
        self.address = address;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue"]
    pub fn get_foursquare_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.foursquare_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue"]
    pub fn get_foursquare_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.foursquare_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue"]
    pub fn set_foursquare_id<'a>(&'a mut self, foursquare_id: Option<String>) -> &'a mut Self {
        self.foursquare_id = if let Some(foursquare_id) = foursquare_id {
            Some(foursquare_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn get_foursquare_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.foursquare_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn get_foursquare_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.foursquare_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn set_foursquare_type<'a>(&'a mut self, foursquare_type: Option<String>) -> &'a mut Self {
        self.foursquare_type = if let Some(foursquare_type) = foursquare_type {
            Some(foursquare_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn get_google_place_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.google_place_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn get_google_place_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.google_place_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn set_google_place_id<'a>(&'a mut self, google_place_id: Option<String>) -> &'a mut Self {
        self.google_place_id = if let Some(google_place_id) = google_place_id {
            Some(google_place_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn get_google_place_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.google_place_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn get_google_place_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.google_place_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn set_google_place_type<'a>(
        &'a mut self,
        google_place_type: Option<String>,
    ) -> &'a mut Self {
        self.google_place_type = if let Some(google_place_type) = google_place_type {
            Some(google_place_type)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl PassportElementErrorSelfie {
    pub fn new(source: String, file_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorSelfie".to_owned(),
            source,
            file_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    pub fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.file_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    pub fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    pub fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    pub fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    pub fn get_file_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    pub fn get_file_hash_ref<'a>(&'a self) -> &'a str {
        self.file_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    pub fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
#[allow(dead_code)]
impl ForumTopicClosed {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    pub fn into_tuple(self) {
        ()
    }
}
#[allow(dead_code)]
impl VideoNote {
    pub fn new(file_id: String, file_unique_id: String, length: i64, duration: i64) -> Self {
        Self {
            file_id,
            file_unique_id,
            length,
            duration,
            thumbnail: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, length, duration, thumbnail, file_size)"]
    pub fn into_tuple(self) -> (String, String, i64, i64, Option<PhotoSize>, Option<i64>) {
        (
            self.file_id,
            self.file_unique_id,
            self.length,
            self.duration,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.file_size.map(|file_size| file_size),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id_ref<'a>(&'a self) -> &'a str {
        self.file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width and height (diameter of the video message) as defined by sender"]
    pub fn get_length<'a>(&'a self) -> i64 {
        self.length
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width and height (diameter of the video message) as defined by sender"]
    pub fn get_length_ref<'a>(&'a self) -> i64 {
        self.length
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width and height (diameter of the video message) as defined by sender"]
    pub fn set_length<'a>(&'a mut self, length: i64) -> &'a mut Self {
        self.length = length;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn get_duration<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn get_duration_ref<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self {
        self.duration = duration;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a PhotoSize> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn get_file_size<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn get_file_size_ref<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self {
        self.file_size = if let Some(file_size) = file_size {
            Some(file_size)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InlineKeyboardMarkup {
    pub fn new(inline_keyboard: Vec<Vec<InlineKeyboardButton>>) -> Self {
        Self { inline_keyboard }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (inline_keyboard)"]
    pub fn into_tuple(self) -> Vec<Vec<InlineKeyboardButton>> {
        self.inline_keyboard
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of InlineKeyboardButton objects"]
    pub fn get_inline_keyboard<'a>(&'a self) -> Cow<'a, Vec<Vec<InlineKeyboardButton>>> {
        Cow::Borrowed(&self.inline_keyboard)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of InlineKeyboardButton objects"]
    pub fn get_inline_keyboard_ref<'a>(&'a self) -> &'a Vec<Vec<InlineKeyboardButton>> {
        &self.inline_keyboard
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array of button rows, each represented by an Array of InlineKeyboardButton objects"]
    pub fn set_inline_keyboard<'a>(
        &'a mut self,
        inline_keyboard: Vec<Vec<InlineKeyboardButton>>,
    ) -> &'a mut Self {
        self.inline_keyboard = inline_keyboard;
        self
    }
}
#[allow(dead_code)]
impl ProximityAlertTriggered {
    pub fn new(traveler: User, watcher: User, distance: i64) -> Self {
        Self {
            traveler,
            watcher,
            distance,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (traveler, watcher, distance)"]
    pub fn into_tuple(self) -> (User, User, i64) {
        (self.traveler, self.watcher, self.distance)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that triggered the alert"]
    pub fn get_traveler<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.traveler)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that triggered the alert"]
    pub fn get_traveler_ref<'a>(&'a self) -> &'a User {
        &self.traveler
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that triggered the alert"]
    pub fn set_traveler<'a>(&'a mut self, traveler: User) -> &'a mut Self {
        self.traveler = traveler;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that set the alert"]
    pub fn get_watcher<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.watcher)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that set the alert"]
    pub fn get_watcher_ref<'a>(&'a self) -> &'a User {
        &self.watcher
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that set the alert"]
    pub fn set_watcher<'a>(&'a mut self, watcher: User) -> &'a mut Self {
        self.watcher = watcher;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The distance between the users"]
    pub fn get_distance<'a>(&'a self) -> i64 {
        self.distance
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The distance between the users"]
    pub fn get_distance_ref<'a>(&'a self) -> i64 {
        self.distance
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The distance between the users"]
    pub fn set_distance<'a>(&'a mut self, distance: i64) -> &'a mut Self {
        self.distance = distance;
        self
    }
}
#[allow(dead_code)]
impl ForumTopicCreated {
    pub fn new(name: String, icon_color: i64) -> Self {
        Self {
            name,
            icon_color,
            icon_custom_emoji_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (name, icon_color, icon_custom_emoji_id)"]
    pub fn into_tuple(self) -> (String, i64, Option<String>) {
        (
            self.name,
            self.icon_color,
            self.icon_custom_emoji_id
                .map(|icon_custom_emoji_id| icon_custom_emoji_id),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    pub fn get_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    pub fn get_name_ref<'a>(&'a self) -> &'a str {
        self.name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the topic"]
    pub fn set_name<'a>(&'a mut self, name: String) -> &'a mut Self {
        self.name = name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    pub fn get_icon_color<'a>(&'a self) -> i64 {
        self.icon_color
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    pub fn get_icon_color_ref<'a>(&'a self) -> i64 {
        self.icon_color
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Color of the topic icon in RGB format"]
    pub fn set_icon_color<'a>(&'a mut self, icon_color: i64) -> &'a mut Self {
        self.icon_color = icon_color;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    pub fn get_icon_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.icon_custom_emoji_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    pub fn get_icon_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.icon_custom_emoji_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unique identifier of the custom emoji shown as the topic icon"]
    pub fn set_icon_custom_emoji_id<'a>(
        &'a mut self,
        icon_custom_emoji_id: Option<String>,
    ) -> &'a mut Self {
        self.icon_custom_emoji_id = if let Some(icon_custom_emoji_id) = icon_custom_emoji_id {
            Some(icon_custom_emoji_id)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl Sticker {
    pub fn new(
        file_id: String,
        file_unique_id: String,
        width: i64,
        height: i64,
        is_animated: bool,
        is_video: bool,
    ) -> Self {
        Self {
            tg_type: "Sticker".to_owned(),
            file_id,
            file_unique_id,
            width,
            height,
            is_animated,
            is_video,
            thumbnail: None,
            emoji: None,
            set_name: None,
            premium_animation: None,
            mask_position: None,
            custom_emoji_id: None,
            needs_repainting: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, type, width, height, is_animated, is_video, thumbnail, emoji, set_name, premium_animation, mask_position, custom_emoji_id, needs_repainting, file_size)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        i64,
        i64,
        bool,
        bool,
        Option<PhotoSize>,
        Option<String>,
        Option<String>,
        Option<File>,
        Option<MaskPosition>,
        Option<String>,
        Option<bool>,
        Option<i64>,
    ) {
        (
            self.file_id,
            self.file_unique_id,
            self.tg_type,
            self.width,
            self.height,
            self.is_animated,
            self.is_video,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.emoji.map(|emoji| emoji),
            self.set_name.map(|set_name| set_name),
            self.premium_animation
                .map(|premium_animation| premium_animation),
            self.mask_position.map(|mask_position| mask_position),
            self.custom_emoji_id.map(|custom_emoji_id| custom_emoji_id),
            self.needs_repainting
                .map(|needs_repainting| needs_repainting),
            self.file_size.map(|file_size| file_size),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id_ref<'a>(&'a self) -> &'a str {
        self.file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the sticker, currently one of \"regular\", \"mask\", \"custom_emoji\". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video."]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the sticker, currently one of \"regular\", \"mask\", \"custom_emoji\". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video."]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the sticker, currently one of \"regular\", \"mask\", \"custom_emoji\". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video."]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker width"]
    pub fn get_width<'a>(&'a self) -> i64 {
        self.width
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker width"]
    pub fn get_width_ref<'a>(&'a self) -> i64 {
        self.width
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker width"]
    pub fn set_width<'a>(&'a mut self, width: i64) -> &'a mut Self {
        self.width = width;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker height"]
    pub fn get_height<'a>(&'a self) -> i64 {
        self.height
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker height"]
    pub fn get_height_ref<'a>(&'a self) -> i64 {
        self.height
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker height"]
    pub fn set_height<'a>(&'a mut self, height: i64) -> &'a mut Self {
        self.height = height;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is animated"]
    pub fn get_is_animated<'a>(&'a self) -> bool {
        self.is_animated
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is animated"]
    pub fn get_is_animated_ref<'a>(&'a self) -> bool {
        self.is_animated
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is animated"]
    pub fn set_is_animated<'a>(&'a mut self, is_animated: bool) -> &'a mut Self {
        self.is_animated = is_animated;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is a video sticker"]
    pub fn get_is_video<'a>(&'a self) -> bool {
        self.is_video
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is a video sticker"]
    pub fn get_is_video_ref<'a>(&'a self) -> bool {
        self.is_video
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker is a video sticker"]
    pub fn set_is_video<'a>(&'a mut self, is_video: bool) -> &'a mut Self {
        self.is_video = is_video;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker thumbnail in the .WEBP or .JPG format"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker thumbnail in the .WEBP or .JPG format"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a PhotoSize> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker thumbnail in the .WEBP or .JPG format"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Emoji associated with the sticker"]
    pub fn get_emoji<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.emoji.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Emoji associated with the sticker"]
    pub fn get_emoji_ref<'a>(&'a self) -> Option<&'a str> {
        self.emoji.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Emoji associated with the sticker"]
    pub fn set_emoji<'a>(&'a mut self, emoji: Option<String>) -> &'a mut Self {
        self.emoji = if let Some(emoji) = emoji {
            Some(emoji)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the sticker set to which the sticker belongs"]
    pub fn get_set_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.set_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the sticker set to which the sticker belongs"]
    pub fn get_set_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.set_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Name of the sticker set to which the sticker belongs"]
    pub fn set_set_name<'a>(&'a mut self, set_name: Option<String>) -> &'a mut Self {
        self.set_name = if let Some(set_name) = set_name {
            Some(set_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For premium regular stickers, premium animation for the sticker"]
    pub fn get_premium_animation<'a>(&'a self) -> Option<Cow<'a, File>> {
        self.premium_animation.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For premium regular stickers, premium animation for the sticker"]
    pub fn get_premium_animation_ref<'a>(&'a self) -> Option<&'a File> {
        self.premium_animation.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For premium regular stickers, premium animation for the sticker"]
    pub fn set_premium_animation<'a>(
        &'a mut self,
        premium_animation: Option<File>,
    ) -> &'a mut Self {
        self.premium_animation = if let Some(premium_animation) = premium_animation {
            Some(premium_animation)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For mask stickers, the position where the mask should be placed"]
    pub fn get_mask_position<'a>(&'a self) -> Option<Cow<'a, MaskPosition>> {
        self.mask_position.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For mask stickers, the position where the mask should be placed"]
    pub fn get_mask_position_ref<'a>(&'a self) -> Option<&'a MaskPosition> {
        self.mask_position.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For mask stickers, the position where the mask should be placed"]
    pub fn set_mask_position<'a>(
        &'a mut self,
        mask_position: Option<MaskPosition>,
    ) -> &'a mut Self {
        self.mask_position = if let Some(mask_position) = mask_position {
            Some(mask_position)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For custom emoji stickers, unique identifier of the custom emoji"]
    pub fn get_custom_emoji_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.custom_emoji_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For custom emoji stickers, unique identifier of the custom emoji"]
    pub fn get_custom_emoji_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.custom_emoji_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For custom emoji stickers, unique identifier of the custom emoji"]
    pub fn set_custom_emoji_id<'a>(&'a mut self, custom_emoji_id: Option<String>) -> &'a mut Self {
        self.custom_emoji_id = if let Some(custom_emoji_id) = custom_emoji_id {
            Some(custom_emoji_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"]
    pub fn get_needs_repainting<'a>(&'a self) -> Option<bool> {
        self.needs_repainting.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"]
    pub fn get_needs_repainting_ref<'a>(&'a self) -> Option<bool> {
        self.needs_repainting.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"]
    pub fn set_needs_repainting<'a>(&'a mut self, needs_repainting: Option<bool>) -> &'a mut Self {
        self.needs_repainting = if let Some(needs_repainting) = needs_repainting {
            Some(needs_repainting)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn get_file_size<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn get_file_size_ref<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self {
        self.file_size = if let Some(file_size) = file_size {
            Some(file_size)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultContact {
    pub fn new(id: String, phone_number: String, first_name: String) -> Self {
        Self {
            tg_type: "contact".to_owned(),
            id,
            phone_number,
            first_name,
            last_name: None,
            vcard: None,
            reply_markup: None,
            input_message_content: None,
            thumbnail_url: None,
            thumbnail_width: None,
            thumbnail_height: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, phone_number, first_name, last_name, vcard, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.tg_type,
            self.id,
            self.phone_number,
            self.first_name,
            self.last_name.map(|last_name| last_name),
            self.vcard.map(|vcard| vcard),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
            self.thumbnail_url.map(|thumbnail_url| thumbnail_url),
            self.thumbnail_width.map(|thumbnail_width| thumbnail_width),
            self.thumbnail_height
                .map(|thumbnail_height| thumbnail_height),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn get_phone_number<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.phone_number.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn get_phone_number_ref<'a>(&'a self) -> &'a str {
        self.phone_number.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    pub fn set_phone_number<'a>(&'a mut self, phone_number: String) -> &'a mut Self {
        self.phone_number = phone_number;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn get_first_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.first_name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn get_first_name_ref<'a>(&'a self) -> &'a str {
        self.first_name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    pub fn set_first_name<'a>(&'a mut self, first_name: String) -> &'a mut Self {
        self.first_name = first_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.last_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn get_last_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.last_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    pub fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self {
        self.last_name = if let Some(last_name) = last_name {
            Some(last_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    pub fn get_vcard<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.vcard.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    pub fn get_vcard_ref<'a>(&'a self) -> Option<&'a str> {
        self.vcard.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    pub fn set_vcard<'a>(&'a mut self, vcard: Option<String>) -> &'a mut Self {
        self.vcard = if let Some(vcard) = vcard {
            Some(vcard)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_url
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self {
        self.thumbnail_url = if let Some(thumbnail_url) = thumbnail_url {
            Some(thumbnail_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn get_thumbnail_width<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self {
        self.thumbnail_width = if let Some(thumbnail_width) = thumbnail_width {
            Some(thumbnail_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn get_thumbnail_height<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self {
        self.thumbnail_height = if let Some(thumbnail_height) = thumbnail_height {
            Some(thumbnail_height)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl MaskPosition {
    pub fn new(
        point: String,
        x_shift: ::ordered_float::OrderedFloat<f64>,
        y_shift: ::ordered_float::OrderedFloat<f64>,
        scale: ::ordered_float::OrderedFloat<f64>,
    ) -> Self {
        Self {
            point,
            x_shift,
            y_shift,
            scale,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (point, x_shift, y_shift, scale)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
    ) {
        (self.point, self.x_shift, self.y_shift, self.scale)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The part of the face relative to which the mask should be placed. One of \"forehead\", \"eyes\", \"mouth\", or \"chin\"."]
    pub fn get_point<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.point.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The part of the face relative to which the mask should be placed. One of \"forehead\", \"eyes\", \"mouth\", or \"chin\"."]
    pub fn get_point_ref<'a>(&'a self) -> &'a str {
        self.point.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The part of the face relative to which the mask should be placed. One of \"forehead\", \"eyes\", \"mouth\", or \"chin\"."]
    pub fn set_point<'a>(&'a mut self, point: String) -> &'a mut Self {
        self.point = point;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."]
    pub fn get_x_shift<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.x_shift
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."]
    pub fn get_x_shift_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.x_shift
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."]
    pub fn set_x_shift<'a>(
        &'a mut self,
        x_shift: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.x_shift = x_shift;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."]
    pub fn get_y_shift<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.y_shift
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."]
    pub fn get_y_shift_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.y_shift
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."]
    pub fn set_y_shift<'a>(
        &'a mut self,
        y_shift: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.y_shift = y_shift;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Mask scaling coefficient. For example, 2.0 means double size."]
    pub fn get_scale<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.scale
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Mask scaling coefficient. For example, 2.0 means double size."]
    pub fn get_scale_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.scale
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Mask scaling coefficient. For example, 2.0 means double size."]
    pub fn set_scale<'a>(&'a mut self, scale: ::ordered_float::OrderedFloat<f64>) -> &'a mut Self {
        self.scale = scale;
        self
    }
}
#[allow(dead_code)]
impl UserShared {
    pub fn new(request_id: i64, user_id: i64) -> Self {
        Self {
            request_id,
            user_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (request_id, user_id)"]
    pub fn into_tuple(self) -> (i64, i64) {
        (self.request_id, self.user_id)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    pub fn get_request_id<'a>(&'a self) -> i64 {
        self.request_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    pub fn get_request_id_ref<'a>(&'a self) -> i64 {
        self.request_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    pub fn set_request_id<'a>(&'a mut self, request_id: i64) -> &'a mut Self {
        self.request_id = request_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."]
    pub fn get_user_id<'a>(&'a self) -> i64 {
        self.user_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."]
    pub fn get_user_id_ref<'a>(&'a self) -> i64 {
        self.user_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."]
    pub fn set_user_id<'a>(&'a mut self, user_id: i64) -> &'a mut Self {
        self.user_id = user_id;
        self
    }
}
#[allow(dead_code)]
impl BotCommandScopeAllChatAdministrators {
    pub fn new() -> Self {
        Self {
            tg_type: "all_chat_administrators".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    pub fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_chat_administrators"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
#[allow(dead_code)]
impl InputMediaAnimation {
    pub fn new(media: Option<InputFile>) -> Self {
        Self {
            tg_type: "animation".to_owned(),
            media,
            thumbnail: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            width: None,
            height: None,
            duration: None,
            has_spoiler: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, media, thumbnail, caption, parse_mode, caption_entities, width, height, duration, has_spoiler)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        Option<InputFile>,
        Option<InputFile>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
    ) {
        (
            self.tg_type,
            self.media,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.width.map(|width| width),
            self.height.map(|height| height),
            self.duration.map(|duration| duration),
            self.has_spoiler.map(|has_spoiler| has_spoiler),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be animation"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_media<'a>(&'a self) -> Cow<'a, Option<InputFile>> {
        Cow::Borrowed(&self.media)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_media_ref<'a>(&'a self) -> &'a Option<InputFile> {
        &self.media
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_media<'a>(&'a mut self, media: Option<InputFile>) -> &'a mut Self {
        self.media = media;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, InputFile>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a InputFile> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<InputFile>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    pub fn get_width<'a>(&'a self) -> Option<i64> {
        self.width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    pub fn get_width_ref<'a>(&'a self) -> Option<i64> {
        self.width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation width"]
    pub fn set_width<'a>(&'a mut self, width: Option<i64>) -> &'a mut Self {
        self.width = if let Some(width) = width {
            Some(width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    pub fn get_height<'a>(&'a self) -> Option<i64> {
        self.height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    pub fn get_height_ref<'a>(&'a self) -> Option<i64> {
        self.height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation height"]
    pub fn set_height<'a>(&'a mut self, height: Option<i64>) -> &'a mut Self {
        self.height = if let Some(height) = height {
            Some(height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    pub fn get_duration<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    pub fn get_duration_ref<'a>(&'a self) -> Option<i64> {
        self.duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation duration in seconds"]
    pub fn set_duration<'a>(&'a mut self, duration: Option<i64>) -> &'a mut Self {
        self.duration = if let Some(duration) = duration {
            Some(duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    pub fn get_has_spoiler<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    pub fn get_has_spoiler_ref<'a>(&'a self) -> Option<bool> {
        self.has_spoiler.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the animation needs to be covered with a spoiler animation"]
    pub fn set_has_spoiler<'a>(&'a mut self, has_spoiler: Option<bool>) -> &'a mut Self {
        self.has_spoiler = if let Some(has_spoiler) = has_spoiler {
            Some(has_spoiler)
        } else {
            None
        };
        self
    }
    fn to_form(self, data: Form) -> Result<(Form, String)> {
        match self.media {
            Some(InputFile::Bytes(FileBytes {
                name,
                bytes: Some(bytes),
            })) => {
                let attach = format!("attach://{}", name);
                let form = data.part(name, Part::bytes(bytes));
                Ok((form, attach))
            }
            Some(InputFile::String(name)) => Ok((data, name)),
            _ => Err(anyhow!("cry")),
        }
    }
}
#[allow(dead_code)]
impl KeyboardButtonPollType {
    pub fn new() -> Self {
        Self {
            tg_type: Some("KeyboardButtonPollType".to_owned()),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    pub fn into_tuple(self) -> Option<String> {
        self.tg_type.map(|tg_type| tg_type)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."]
    pub fn get_tg_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.tg_type.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."]
    pub fn get_tg_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.tg_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: Option<String>) -> &'a mut Self {
        self.tg_type = if let Some(tg_type) = tg_type {
            Some(tg_type)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatJoinRequest {
    pub fn new(chat: Chat, from: User, user_chat_id: i64, date: i64) -> Self {
        Self {
            chat,
            from,
            user_chat_id,
            date,
            bio: None,
            invite_link: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (chat, from, user_chat_id, date, bio, invite_link)"]
    pub fn into_tuple(self) -> (Chat, User, i64, i64, Option<String>, Option<ChatInviteLink>) {
        (
            self.chat,
            self.from,
            self.user_chat_id,
            self.date,
            self.bio.map(|bio| bio),
            self.invite_link.map(|invite_link| invite_link),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat to which the request was sent"]
    pub fn get_chat<'a>(&'a self) -> Cow<'a, Chat> {
        Cow::Borrowed(&self.chat)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat to which the request was sent"]
    pub fn get_chat_ref<'a>(&'a self) -> &'a Chat {
        &self.chat
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Chat to which the request was sent"]
    pub fn set_chat<'a>(&'a mut self, chat: Chat) -> &'a mut Self {
        self.chat = chat;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that sent the join request"]
    pub fn get_from<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.from)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that sent the join request"]
    pub fn get_from_ref<'a>(&'a self) -> &'a User {
        &self.from
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User that sent the join request"]
    pub fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    pub fn get_user_chat_id<'a>(&'a self) -> i64 {
        self.user_chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    pub fn get_user_chat_id_ref<'a>(&'a self) -> i64 {
        self.user_chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."]
    pub fn set_user_chat_id<'a>(&'a mut self, user_chat_id: i64) -> &'a mut Self {
        self.user_chat_id = user_chat_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the request was sent in Unix time"]
    pub fn get_date<'a>(&'a self) -> i64 {
        self.date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the request was sent in Unix time"]
    pub fn get_date_ref<'a>(&'a self) -> i64 {
        self.date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date the request was sent in Unix time"]
    pub fn set_date<'a>(&'a mut self, date: i64) -> &'a mut Self {
        self.date = date;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    pub fn get_bio<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.bio.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    pub fn get_bio_ref<'a>(&'a self) -> Option<&'a str> {
        self.bio.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Bio of the user."]
    pub fn set_bio<'a>(&'a mut self, bio: Option<String>) -> &'a mut Self {
        self.bio = if let Some(bio) = bio { Some(bio) } else { None };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    pub fn get_invite_link<'a>(&'a self) -> Option<Cow<'a, ChatInviteLink>> {
        self.invite_link.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    pub fn get_invite_link_ref<'a>(&'a self) -> Option<&'a ChatInviteLink> {
        self.invite_link.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Chat invite link that was used by the user to send the join request"]
    pub fn set_invite_link<'a>(&'a mut self, invite_link: Option<ChatInviteLink>) -> &'a mut Self {
        self.invite_link = if let Some(invite_link) = invite_link {
            Some(invite_link)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InputFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    pub fn into_tuple(self) {
        ()
    }
    pub fn to_form(self, data: Form) -> Result<(Form, String)> {
        match self {
            InputFile::Bytes(FileBytes {
                name,
                bytes: Some(bytes),
            }) => {
                let attach = format!("attach://{}", name);
                let form = data.part(name, Part::bytes(bytes).file_name(""));
                Ok((form, attach))
            }
            InputFile::String(name) => Ok((data, name)),
            _ => Err(anyhow!("cry")),
        }
    }
}
#[allow(dead_code)]
impl InlineQueryResultCachedDocument {
    pub fn new(id: String, title: String, document_file_id: String) -> Self {
        Self {
            tg_type: "document".to_owned(),
            id,
            title,
            document_file_id,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, title, document_file_id, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.title,
            self.document_file_id,
            self.description.map(|description| description),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    pub fn get_document_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.document_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    pub fn get_document_file_id_ref<'a>(&'a self) -> &'a str {
        self.document_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    pub fn set_document_file_id<'a>(&'a mut self, document_file_id: String) -> &'a mut Self {
        self.document_file_id = document_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatAdministratorRights {
    pub fn new(
        is_anonymous: bool,
        can_manage_chat: bool,
        can_delete_messages: bool,
        can_manage_video_chats: bool,
        can_restrict_members: bool,
        can_promote_members: bool,
        can_change_info: bool,
        can_invite_users: bool,
    ) -> Self {
        Self {
            is_anonymous,
            can_manage_chat,
            can_delete_messages,
            can_manage_video_chats,
            can_restrict_members,
            can_promote_members,
            can_change_info,
            can_invite_users,
            can_post_messages: None,
            can_edit_messages: None,
            can_pin_messages: None,
            can_post_stories: None,
            can_edit_stories: None,
            can_delete_stories: None,
            can_manage_topics: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (is_anonymous, can_manage_chat, can_delete_messages, can_manage_video_chats, can_restrict_members, can_promote_members, can_change_info, can_invite_users, can_post_messages, can_edit_messages, can_pin_messages, can_post_stories, can_edit_stories, can_delete_stories, can_manage_topics)"]
    pub fn into_tuple(
        self,
    ) -> (
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    ) {
        (
            self.is_anonymous,
            self.can_manage_chat,
            self.can_delete_messages,
            self.can_manage_video_chats,
            self.can_restrict_members,
            self.can_promote_members,
            self.can_change_info,
            self.can_invite_users,
            self.can_post_messages
                .map(|can_post_messages| can_post_messages),
            self.can_edit_messages
                .map(|can_edit_messages| can_edit_messages),
            self.can_pin_messages
                .map(|can_pin_messages| can_pin_messages),
            self.can_post_stories
                .map(|can_post_stories| can_post_stories),
            self.can_edit_stories
                .map(|can_edit_stories| can_edit_stories),
            self.can_delete_stories
                .map(|can_delete_stories| can_delete_stories),
            self.can_manage_topics
                .map(|can_manage_topics| can_manage_topics),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn get_is_anonymous<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn get_is_anonymous_ref<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn set_is_anonymous<'a>(&'a mut self, is_anonymous: bool) -> &'a mut Self {
        self.is_anonymous = is_anonymous;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    pub fn get_can_manage_chat<'a>(&'a self) -> bool {
        self.can_manage_chat
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    pub fn get_can_manage_chat_ref<'a>(&'a self) -> bool {
        self.can_manage_chat
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"]
    pub fn set_can_manage_chat<'a>(&'a mut self, can_manage_chat: bool) -> &'a mut Self {
        self.can_manage_chat = can_manage_chat;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    pub fn get_can_delete_messages<'a>(&'a self) -> bool {
        self.can_delete_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    pub fn get_can_delete_messages_ref<'a>(&'a self) -> bool {
        self.can_delete_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can delete messages of other users"]
    pub fn set_can_delete_messages<'a>(&'a mut self, can_delete_messages: bool) -> &'a mut Self {
        self.can_delete_messages = can_delete_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    pub fn get_can_manage_video_chats<'a>(&'a self) -> bool {
        self.can_manage_video_chats
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    pub fn get_can_manage_video_chats_ref<'a>(&'a self) -> bool {
        self.can_manage_video_chats
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can manage video chats"]
    pub fn set_can_manage_video_chats<'a>(
        &'a mut self,
        can_manage_video_chats: bool,
    ) -> &'a mut Self {
        self.can_manage_video_chats = can_manage_video_chats;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    pub fn get_can_restrict_members<'a>(&'a self) -> bool {
        self.can_restrict_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    pub fn get_can_restrict_members_ref<'a>(&'a self) -> bool {
        self.can_restrict_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"]
    pub fn set_can_restrict_members<'a>(&'a mut self, can_restrict_members: bool) -> &'a mut Self {
        self.can_restrict_members = can_restrict_members;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    pub fn get_can_promote_members<'a>(&'a self) -> bool {
        self.can_promote_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    pub fn get_can_promote_members_ref<'a>(&'a self) -> bool {
        self.can_promote_members
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"]
    pub fn set_can_promote_members<'a>(&'a mut self, can_promote_members: bool) -> &'a mut Self {
        self.can_promote_members = can_promote_members;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn get_can_change_info<'a>(&'a self) -> bool {
        self.can_change_info
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn get_can_change_info_ref<'a>(&'a self) -> bool {
        self.can_change_info
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn set_can_change_info<'a>(&'a mut self, can_change_info: bool) -> &'a mut Self {
        self.can_change_info = can_change_info;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn get_can_invite_users<'a>(&'a self) -> bool {
        self.can_invite_users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn get_can_invite_users_ref<'a>(&'a self) -> bool {
        self.can_invite_users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn set_can_invite_users<'a>(&'a mut self, can_invite_users: bool) -> &'a mut Self {
        self.can_invite_users = can_invite_users;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    pub fn get_can_post_messages<'a>(&'a self) -> Option<bool> {
        self.can_post_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    pub fn get_can_post_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_post_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"]
    pub fn set_can_post_messages<'a>(
        &'a mut self,
        can_post_messages: Option<bool>,
    ) -> &'a mut Self {
        self.can_post_messages = if let Some(can_post_messages) = can_post_messages {
            Some(can_post_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    pub fn get_can_edit_messages<'a>(&'a self) -> Option<bool> {
        self.can_edit_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    pub fn get_can_edit_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_edit_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"]
    pub fn set_can_edit_messages<'a>(
        &'a mut self,
        can_edit_messages: Option<bool>,
    ) -> &'a mut Self {
        self.can_edit_messages = if let Some(can_edit_messages) = can_edit_messages {
            Some(can_edit_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    pub fn get_can_pin_messages<'a>(&'a self) -> Option<bool> {
        self.can_pin_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    pub fn get_can_pin_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_pin_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to pin messages; groups and supergroups only"]
    pub fn set_can_pin_messages<'a>(&'a mut self, can_pin_messages: Option<bool>) -> &'a mut Self {
        self.can_pin_messages = if let Some(can_pin_messages) = can_pin_messages {
            Some(can_pin_messages)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    pub fn get_can_post_stories<'a>(&'a self) -> Option<bool> {
        self.can_post_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    pub fn get_can_post_stories_ref<'a>(&'a self) -> Option<bool> {
        self.can_post_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can post stories in the channel; channels only"]
    pub fn set_can_post_stories<'a>(&'a mut self, can_post_stories: Option<bool>) -> &'a mut Self {
        self.can_post_stories = if let Some(can_post_stories) = can_post_stories {
            Some(can_post_stories)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    pub fn get_can_edit_stories<'a>(&'a self) -> Option<bool> {
        self.can_edit_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    pub fn get_can_edit_stories_ref<'a>(&'a self) -> Option<bool> {
        self.can_edit_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can edit stories posted by other users; channels only"]
    pub fn set_can_edit_stories<'a>(&'a mut self, can_edit_stories: Option<bool>) -> &'a mut Self {
        self.can_edit_stories = if let Some(can_edit_stories) = can_edit_stories {
            Some(can_edit_stories)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    pub fn get_can_delete_stories<'a>(&'a self) -> Option<bool> {
        self.can_delete_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    pub fn get_can_delete_stories_ref<'a>(&'a self) -> Option<bool> {
        self.can_delete_stories.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the administrator can delete stories posted by other users; channels only"]
    pub fn set_can_delete_stories<'a>(
        &'a mut self,
        can_delete_stories: Option<bool>,
    ) -> &'a mut Self {
        self.can_delete_stories = if let Some(can_delete_stories) = can_delete_stories {
            Some(can_delete_stories)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    pub fn get_can_manage_topics<'a>(&'a self) -> Option<bool> {
        self.can_manage_topics.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    pub fn get_can_manage_topics_ref<'a>(&'a self) -> Option<bool> {
        self.can_manage_topics.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"]
    pub fn set_can_manage_topics<'a>(
        &'a mut self,
        can_manage_topics: Option<bool>,
    ) -> &'a mut Self {
        self.can_manage_topics = if let Some(can_manage_topics) = can_manage_topics {
            Some(can_manage_topics)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl VideoChatStarted {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    pub fn into_tuple(self) {
        ()
    }
}
#[allow(dead_code)]
impl WebhookInfo {
    pub fn new(url: String, has_custom_certificate: bool, pending_update_count: i64) -> Self {
        Self {
            url,
            has_custom_certificate,
            pending_update_count,
            ip_address: None,
            last_error_date: None,
            last_error_message: None,
            last_synchronization_error_date: None,
            max_connections: None,
            allowed_updates: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (url, has_custom_certificate, pending_update_count, ip_address, last_error_date, last_error_message, last_synchronization_error_date, max_connections, allowed_updates)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        bool,
        i64,
        Option<String>,
        Option<i64>,
        Option<String>,
        Option<i64>,
        Option<i64>,
        Option<Vec<String>>,
    ) {
        (
            self.url,
            self.has_custom_certificate,
            self.pending_update_count,
            self.ip_address.map(|ip_address| ip_address),
            self.last_error_date.map(|last_error_date| last_error_date),
            self.last_error_message
                .map(|last_error_message| last_error_message),
            self.last_synchronization_error_date
                .map(|last_synchronization_error_date| last_synchronization_error_date),
            self.max_connections.map(|max_connections| max_connections),
            self.allowed_updates.map(|allowed_updates| allowed_updates),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Webhook URL, may be empty if webhook is not set up"]
    pub fn get_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Webhook URL, may be empty if webhook is not set up"]
    pub fn get_url_ref<'a>(&'a self) -> &'a str {
        self.url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Webhook URL, may be empty if webhook is not set up"]
    pub fn set_url<'a>(&'a mut self, url: String) -> &'a mut Self {
        self.url = url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if a custom certificate was provided for webhook certificate checks"]
    pub fn get_has_custom_certificate<'a>(&'a self) -> bool {
        self.has_custom_certificate
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if a custom certificate was provided for webhook certificate checks"]
    pub fn get_has_custom_certificate_ref<'a>(&'a self) -> bool {
        self.has_custom_certificate
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if a custom certificate was provided for webhook certificate checks"]
    pub fn set_has_custom_certificate<'a>(
        &'a mut self,
        has_custom_certificate: bool,
    ) -> &'a mut Self {
        self.has_custom_certificate = has_custom_certificate;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of updates awaiting delivery"]
    pub fn get_pending_update_count<'a>(&'a self) -> i64 {
        self.pending_update_count
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of updates awaiting delivery"]
    pub fn get_pending_update_count_ref<'a>(&'a self) -> i64 {
        self.pending_update_count
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Number of updates awaiting delivery"]
    pub fn set_pending_update_count<'a>(&'a mut self, pending_update_count: i64) -> &'a mut Self {
        self.pending_update_count = pending_update_count;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Currently used webhook IP address"]
    pub fn get_ip_address<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.ip_address.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Currently used webhook IP address"]
    pub fn get_ip_address_ref<'a>(&'a self) -> Option<&'a str> {
        self.ip_address.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Currently used webhook IP address"]
    pub fn set_ip_address<'a>(&'a mut self, ip_address: Option<String>) -> &'a mut Self {
        self.ip_address = if let Some(ip_address) = ip_address {
            Some(ip_address)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"]
    pub fn get_last_error_date<'a>(&'a self) -> Option<i64> {
        self.last_error_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"]
    pub fn get_last_error_date_ref<'a>(&'a self) -> Option<i64> {
        self.last_error_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"]
    pub fn set_last_error_date<'a>(&'a mut self, last_error_date: Option<i64>) -> &'a mut Self {
        self.last_error_date = if let Some(last_error_date) = last_error_date {
            Some(last_error_date)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"]
    pub fn get_last_error_message<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.last_error_message
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"]
    pub fn get_last_error_message_ref<'a>(&'a self) -> Option<&'a str> {
        self.last_error_message.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"]
    pub fn set_last_error_message<'a>(
        &'a mut self,
        last_error_message: Option<String>,
    ) -> &'a mut Self {
        self.last_error_message = if let Some(last_error_message) = last_error_message {
            Some(last_error_message)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"]
    pub fn get_last_synchronization_error_date<'a>(&'a self) -> Option<i64> {
        self.last_synchronization_error_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"]
    pub fn get_last_synchronization_error_date_ref<'a>(&'a self) -> Option<i64> {
        self.last_synchronization_error_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"]
    pub fn set_last_synchronization_error_date<'a>(
        &'a mut self,
        last_synchronization_error_date: Option<i64>,
    ) -> &'a mut Self {
        self.last_synchronization_error_date =
            if let Some(last_synchronization_error_date) = last_synchronization_error_date {
                Some(last_synchronization_error_date)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"]
    pub fn get_max_connections<'a>(&'a self) -> Option<i64> {
        self.max_connections.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"]
    pub fn get_max_connections_ref<'a>(&'a self) -> Option<i64> {
        self.max_connections.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"]
    pub fn set_max_connections<'a>(&'a mut self, max_connections: Option<i64>) -> &'a mut Self {
        self.max_connections = if let Some(max_connections) = max_connections {
            Some(max_connections)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"]
    pub fn get_allowed_updates<'a>(&'a self) -> Option<Cow<'a, Vec<String>>> {
        self.allowed_updates.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"]
    pub fn get_allowed_updates_ref<'a>(&'a self) -> Option<&'a Vec<String>> {
        self.allowed_updates.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"]
    pub fn set_allowed_updates<'a>(
        &'a mut self,
        allowed_updates: Option<Vec<String>>,
    ) -> &'a mut Self {
        self.allowed_updates = if let Some(allowed_updates) = allowed_updates {
            Some(allowed_updates)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl WebAppData {
    pub fn new(data: String, button_text: String) -> Self {
        Self { data, button_text }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (data, button_text)"]
    pub fn into_tuple(self) -> (String, String) {
        (self.data, self.button_text)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The data. Be aware that a bad client can send arbitrary data in this field."]
    pub fn get_data<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.data.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The data. Be aware that a bad client can send arbitrary data in this field."]
    pub fn get_data_ref<'a>(&'a self) -> &'a str {
        self.data.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The data. Be aware that a bad client can send arbitrary data in this field."]
    pub fn set_data<'a>(&'a mut self, data: String) -> &'a mut Self {
        self.data = data;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."]
    pub fn get_button_text<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.button_text.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."]
    pub fn get_button_text_ref<'a>(&'a self) -> &'a str {
        self.button_text.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."]
    pub fn set_button_text<'a>(&'a mut self, button_text: String) -> &'a mut Self {
        self.button_text = button_text;
        self
    }
}
#[allow(dead_code)]
impl InlineQuery {
    pub fn new(id: String, from: User, query: String, offset: String) -> Self {
        Self {
            id,
            from,
            query,
            offset,
            chat_type: None,
            location: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, from, query, offset, chat_type, location)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        User,
        String,
        String,
        Option<String>,
        Option<Location>,
    ) {
        (
            self.id,
            self.from,
            self.query,
            self.offset,
            self.chat_type.map(|chat_type| chat_type),
            self.location.map(|location| location),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this query"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    pub fn get_from<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.from)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    pub fn get_from_ref<'a>(&'a self) -> &'a User {
        &self.from
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sender"]
    pub fn set_from<'a>(&'a mut self, from: User) -> &'a mut Self {
        self.from = from;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the query (up to 256 characters)"]
    pub fn get_query<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.query.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the query (up to 256 characters)"]
    pub fn get_query_ref<'a>(&'a self) -> &'a str {
        self.query.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the query (up to 256 characters)"]
    pub fn set_query<'a>(&'a mut self, query: String) -> &'a mut Self {
        self.query = query;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    pub fn get_offset<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.offset.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    pub fn get_offset_ref<'a>(&'a self) -> &'a str {
        self.offset.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Offset of the results to be returned, can be controlled by the bot"]
    pub fn set_offset<'a>(&'a mut self, offset: String) -> &'a mut Self {
        self.offset = offset;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    pub fn get_chat_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.chat_type.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    pub fn get_chat_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.chat_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Type of the chat from which the inline query was sent. Can be either \"sender\" for a private chat with the inline query sender, \"private\", \"group\", \"supergroup\", or \"channel\". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat"]
    pub fn set_chat_type<'a>(&'a mut self, chat_type: Option<String>) -> &'a mut Self {
        self.chat_type = if let Some(chat_type) = chat_type {
            Some(chat_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that request user location"]
    pub fn get_location<'a>(&'a self) -> Option<Cow<'a, Location>> {
        self.location.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that request user location"]
    pub fn get_location_ref<'a>(&'a self) -> Option<&'a Location> {
        self.location.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sender location, only for bots that request user location"]
    pub fn set_location<'a>(&'a mut self, location: Option<Location>) -> &'a mut Self {
        self.location = if let Some(location) = location {
            Some(location)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl PassportFile {
    pub fn new(file_id: String, file_unique_id: String, file_size: i64, file_date: i64) -> Self {
        Self {
            file_id,
            file_unique_id,
            file_size,
            file_date,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, file_size, file_date)"]
    pub fn into_tuple(self) -> (String, String, i64, i64) {
        (
            self.file_id,
            self.file_unique_id,
            self.file_size,
            self.file_date,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id_ref<'a>(&'a self) -> &'a str {
        self.file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File size in bytes"]
    pub fn get_file_size<'a>(&'a self) -> i64 {
        self.file_size
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File size in bytes"]
    pub fn get_file_size_ref<'a>(&'a self) -> i64 {
        self.file_size
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File size in bytes"]
    pub fn set_file_size<'a>(&'a mut self, file_size: i64) -> &'a mut Self {
        self.file_size = file_size;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unix time when the file was uploaded"]
    pub fn get_file_date<'a>(&'a self) -> i64 {
        self.file_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unix time when the file was uploaded"]
    pub fn get_file_date_ref<'a>(&'a self) -> i64 {
        self.file_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unix time when the file was uploaded"]
    pub fn set_file_date<'a>(&'a mut self, file_date: i64) -> &'a mut Self {
        self.file_date = file_date;
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultCachedSticker {
    pub fn new(id: String, sticker_file_id: String) -> Self {
        Self {
            tg_type: "sticker".to_owned(),
            id,
            sticker_file_id,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, sticker_file_id, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.sticker_file_id,
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    pub fn get_sticker_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.sticker_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    pub fn get_sticker_file_id_ref<'a>(&'a self) -> &'a str {
        self.sticker_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    pub fn set_sticker_file_id<'a>(&'a mut self, sticker_file_id: String) -> &'a mut Self {
        self.sticker_file_id = sticker_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl Animation {
    pub fn new(
        file_id: String,
        file_unique_id: String,
        width: i64,
        height: i64,
        duration: i64,
    ) -> Self {
        Self {
            file_id,
            file_unique_id,
            width,
            height,
            duration,
            thumbnail: None,
            file_name: None,
            mime_type: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, width, height, duration, thumbnail, file_name, mime_type, file_size)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        i64,
        i64,
        i64,
        Option<PhotoSize>,
        Option<String>,
        Option<String>,
        Option<i64>,
    ) {
        (
            self.file_id,
            self.file_unique_id,
            self.width,
            self.height,
            self.duration,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.file_name.map(|file_name| file_name),
            self.mime_type.map(|mime_type| mime_type),
            self.file_size.map(|file_size| file_size),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id_ref<'a>(&'a self) -> &'a str {
        self.file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    pub fn get_width<'a>(&'a self) -> i64 {
        self.width
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    pub fn get_width_ref<'a>(&'a self) -> i64 {
        self.width
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    pub fn set_width<'a>(&'a mut self, width: i64) -> &'a mut Self {
        self.width = width;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    pub fn get_height<'a>(&'a self) -> i64 {
        self.height
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    pub fn get_height_ref<'a>(&'a self) -> i64 {
        self.height
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    pub fn set_height<'a>(&'a mut self, height: i64) -> &'a mut Self {
        self.height = height;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn get_duration<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn get_duration_ref<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self {
        self.duration = duration;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation thumbnail as defined by sender"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation thumbnail as defined by sender"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a PhotoSize> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation thumbnail as defined by sender"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original animation filename as defined by sender"]
    pub fn get_file_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.file_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original animation filename as defined by sender"]
    pub fn get_file_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.file_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original animation filename as defined by sender"]
    pub fn set_file_name<'a>(&'a mut self, file_name: Option<String>) -> &'a mut Self {
        self.file_name = if let Some(file_name) = file_name {
            Some(file_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn get_mime_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.mime_type.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn get_mime_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.mime_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn set_mime_type<'a>(&'a mut self, mime_type: Option<String>) -> &'a mut Self {
        self.mime_type = if let Some(mime_type) = mime_type {
            Some(mime_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size_ref<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self {
        self.file_size = if let Some(file_size) = file_size {
            Some(file_size)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatPhoto {
    pub fn new(
        small_file_id: String,
        small_file_unique_id: String,
        big_file_id: String,
        big_file_unique_id: String,
    ) -> Self {
        Self {
            small_file_id,
            small_file_unique_id,
            big_file_id,
            big_file_unique_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (small_file_id, small_file_unique_id, big_file_id, big_file_unique_id)"]
    pub fn into_tuple(self) -> (String, String, String, String) {
        (
            self.small_file_id,
            self.small_file_unique_id,
            self.big_file_id,
            self.big_file_unique_id,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    pub fn get_small_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.small_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    pub fn get_small_file_id_ref<'a>(&'a self) -> &'a str {
        self.small_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    pub fn set_small_file_id<'a>(&'a mut self, small_file_id: String) -> &'a mut Self {
        self.small_file_id = small_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_small_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.small_file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_small_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.small_file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_small_file_unique_id<'a>(
        &'a mut self,
        small_file_unique_id: String,
    ) -> &'a mut Self {
        self.small_file_unique_id = small_file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    pub fn get_big_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.big_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    pub fn get_big_file_id_ref<'a>(&'a self) -> &'a str {
        self.big_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."]
    pub fn set_big_file_id<'a>(&'a mut self, big_file_id: String) -> &'a mut Self {
        self.big_file_id = big_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_big_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.big_file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_big_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.big_file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_big_file_unique_id<'a>(&'a mut self, big_file_unique_id: String) -> &'a mut Self {
        self.big_file_unique_id = big_file_unique_id;
        self
    }
}
#[allow(dead_code)]
impl StickerSet {
    pub fn new(
        name: String,
        title: String,
        sticker_type: String,
        is_animated: bool,
        is_video: bool,
        stickers: Vec<Sticker>,
    ) -> Self {
        Self {
            name,
            title,
            sticker_type,
            is_animated,
            is_video,
            stickers,
            thumbnail: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (name, title, sticker_type, is_animated, is_video, stickers, thumbnail)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        bool,
        bool,
        Vec<Sticker>,
        Option<PhotoSize>,
    ) {
        (
            self.name,
            self.title,
            self.sticker_type,
            self.is_animated,
            self.is_video,
            self.stickers,
            self.thumbnail.map(|thumbnail| thumbnail),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set name"]
    pub fn get_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set name"]
    pub fn get_name_ref<'a>(&'a self) -> &'a str {
        self.name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set name"]
    pub fn set_name<'a>(&'a mut self, name: String) -> &'a mut Self {
        self.name = name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set title"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set title"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Sticker set title"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of stickers in the set, currently one of \"regular\", \"mask\", \"custom_emoji\""]
    pub fn get_sticker_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.sticker_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of stickers in the set, currently one of \"regular\", \"mask\", \"custom_emoji\""]
    pub fn get_sticker_type_ref<'a>(&'a self) -> &'a str {
        self.sticker_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of stickers in the set, currently one of \"regular\", \"mask\", \"custom_emoji\""]
    pub fn set_sticker_type<'a>(&'a mut self, sticker_type: String) -> &'a mut Self {
        self.sticker_type = sticker_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains animated stickers"]
    pub fn get_is_animated<'a>(&'a self) -> bool {
        self.is_animated
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains animated stickers"]
    pub fn get_is_animated_ref<'a>(&'a self) -> bool {
        self.is_animated
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains animated stickers"]
    pub fn set_is_animated<'a>(&'a mut self, is_animated: bool) -> &'a mut Self {
        self.is_animated = is_animated;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains video stickers"]
    pub fn get_is_video<'a>(&'a self) -> bool {
        self.is_video
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains video stickers"]
    pub fn get_is_video_ref<'a>(&'a self) -> bool {
        self.is_video
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the sticker set contains video stickers"]
    pub fn set_is_video<'a>(&'a mut self, is_video: bool) -> &'a mut Self {
        self.is_video = is_video;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of all set stickers"]
    pub fn get_stickers<'a>(&'a self) -> Cow<'a, Vec<Sticker>> {
        Cow::Borrowed(&self.stickers)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of all set stickers"]
    pub fn get_stickers_ref<'a>(&'a self) -> &'a Vec<Sticker> {
        &self.stickers
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of all set stickers"]
    pub fn set_stickers<'a>(&'a mut self, stickers: Vec<Sticker>) -> &'a mut Self {
        self.stickers = stickers;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a PhotoSize> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InputVenueMessageContent {
    pub fn new(
        latitude: ::ordered_float::OrderedFloat<f64>,
        longitude: ::ordered_float::OrderedFloat<f64>,
        title: String,
        address: String,
    ) -> Self {
        Self {
            latitude,
            longitude,
            title,
            address,
            foursquare_id: None,
            foursquare_type: None,
            google_place_id: None,
            google_place_type: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (latitude, longitude, title, address, foursquare_id, foursquare_type, google_place_id, google_place_type)"]
    pub fn into_tuple(
        self,
    ) -> (
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
    ) {
        (
            self.latitude,
            self.longitude,
            self.title,
            self.address,
            self.foursquare_id.map(|foursquare_id| foursquare_id),
            self.foursquare_type.map(|foursquare_type| foursquare_type),
            self.google_place_id.map(|google_place_id| google_place_id),
            self.google_place_type
                .map(|google_place_type| google_place_type),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    pub fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    pub fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    pub fn set_latitude<'a>(
        &'a mut self,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    pub fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    pub fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    pub fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn get_address<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.address.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn get_address_ref<'a>(&'a self) -> &'a str {
        self.address.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    pub fn set_address<'a>(&'a mut self, address: String) -> &'a mut Self {
        self.address = address;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    pub fn get_foursquare_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.foursquare_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    pub fn get_foursquare_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.foursquare_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    pub fn set_foursquare_id<'a>(&'a mut self, foursquare_id: Option<String>) -> &'a mut Self {
        self.foursquare_id = if let Some(foursquare_id) = foursquare_id {
            Some(foursquare_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn get_foursquare_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.foursquare_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn get_foursquare_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.foursquare_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    pub fn set_foursquare_type<'a>(&'a mut self, foursquare_type: Option<String>) -> &'a mut Self {
        self.foursquare_type = if let Some(foursquare_type) = foursquare_type {
            Some(foursquare_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn get_google_place_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.google_place_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn get_google_place_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.google_place_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    pub fn set_google_place_id<'a>(&'a mut self, google_place_id: Option<String>) -> &'a mut Self {
        self.google_place_id = if let Some(google_place_id) = google_place_id {
            Some(google_place_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn get_google_place_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.google_place_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn get_google_place_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.google_place_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    pub fn set_google_place_type<'a>(
        &'a mut self,
        google_place_type: Option<String>,
    ) -> &'a mut Self {
        self.google_place_type = if let Some(google_place_type) = google_place_type {
            Some(google_place_type)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl PassportElementErrorFiles {
    pub fn new(source: String, file_hashes: Vec<String>, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorFiles".to_owned(),
            source,
            file_hashes,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hashes, message)"]
    pub fn into_tuple(self) -> (String, String, Vec<String>, String) {
        (self.source, self.tg_type, self.file_hashes, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    pub fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    pub fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    pub fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    pub fn get_file_hashes<'a>(&'a self) -> Cow<'a, Vec<String>> {
        Cow::Borrowed(&self.file_hashes)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    pub fn get_file_hashes_ref<'a>(&'a self) -> &'a Vec<String> {
        &self.file_hashes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    pub fn set_file_hashes<'a>(&'a mut self, file_hashes: Vec<String>) -> &'a mut Self {
        self.file_hashes = file_hashes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
#[allow(dead_code)]
impl BotCommandScopeChatAdministrators {
    pub fn new(chat_id: ::ordered_float::OrderedFloat<f64>) -> Self {
        Self {
            tg_type: "chat_administrators".to_owned(),
            chat_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, chat_id)"]
    pub fn into_tuple(self) -> (String, ::ordered_float::OrderedFloat<f64>) {
        (self.tg_type, self.chat_id)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_administrators"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn get_chat_id<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn get_chat_id_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn set_chat_id<'a>(
        &'a mut self,
        chat_id: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.chat_id = chat_id;
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultCachedPhoto {
    pub fn new(id: String, photo_file_id: String) -> Self {
        Self {
            tg_type: "photo".to_owned(),
            id,
            photo_file_id,
            title: None,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, photo_file_id, title, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.photo_file_id,
            self.title.map(|title| title),
            self.description.map(|description| description),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    pub fn get_photo_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.photo_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    pub fn get_photo_file_id_ref<'a>(&'a self) -> &'a str {
        self.photo_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    pub fn set_photo_file_id<'a>(&'a mut self, photo_file_id: String) -> &'a mut Self {
        self.photo_file_id = photo_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InputInvoiceMessageContent {
    pub fn new(
        title: String,
        description: String,
        payload: String,
        provider_token: String,
        currency: String,
        prices: Vec<LabeledPrice>,
    ) -> Self {
        Self {
            title,
            description,
            payload,
            provider_token,
            currency,
            prices,
            max_tip_amount: None,
            suggested_tip_amounts: None,
            provider_data: None,
            photo_url: None,
            photo_size: None,
            photo_width: None,
            photo_height: None,
            need_name: None,
            need_phone_number: None,
            need_email: None,
            need_shipping_address: None,
            send_phone_number_to_provider: None,
            send_email_to_provider: None,
            is_flexible: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (title, description, payload, provider_token, currency, prices, max_tip_amount, suggested_tip_amounts, provider_data, photo_url, photo_size, photo_width, photo_height, need_name, need_phone_number, need_email, need_shipping_address, send_phone_number_to_provider, send_email_to_provider, is_flexible)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        Vec<LabeledPrice>,
        Option<i64>,
        Option<Vec<i64>>,
        Option<String>,
        Option<String>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    ) {
        (
            self.title,
            self.description,
            self.payload,
            self.provider_token,
            self.currency,
            self.prices,
            self.max_tip_amount.map(|max_tip_amount| max_tip_amount),
            self.suggested_tip_amounts
                .map(|suggested_tip_amounts| suggested_tip_amounts),
            self.provider_data.map(|provider_data| provider_data),
            self.photo_url.map(|photo_url| photo_url),
            self.photo_size.map(|photo_size| photo_size),
            self.photo_width.map(|photo_width| photo_width),
            self.photo_height.map(|photo_height| photo_height),
            self.need_name.map(|need_name| need_name),
            self.need_phone_number
                .map(|need_phone_number| need_phone_number),
            self.need_email.map(|need_email| need_email),
            self.need_shipping_address
                .map(|need_shipping_address| need_shipping_address),
            self.send_phone_number_to_provider
                .map(|send_phone_number_to_provider| send_phone_number_to_provider),
            self.send_email_to_provider
                .map(|send_email_to_provider| send_email_to_provider),
            self.is_flexible.map(|is_flexible| is_flexible),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    pub fn get_description<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.description.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    pub fn get_description_ref<'a>(&'a self) -> &'a str {
        self.description.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    pub fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self {
        self.description = description;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    pub fn get_payload<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.payload.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    pub fn get_payload_ref<'a>(&'a self) -> &'a str {
        self.payload.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    pub fn set_payload<'a>(&'a mut self, payload: String) -> &'a mut Self {
        self.payload = payload;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    pub fn get_provider_token<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.provider_token.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    pub fn get_provider_token_ref<'a>(&'a self) -> &'a str {
        self.provider_token.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    pub fn set_provider_token<'a>(&'a mut self, provider_token: String) -> &'a mut Self {
        self.provider_token = provider_token;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    pub fn get_currency<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.currency.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    pub fn get_currency_ref<'a>(&'a self) -> &'a str {
        self.currency.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    pub fn set_currency<'a>(&'a mut self, currency: String) -> &'a mut Self {
        self.currency = currency;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    pub fn get_prices<'a>(&'a self) -> Cow<'a, Vec<LabeledPrice>> {
        Cow::Borrowed(&self.prices)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    pub fn get_prices_ref<'a>(&'a self) -> &'a Vec<LabeledPrice> {
        &self.prices
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    pub fn set_prices<'a>(&'a mut self, prices: Vec<LabeledPrice>) -> &'a mut Self {
        self.prices = prices;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    pub fn get_max_tip_amount<'a>(&'a self) -> Option<i64> {
        self.max_tip_amount.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    pub fn get_max_tip_amount_ref<'a>(&'a self) -> Option<i64> {
        self.max_tip_amount.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    pub fn set_max_tip_amount<'a>(&'a mut self, max_tip_amount: Option<i64>) -> &'a mut Self {
        self.max_tip_amount = if let Some(max_tip_amount) = max_tip_amount {
            Some(max_tip_amount)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    pub fn get_suggested_tip_amounts<'a>(&'a self) -> Option<Cow<'a, Vec<i64>>> {
        self.suggested_tip_amounts
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    pub fn get_suggested_tip_amounts_ref<'a>(&'a self) -> Option<&'a Vec<i64>> {
        self.suggested_tip_amounts.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    pub fn set_suggested_tip_amounts<'a>(
        &'a mut self,
        suggested_tip_amounts: Option<Vec<i64>>,
    ) -> &'a mut Self {
        self.suggested_tip_amounts = if let Some(suggested_tip_amounts) = suggested_tip_amounts {
            Some(suggested_tip_amounts)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    pub fn get_provider_data<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.provider_data
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    pub fn get_provider_data_ref<'a>(&'a self) -> Option<&'a str> {
        self.provider_data.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    pub fn set_provider_data<'a>(&'a mut self, provider_data: Option<String>) -> &'a mut Self {
        self.provider_data = if let Some(provider_data) = provider_data {
            Some(provider_data)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    pub fn get_photo_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.photo_url.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    pub fn get_photo_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.photo_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    pub fn set_photo_url<'a>(&'a mut self, photo_url: Option<String>) -> &'a mut Self {
        self.photo_url = if let Some(photo_url) = photo_url {
            Some(photo_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    pub fn get_photo_size<'a>(&'a self) -> Option<i64> {
        self.photo_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    pub fn get_photo_size_ref<'a>(&'a self) -> Option<i64> {
        self.photo_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    pub fn set_photo_size<'a>(&'a mut self, photo_size: Option<i64>) -> &'a mut Self {
        self.photo_size = if let Some(photo_size) = photo_size {
            Some(photo_size)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    pub fn get_photo_width<'a>(&'a self) -> Option<i64> {
        self.photo_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    pub fn get_photo_width_ref<'a>(&'a self) -> Option<i64> {
        self.photo_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    pub fn set_photo_width<'a>(&'a mut self, photo_width: Option<i64>) -> &'a mut Self {
        self.photo_width = if let Some(photo_width) = photo_width {
            Some(photo_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    pub fn get_photo_height<'a>(&'a self) -> Option<i64> {
        self.photo_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    pub fn get_photo_height_ref<'a>(&'a self) -> Option<i64> {
        self.photo_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    pub fn set_photo_height<'a>(&'a mut self, photo_height: Option<i64>) -> &'a mut Self {
        self.photo_height = if let Some(photo_height) = photo_height {
            Some(photo_height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    pub fn get_need_name<'a>(&'a self) -> Option<bool> {
        self.need_name.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    pub fn get_need_name_ref<'a>(&'a self) -> Option<bool> {
        self.need_name.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    pub fn set_need_name<'a>(&'a mut self, need_name: Option<bool>) -> &'a mut Self {
        self.need_name = if let Some(need_name) = need_name {
            Some(need_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    pub fn get_need_phone_number<'a>(&'a self) -> Option<bool> {
        self.need_phone_number.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    pub fn get_need_phone_number_ref<'a>(&'a self) -> Option<bool> {
        self.need_phone_number.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    pub fn set_need_phone_number<'a>(
        &'a mut self,
        need_phone_number: Option<bool>,
    ) -> &'a mut Self {
        self.need_phone_number = if let Some(need_phone_number) = need_phone_number {
            Some(need_phone_number)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    pub fn get_need_email<'a>(&'a self) -> Option<bool> {
        self.need_email.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    pub fn get_need_email_ref<'a>(&'a self) -> Option<bool> {
        self.need_email.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    pub fn set_need_email<'a>(&'a mut self, need_email: Option<bool>) -> &'a mut Self {
        self.need_email = if let Some(need_email) = need_email {
            Some(need_email)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    pub fn get_need_shipping_address<'a>(&'a self) -> Option<bool> {
        self.need_shipping_address.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    pub fn get_need_shipping_address_ref<'a>(&'a self) -> Option<bool> {
        self.need_shipping_address.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    pub fn set_need_shipping_address<'a>(
        &'a mut self,
        need_shipping_address: Option<bool>,
    ) -> &'a mut Self {
        self.need_shipping_address = if let Some(need_shipping_address) = need_shipping_address {
            Some(need_shipping_address)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    pub fn get_send_phone_number_to_provider<'a>(&'a self) -> Option<bool> {
        self.send_phone_number_to_provider.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    pub fn get_send_phone_number_to_provider_ref<'a>(&'a self) -> Option<bool> {
        self.send_phone_number_to_provider.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    pub fn set_send_phone_number_to_provider<'a>(
        &'a mut self,
        send_phone_number_to_provider: Option<bool>,
    ) -> &'a mut Self {
        self.send_phone_number_to_provider =
            if let Some(send_phone_number_to_provider) = send_phone_number_to_provider {
                Some(send_phone_number_to_provider)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    pub fn get_send_email_to_provider<'a>(&'a self) -> Option<bool> {
        self.send_email_to_provider.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    pub fn get_send_email_to_provider_ref<'a>(&'a self) -> Option<bool> {
        self.send_email_to_provider.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    pub fn set_send_email_to_provider<'a>(
        &'a mut self,
        send_email_to_provider: Option<bool>,
    ) -> &'a mut Self {
        self.send_email_to_provider = if let Some(send_email_to_provider) = send_email_to_provider {
            Some(send_email_to_provider)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    pub fn get_is_flexible<'a>(&'a self) -> Option<bool> {
        self.is_flexible.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    pub fn get_is_flexible_ref<'a>(&'a self) -> Option<bool> {
        self.is_flexible.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    pub fn set_is_flexible<'a>(&'a mut self, is_flexible: Option<bool>) -> &'a mut Self {
        self.is_flexible = if let Some(is_flexible) = is_flexible {
            Some(is_flexible)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatMemberMember {
    pub fn new(user: User) -> Self {
        Self { user }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user)"]
    pub fn into_tuple(self) -> User {
        self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
}
#[allow(dead_code)]
impl ForceReply {
    pub fn new(force_reply: bool) -> Self {
        Self {
            force_reply,
            input_field_placeholder: None,
            selective: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (force_reply, input_field_placeholder, selective)"]
    pub fn into_tuple(self) -> (bool, Option<String>, Option<bool>) {
        (
            self.force_reply,
            self.input_field_placeholder
                .map(|input_field_placeholder| input_field_placeholder),
            self.selective.map(|selective| selective),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"]
    pub fn get_force_reply<'a>(&'a self) -> bool {
        self.force_reply
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"]
    pub fn get_force_reply_ref<'a>(&'a self) -> bool {
        self.force_reply
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"]
    pub fn set_force_reply<'a>(&'a mut self, force_reply: bool) -> &'a mut Self {
        self.force_reply = force_reply;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"]
    pub fn get_input_field_placeholder<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.input_field_placeholder
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"]
    pub fn get_input_field_placeholder_ref<'a>(&'a self) -> Option<&'a str> {
        self.input_field_placeholder.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"]
    pub fn set_input_field_placeholder<'a>(
        &'a mut self,
        input_field_placeholder: Option<String>,
    ) -> &'a mut Self {
        self.input_field_placeholder =
            if let Some(input_field_placeholder) = input_field_placeholder {
                Some(input_field_placeholder)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."]
    pub fn get_selective<'a>(&'a self) -> Option<bool> {
        self.selective.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."]
    pub fn get_selective_ref<'a>(&'a self) -> Option<bool> {
        self.selective.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."]
    pub fn set_selective<'a>(&'a mut self, selective: Option<bool>) -> &'a mut Self {
        self.selective = if let Some(selective) = selective {
            Some(selective)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl MenuButtonWebApp {
    pub fn new(text: String, web_app: WebAppInfo) -> Self {
        Self {
            tg_type: "web_app".to_owned(),
            text,
            web_app,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, text, web_app)"]
    pub fn into_tuple(self) -> (String, String, WebAppInfo) {
        (self.tg_type, self.text, self.web_app)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    pub fn get_text<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.text.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    pub fn get_text_ref<'a>(&'a self) -> &'a str {
        self.text.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    pub fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    pub fn get_web_app<'a>(&'a self) -> Cow<'a, WebAppInfo> {
        Cow::Borrowed(&self.web_app)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    pub fn get_web_app_ref<'a>(&'a self) -> &'a WebAppInfo {
        &self.web_app
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    pub fn set_web_app<'a>(&'a mut self, web_app: WebAppInfo) -> &'a mut Self {
        self.web_app = web_app;
        self
    }
}
#[allow(dead_code)]
impl Update {
    pub fn new(update_id: i64) -> Self {
        Self {
            update_id,
            message: None,
            edited_message: None,
            channel_post: None,
            edited_channel_post: None,
            inline_query: None,
            chosen_inline_result: None,
            callback_query: None,
            shipping_query: None,
            pre_checkout_query: None,
            poll: None,
            poll_answer: None,
            my_chat_member: None,
            chat_member: None,
            chat_join_request: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (update_id, message, edited_message, channel_post, edited_channel_post, inline_query, chosen_inline_result, callback_query, shipping_query, pre_checkout_query, poll, poll_answer, my_chat_member, chat_member, chat_join_request)"]
    pub fn into_tuple(
        self,
    ) -> (
        i64,
        Option<Message>,
        Option<Message>,
        Option<Message>,
        Option<Message>,
        Option<InlineQuery>,
        Option<ChosenInlineResult>,
        Option<CallbackQuery>,
        Option<ShippingQuery>,
        Option<PreCheckoutQuery>,
        Option<Poll>,
        Option<PollAnswer>,
        Option<ChatMemberUpdated>,
        Option<ChatMemberUpdated>,
        Option<ChatJoinRequest>,
    ) {
        (
            self.update_id,
            self.message.map(|message| message),
            self.edited_message.map(|edited_message| edited_message),
            self.channel_post.map(|channel_post| channel_post),
            self.edited_channel_post
                .map(|edited_channel_post| edited_channel_post),
            self.inline_query.map(|inline_query| inline_query),
            self.chosen_inline_result
                .map(|chosen_inline_result| chosen_inline_result),
            self.callback_query.map(|callback_query| callback_query),
            self.shipping_query.map(|shipping_query| shipping_query),
            self.pre_checkout_query
                .map(|pre_checkout_query| pre_checkout_query),
            self.poll.map(|poll| poll),
            self.poll_answer.map(|poll_answer| poll_answer),
            self.my_chat_member.map(|my_chat_member| my_chat_member),
            self.chat_member.map(|chat_member| chat_member),
            self.chat_join_request
                .map(|chat_join_request| chat_join_request),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."]
    pub fn get_update_id<'a>(&'a self) -> i64 {
        self.update_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."]
    pub fn get_update_id_ref<'a>(&'a self) -> i64 {
        self.update_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."]
    pub fn set_update_id<'a>(&'a mut self, update_id: i64) -> &'a mut Self {
        self.update_id = update_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming message of any kind - text, photo, sticker, etc."]
    pub fn get_message<'a>(&'a self) -> Option<Cow<'a, Message>> {
        self.message.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming message of any kind - text, photo, sticker, etc."]
    pub fn get_message_ref<'a>(&'a self) -> Option<&'a Message> {
        self.message.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming message of any kind - text, photo, sticker, etc."]
    pub fn set_message<'a>(&'a mut self, message: Option<Message>) -> &'a mut Self {
        self.message = if let Some(message) = message {
            Some(message)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a message that is known to the bot and was edited"]
    pub fn get_edited_message<'a>(&'a self) -> Option<Cow<'a, Message>> {
        self.edited_message.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a message that is known to the bot and was edited"]
    pub fn get_edited_message_ref<'a>(&'a self) -> Option<&'a Message> {
        self.edited_message.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a message that is known to the bot and was edited"]
    pub fn set_edited_message<'a>(&'a mut self, edited_message: Option<Message>) -> &'a mut Self {
        self.edited_message = if let Some(edited_message) = edited_message {
            Some(edited_message)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming channel post of any kind - text, photo, sticker, etc."]
    pub fn get_channel_post<'a>(&'a self) -> Option<Cow<'a, Message>> {
        self.channel_post.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming channel post of any kind - text, photo, sticker, etc."]
    pub fn get_channel_post_ref<'a>(&'a self) -> Option<&'a Message> {
        self.channel_post.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming channel post of any kind - text, photo, sticker, etc."]
    pub fn set_channel_post<'a>(&'a mut self, channel_post: Option<Message>) -> &'a mut Self {
        self.channel_post = if let Some(channel_post) = channel_post {
            Some(channel_post)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a channel post that is known to the bot and was edited"]
    pub fn get_edited_channel_post<'a>(&'a self) -> Option<Cow<'a, Message>> {
        self.edited_channel_post.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a channel post that is known to the bot and was edited"]
    pub fn get_edited_channel_post_ref<'a>(&'a self) -> Option<&'a Message> {
        self.edited_channel_post.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New version of a channel post that is known to the bot and was edited"]
    pub fn set_edited_channel_post<'a>(
        &'a mut self,
        edited_channel_post: Option<Message>,
    ) -> &'a mut Self {
        self.edited_channel_post = if let Some(edited_channel_post) = edited_channel_post {
            Some(edited_channel_post)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming inline query"]
    pub fn get_inline_query<'a>(&'a self) -> Option<Cow<'a, InlineQuery>> {
        self.inline_query.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming inline query"]
    pub fn get_inline_query_ref<'a>(&'a self) -> Option<&'a InlineQuery> {
        self.inline_query.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming inline query"]
    pub fn set_inline_query<'a>(&'a mut self, inline_query: Option<InlineQuery>) -> &'a mut Self {
        self.inline_query = if let Some(inline_query) = inline_query {
            Some(inline_query)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."]
    pub fn get_chosen_inline_result<'a>(&'a self) -> Option<Cow<'a, ChosenInlineResult>> {
        self.chosen_inline_result.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."]
    pub fn get_chosen_inline_result_ref<'a>(&'a self) -> Option<&'a ChosenInlineResult> {
        self.chosen_inline_result.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."]
    pub fn set_chosen_inline_result<'a>(
        &'a mut self,
        chosen_inline_result: Option<ChosenInlineResult>,
    ) -> &'a mut Self {
        self.chosen_inline_result = if let Some(chosen_inline_result) = chosen_inline_result {
            Some(chosen_inline_result)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming callback query"]
    pub fn get_callback_query<'a>(&'a self) -> Option<Cow<'a, CallbackQuery>> {
        self.callback_query.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming callback query"]
    pub fn get_callback_query_ref<'a>(&'a self) -> Option<&'a CallbackQuery> {
        self.callback_query.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming callback query"]
    pub fn set_callback_query<'a>(
        &'a mut self,
        callback_query: Option<CallbackQuery>,
    ) -> &'a mut Self {
        self.callback_query = if let Some(callback_query) = callback_query {
            Some(callback_query)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming shipping query. Only for invoices with flexible price"]
    pub fn get_shipping_query<'a>(&'a self) -> Option<Cow<'a, ShippingQuery>> {
        self.shipping_query.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming shipping query. Only for invoices with flexible price"]
    pub fn get_shipping_query_ref<'a>(&'a self) -> Option<&'a ShippingQuery> {
        self.shipping_query.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming shipping query. Only for invoices with flexible price"]
    pub fn set_shipping_query<'a>(
        &'a mut self,
        shipping_query: Option<ShippingQuery>,
    ) -> &'a mut Self {
        self.shipping_query = if let Some(shipping_query) = shipping_query {
            Some(shipping_query)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming pre-checkout query. Contains full information about checkout"]
    pub fn get_pre_checkout_query<'a>(&'a self) -> Option<Cow<'a, PreCheckoutQuery>> {
        self.pre_checkout_query.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming pre-checkout query. Contains full information about checkout"]
    pub fn get_pre_checkout_query_ref<'a>(&'a self) -> Option<&'a PreCheckoutQuery> {
        self.pre_checkout_query.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New incoming pre-checkout query. Contains full information about checkout"]
    pub fn set_pre_checkout_query<'a>(
        &'a mut self,
        pre_checkout_query: Option<PreCheckoutQuery>,
    ) -> &'a mut Self {
        self.pre_checkout_query = if let Some(pre_checkout_query) = pre_checkout_query {
            Some(pre_checkout_query)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"]
    pub fn get_poll<'a>(&'a self) -> Option<Cow<'a, Poll>> {
        self.poll.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"]
    pub fn get_poll_ref<'a>(&'a self) -> Option<&'a Poll> {
        self.poll.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"]
    pub fn set_poll<'a>(&'a mut self, poll: Option<Poll>) -> &'a mut Self {
        self.poll = if let Some(poll) = poll {
            Some(poll)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."]
    pub fn get_poll_answer<'a>(&'a self) -> Option<Cow<'a, PollAnswer>> {
        self.poll_answer.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."]
    pub fn get_poll_answer_ref<'a>(&'a self) -> Option<&'a PollAnswer> {
        self.poll_answer.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."]
    pub fn set_poll_answer<'a>(&'a mut self, poll_answer: Option<PollAnswer>) -> &'a mut Self {
        self.poll_answer = if let Some(poll_answer) = poll_answer {
            Some(poll_answer)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."]
    pub fn get_my_chat_member<'a>(&'a self) -> Option<Cow<'a, ChatMemberUpdated>> {
        self.my_chat_member.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."]
    pub fn get_my_chat_member_ref<'a>(&'a self) -> Option<&'a ChatMemberUpdated> {
        self.my_chat_member.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."]
    pub fn set_my_chat_member<'a>(
        &'a mut self,
        my_chat_member: Option<ChatMemberUpdated>,
    ) -> &'a mut Self {
        self.my_chat_member = if let Some(my_chat_member) = my_chat_member {
            Some(my_chat_member)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify \"chat_member\" in the list of allowed_updates to receive these updates."]
    pub fn get_chat_member<'a>(&'a self) -> Option<Cow<'a, ChatMemberUpdated>> {
        self.chat_member.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify \"chat_member\" in the list of allowed_updates to receive these updates."]
    pub fn get_chat_member_ref<'a>(&'a self) -> Option<&'a ChatMemberUpdated> {
        self.chat_member.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify \"chat_member\" in the list of allowed_updates to receive these updates."]
    pub fn set_chat_member<'a>(
        &'a mut self,
        chat_member: Option<ChatMemberUpdated>,
    ) -> &'a mut Self {
        self.chat_member = if let Some(chat_member) = chat_member {
            Some(chat_member)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."]
    pub fn get_chat_join_request<'a>(&'a self) -> Option<Cow<'a, ChatJoinRequest>> {
        self.chat_join_request.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."]
    pub fn get_chat_join_request_ref<'a>(&'a self) -> Option<&'a ChatJoinRequest> {
        self.chat_join_request.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."]
    pub fn set_chat_join_request<'a>(
        &'a mut self,
        chat_join_request: Option<ChatJoinRequest>,
    ) -> &'a mut Self {
        self.chat_join_request = if let Some(chat_join_request) = chat_join_request {
            Some(chat_join_request)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl MenuButtonCommands {
    pub fn new() -> Self {
        Self {
            tg_type: "commands".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    pub fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
#[allow(dead_code)]
impl ChatMemberRestricted {
    pub fn new(
        user: User,
        is_member: bool,
        can_send_messages: bool,
        can_send_audios: bool,
        can_send_documents: bool,
        can_send_photos: bool,
        can_send_videos: bool,
        can_send_video_notes: bool,
        can_send_voice_notes: bool,
        can_send_polls: bool,
        can_send_other_messages: bool,
        can_add_web_page_previews: bool,
        can_change_info: bool,
        can_invite_users: bool,
        can_pin_messages: bool,
        can_manage_topics: bool,
        until_date: i64,
    ) -> Self {
        Self {
            user,
            is_member,
            can_send_messages,
            can_send_audios,
            can_send_documents,
            can_send_photos,
            can_send_videos,
            can_send_video_notes,
            can_send_voice_notes,
            can_send_polls,
            can_send_other_messages,
            can_add_web_page_previews,
            can_change_info,
            can_invite_users,
            can_pin_messages,
            can_manage_topics,
            until_date,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, is_member, can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, can_send_voice_notes, can_send_polls, can_send_other_messages, can_add_web_page_previews, can_change_info, can_invite_users, can_pin_messages, can_manage_topics, until_date)"]
    pub fn into_tuple(
        self,
    ) -> (
        User,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        bool,
        i64,
    ) {
        (
            self.user,
            self.is_member,
            self.can_send_messages,
            self.can_send_audios,
            self.can_send_documents,
            self.can_send_photos,
            self.can_send_videos,
            self.can_send_video_notes,
            self.can_send_voice_notes,
            self.can_send_polls,
            self.can_send_other_messages,
            self.can_add_web_page_previews,
            self.can_change_info,
            self.can_invite_users,
            self.can_pin_messages,
            self.can_manage_topics,
            self.until_date,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    pub fn get_is_member<'a>(&'a self) -> bool {
        self.is_member
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    pub fn get_is_member_ref<'a>(&'a self) -> bool {
        self.is_member
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is a member of the chat at the moment of the request"]
    pub fn set_is_member<'a>(&'a mut self, is_member: bool) -> &'a mut Self {
        self.is_member = is_member;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    pub fn get_can_send_messages<'a>(&'a self) -> bool {
        self.can_send_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    pub fn get_can_send_messages_ref<'a>(&'a self) -> bool {
        self.can_send_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"]
    pub fn set_can_send_messages<'a>(&'a mut self, can_send_messages: bool) -> &'a mut Self {
        self.can_send_messages = can_send_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    pub fn get_can_send_audios<'a>(&'a self) -> bool {
        self.can_send_audios
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    pub fn get_can_send_audios_ref<'a>(&'a self) -> bool {
        self.can_send_audios
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send audios"]
    pub fn set_can_send_audios<'a>(&'a mut self, can_send_audios: bool) -> &'a mut Self {
        self.can_send_audios = can_send_audios;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    pub fn get_can_send_documents<'a>(&'a self) -> bool {
        self.can_send_documents
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    pub fn get_can_send_documents_ref<'a>(&'a self) -> bool {
        self.can_send_documents
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send documents"]
    pub fn set_can_send_documents<'a>(&'a mut self, can_send_documents: bool) -> &'a mut Self {
        self.can_send_documents = can_send_documents;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    pub fn get_can_send_photos<'a>(&'a self) -> bool {
        self.can_send_photos
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    pub fn get_can_send_photos_ref<'a>(&'a self) -> bool {
        self.can_send_photos
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send photos"]
    pub fn set_can_send_photos<'a>(&'a mut self, can_send_photos: bool) -> &'a mut Self {
        self.can_send_photos = can_send_photos;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    pub fn get_can_send_videos<'a>(&'a self) -> bool {
        self.can_send_videos
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    pub fn get_can_send_videos_ref<'a>(&'a self) -> bool {
        self.can_send_videos
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send videos"]
    pub fn set_can_send_videos<'a>(&'a mut self, can_send_videos: bool) -> &'a mut Self {
        self.can_send_videos = can_send_videos;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    pub fn get_can_send_video_notes<'a>(&'a self) -> bool {
        self.can_send_video_notes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    pub fn get_can_send_video_notes_ref<'a>(&'a self) -> bool {
        self.can_send_video_notes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send video notes"]
    pub fn set_can_send_video_notes<'a>(&'a mut self, can_send_video_notes: bool) -> &'a mut Self {
        self.can_send_video_notes = can_send_video_notes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    pub fn get_can_send_voice_notes<'a>(&'a self) -> bool {
        self.can_send_voice_notes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    pub fn get_can_send_voice_notes_ref<'a>(&'a self) -> bool {
        self.can_send_voice_notes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send voice notes"]
    pub fn set_can_send_voice_notes<'a>(&'a mut self, can_send_voice_notes: bool) -> &'a mut Self {
        self.can_send_voice_notes = can_send_voice_notes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    pub fn get_can_send_polls<'a>(&'a self) -> bool {
        self.can_send_polls
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    pub fn get_can_send_polls_ref<'a>(&'a self) -> bool {
        self.can_send_polls
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send polls"]
    pub fn set_can_send_polls<'a>(&'a mut self, can_send_polls: bool) -> &'a mut Self {
        self.can_send_polls = can_send_polls;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    pub fn get_can_send_other_messages<'a>(&'a self) -> bool {
        self.can_send_other_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    pub fn get_can_send_other_messages_ref<'a>(&'a self) -> bool {
        self.can_send_other_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to send animations, games, stickers and use inline bots"]
    pub fn set_can_send_other_messages<'a>(
        &'a mut self,
        can_send_other_messages: bool,
    ) -> &'a mut Self {
        self.can_send_other_messages = can_send_other_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    pub fn get_can_add_web_page_previews<'a>(&'a self) -> bool {
        self.can_add_web_page_previews
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    pub fn get_can_add_web_page_previews_ref<'a>(&'a self) -> bool {
        self.can_add_web_page_previews
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to add web page previews to their messages"]
    pub fn set_can_add_web_page_previews<'a>(
        &'a mut self,
        can_add_web_page_previews: bool,
    ) -> &'a mut Self {
        self.can_add_web_page_previews = can_add_web_page_previews;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn get_can_change_info<'a>(&'a self) -> bool {
        self.can_change_info
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn get_can_change_info_ref<'a>(&'a self) -> bool {
        self.can_change_info
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to change the chat title, photo and other settings"]
    pub fn set_can_change_info<'a>(&'a mut self, can_change_info: bool) -> &'a mut Self {
        self.can_change_info = can_change_info;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn get_can_invite_users<'a>(&'a self) -> bool {
        self.can_invite_users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn get_can_invite_users_ref<'a>(&'a self) -> bool {
        self.can_invite_users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to invite new users to the chat"]
    pub fn set_can_invite_users<'a>(&'a mut self, can_invite_users: bool) -> &'a mut Self {
        self.can_invite_users = can_invite_users;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    pub fn get_can_pin_messages<'a>(&'a self) -> bool {
        self.can_pin_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    pub fn get_can_pin_messages_ref<'a>(&'a self) -> bool {
        self.can_pin_messages
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to pin messages"]
    pub fn set_can_pin_messages<'a>(&'a mut self, can_pin_messages: bool) -> &'a mut Self {
        self.can_pin_messages = can_pin_messages;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    pub fn get_can_manage_topics<'a>(&'a self) -> bool {
        self.can_manage_topics
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    pub fn get_can_manage_topics_ref<'a>(&'a self) -> bool {
        self.can_manage_topics
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user is allowed to create forum topics"]
    pub fn set_can_manage_topics<'a>(&'a mut self, can_manage_topics: bool) -> &'a mut Self {
        self.can_manage_topics = can_manage_topics;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    pub fn get_until_date<'a>(&'a self) -> i64 {
        self.until_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    pub fn get_until_date_ref<'a>(&'a self) -> i64 {
        self.until_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"]
    pub fn set_until_date<'a>(&'a mut self, until_date: i64) -> &'a mut Self {
        self.until_date = until_date;
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultArticle {
    pub fn new(id: String, title: String, input_message_content: InputMessageContent) -> Self {
        Self {
            tg_type: "article".to_owned(),
            id,
            title,
            input_message_content,
            reply_markup: None,
            url: None,
            hide_url: None,
            description: None,
            thumbnail_url: None,
            thumbnail_width: None,
            thumbnail_height: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, title, input_message_content, reply_markup, url, hide_url, description, thumbnail_url, thumbnail_width, thumbnail_height)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        InputMessageContent,
        Option<InlineKeyboardMarkup>,
        Option<String>,
        Option<bool>,
        Option<String>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.tg_type,
            self.id,
            self.title,
            self.input_message_content,
            self.reply_markup.map(|reply_markup| reply_markup),
            self.url.map(|url| url),
            self.hide_url.map(|hide_url| hide_url),
            self.description.map(|description| description),
            self.thumbnail_url.map(|thumbnail_url| thumbnail_url),
            self.thumbnail_width.map(|thumbnail_width| thumbnail_width),
            self.thumbnail_height
                .map(|thumbnail_height| thumbnail_height),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    pub fn get_input_message_content<'a>(&'a self) -> Cow<'a, InputMessageContent> {
        Cow::Borrowed(&self.input_message_content)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> &'a InputMessageContent {
        &self.input_message_content
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: InputMessageContent,
    ) -> &'a mut Self {
        self.input_message_content = input_message_content;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    pub fn get_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.url.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    pub fn get_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    pub fn set_url<'a>(&'a mut self, url: Option<String>) -> &'a mut Self {
        self.url = if let Some(url) = url { Some(url) } else { None };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    pub fn get_hide_url<'a>(&'a self) -> Option<bool> {
        self.hide_url.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    pub fn get_hide_url_ref<'a>(&'a self) -> Option<bool> {
        self.hide_url.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    pub fn set_hide_url<'a>(&'a mut self, hide_url: Option<bool>) -> &'a mut Self {
        self.hide_url = if let Some(hide_url) = hide_url {
            Some(hide_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_url
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self {
        self.thumbnail_url = if let Some(thumbnail_url) = thumbnail_url {
            Some(thumbnail_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn get_thumbnail_width<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self {
        self.thumbnail_width = if let Some(thumbnail_width) = thumbnail_width {
            Some(thumbnail_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn get_thumbnail_height<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self {
        self.thumbnail_height = if let Some(thumbnail_height) = thumbnail_height {
            Some(thumbnail_height)
        } else {
            None
        };
        self
    }
}
impl TraitPassportElementErrorDataField for PassportElementErrorDataField {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, field_name, data_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String, String) {
        (
            self.source,
            self.tg_type,
            self.field_name,
            self.data_hash,
            self.message,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    fn get_field_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.field_name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    fn get_field_name_ref<'a>(&'a self) -> &'a str {
        self.field_name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    fn set_field_name<'a>(&'a mut self, field_name: String) -> &'a mut Self {
        self.field_name = field_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    fn get_data_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.data_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    fn get_data_hash_ref<'a>(&'a self) -> &'a str {
        self.data_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    fn set_data_hash<'a>(&'a mut self, data_hash: String) -> &'a mut Self {
        self.data_hash = data_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
impl TraitPassportElementErrorFrontSide for PassportElementErrorFrontSide {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.file_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be front_side"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    fn get_file_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    fn get_file_hash_ref<'a>(&'a self) -> &'a str {
        self.file_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the front side of the document"]
    fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
impl TraitPassportElementErrorReverseSide for PassportElementErrorReverseSide {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.file_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    fn get_file_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    fn get_file_hash_ref<'a>(&'a self) -> &'a str {
        self.file_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
impl TraitPassportElementErrorSelfie for PassportElementErrorSelfie {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.file_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be selfie"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    fn get_file_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    fn get_file_hash_ref<'a>(&'a self) -> &'a str {
        self.file_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the selfie"]
    fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
impl TraitPassportElementErrorFile for PassportElementErrorFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.file_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be file"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn get_file_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn get_file_hash_ref<'a>(&'a self) -> &'a str {
        self.file_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
impl TraitPassportElementErrorFiles for PassportElementErrorFiles {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hashes, message)"]
    fn into_tuple(self) -> (String, String, Vec<String>, String) {
        (self.source, self.tg_type, self.file_hashes, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be files"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn get_file_hashes<'a>(&'a self) -> Cow<'a, Vec<String>> {
        Cow::Borrowed(&self.file_hashes)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn get_file_hashes_ref<'a>(&'a self) -> &'a Vec<String> {
        &self.file_hashes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn set_file_hashes<'a>(&'a mut self, file_hashes: Vec<String>) -> &'a mut Self {
        self.file_hashes = file_hashes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
impl TraitPassportElementErrorTranslationFile for PassportElementErrorTranslationFile {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.file_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn get_file_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn get_file_hash_ref<'a>(&'a self) -> &'a str {
        self.file_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
impl TraitPassportElementErrorTranslationFiles for PassportElementErrorTranslationFiles {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hashes, message)"]
    fn into_tuple(self) -> (String, String, Vec<String>, String) {
        (self.source, self.tg_type, self.file_hashes, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_files"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn get_file_hashes<'a>(&'a self) -> Cow<'a, Vec<String>> {
        Cow::Borrowed(&self.file_hashes)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn get_file_hashes_ref<'a>(&'a self) -> &'a Vec<String> {
        &self.file_hashes
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of base64-encoded file hashes"]
    fn set_file_hashes<'a>(&'a mut self, file_hashes: Vec<String>) -> &'a mut Self {
        self.file_hashes = file_hashes;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
impl TraitPassportElementErrorUnspecified for PassportElementErrorUnspecified {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, element_hash, message)"]
    fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.element_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    fn get_element_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.element_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    fn get_element_hash_ref<'a>(&'a self) -> &'a str {
        self.element_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    fn set_element_hash<'a>(&'a mut self, element_hash: String) -> &'a mut Self {
        self.element_hash = element_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
#[allow(dead_code)]
impl GeneralForumTopicHidden {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    pub fn into_tuple(self) {
        ()
    }
}
#[allow(dead_code)]
impl SentWebAppMessage {
    pub fn new() -> Self {
        Self {
            inline_message_id: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (inline_message_id)"]
    pub fn into_tuple(self) -> Option<String> {
        self.inline_message_id
            .map(|inline_message_id| inline_message_id)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."]
    pub fn get_inline_message_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.inline_message_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."]
    pub fn get_inline_message_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.inline_message_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."]
    pub fn set_inline_message_id<'a>(
        &'a mut self,
        inline_message_id: Option<String>,
    ) -> &'a mut Self {
        self.inline_message_id = if let Some(inline_message_id) = inline_message_id {
            Some(inline_message_id)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl VideoChatParticipantsInvited {
    pub fn new(users: Vec<User>) -> Self {
        Self { users }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (users)"]
    pub fn into_tuple(self) -> Vec<User> {
        self.users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New members that were invited to the video chat"]
    pub fn get_users<'a>(&'a self) -> Cow<'a, Vec<User>> {
        Cow::Borrowed(&self.users)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New members that were invited to the video chat"]
    pub fn get_users_ref<'a>(&'a self) -> &'a Vec<User> {
        &self.users
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New members that were invited to the video chat"]
    pub fn set_users<'a>(&'a mut self, users: Vec<User>) -> &'a mut Self {
        self.users = users;
        self
    }
}
#[allow(dead_code)]
impl InlineKeyboardButton {
    pub fn new(text: String) -> Self {
        Self {
            text,
            url: None,
            callback_data: None,
            web_app: None,
            login_url: None,
            switch_inline_query: None,
            switch_inline_query_current_chat: None,
            switch_inline_query_chosen_chat: None,
            callback_game: None,
            pay: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (text, url, callback_data, web_app, login_url, switch_inline_query, switch_inline_query_current_chat, switch_inline_query_chosen_chat, callback_game, pay)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        Option<String>,
        Option<String>,
        Option<WebAppInfo>,
        Option<LoginUrl>,
        Option<String>,
        Option<String>,
        Option<SwitchInlineQueryChosenChat>,
        Option<CallbackGame>,
        Option<bool>,
    ) {
        (
            self.text,
            self.url.map(|url| url),
            self.callback_data.map(|callback_data| callback_data),
            self.web_app.map(|web_app| web_app),
            self.login_url.map(|login_url| login_url),
            self.switch_inline_query
                .map(|switch_inline_query| switch_inline_query),
            self.switch_inline_query_current_chat
                .map(|switch_inline_query_current_chat| switch_inline_query_current_chat),
            self.switch_inline_query_chosen_chat
                .map(|switch_inline_query_chosen_chat| switch_inline_query_chosen_chat),
            self.callback_game.map(|callback_game| callback_game),
            self.pay.map(|pay| pay),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    pub fn get_text<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.text.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    pub fn get_text_ref<'a>(&'a self) -> &'a str {
        self.text.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Label text on the button"]
    pub fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."]
    pub fn get_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.url.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."]
    pub fn get_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."]
    pub fn set_url<'a>(&'a mut self, url: Option<String>) -> &'a mut Self {
        self.url = if let Some(url) = url { Some(url) } else { None };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"]
    pub fn get_callback_data<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.callback_data
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"]
    pub fn get_callback_data_ref<'a>(&'a self) -> Option<&'a str> {
        self.callback_data.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"]
    pub fn set_callback_data<'a>(&'a mut self, callback_data: Option<String>) -> &'a mut Self {
        self.callback_data = if let Some(callback_data) = callback_data {
            Some(callback_data)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."]
    pub fn get_web_app<'a>(&'a self) -> Option<Cow<'a, WebAppInfo>> {
        self.web_app.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."]
    pub fn get_web_app_ref<'a>(&'a self) -> Option<&'a WebAppInfo> {
        self.web_app.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."]
    pub fn set_web_app<'a>(&'a mut self, web_app: Option<WebAppInfo>) -> &'a mut Self {
        self.web_app = if let Some(web_app) = web_app {
            Some(web_app)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."]
    pub fn get_login_url<'a>(&'a self) -> Option<Cow<'a, LoginUrl>> {
        self.login_url.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."]
    pub fn get_login_url_ref<'a>(&'a self) -> Option<&'a LoginUrl> {
        self.login_url.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."]
    pub fn set_login_url<'a>(&'a mut self, login_url: Option<LoginUrl>) -> &'a mut Self {
        self.login_url = if let Some(login_url) = login_url {
            Some(login_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."]
    pub fn get_switch_inline_query<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.switch_inline_query
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."]
    pub fn get_switch_inline_query_ref<'a>(&'a self) -> Option<&'a str> {
        self.switch_inline_query.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."]
    pub fn set_switch_inline_query<'a>(
        &'a mut self,
        switch_inline_query: Option<String>,
    ) -> &'a mut Self {
        self.switch_inline_query = if let Some(switch_inline_query) = switch_inline_query {
            Some(switch_inline_query)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."]
    pub fn get_switch_inline_query_current_chat<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.switch_inline_query_current_chat
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."]
    pub fn get_switch_inline_query_current_chat_ref<'a>(&'a self) -> Option<&'a str> {
        self.switch_inline_query_current_chat
            .as_ref()
            .map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."]
    pub fn set_switch_inline_query_current_chat<'a>(
        &'a mut self,
        switch_inline_query_current_chat: Option<String>,
    ) -> &'a mut Self {
        self.switch_inline_query_current_chat =
            if let Some(switch_inline_query_current_chat) = switch_inline_query_current_chat {
                Some(switch_inline_query_current_chat)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"]
    pub fn get_switch_inline_query_chosen_chat<'a>(
        &'a self,
    ) -> Option<Cow<'a, SwitchInlineQueryChosenChat>> {
        self.switch_inline_query_chosen_chat
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"]
    pub fn get_switch_inline_query_chosen_chat_ref<'a>(
        &'a self,
    ) -> Option<&'a SwitchInlineQueryChosenChat> {
        self.switch_inline_query_chosen_chat.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"]
    pub fn set_switch_inline_query_chosen_chat<'a>(
        &'a mut self,
        switch_inline_query_chosen_chat: Option<SwitchInlineQueryChosenChat>,
    ) -> &'a mut Self {
        self.switch_inline_query_chosen_chat =
            if let Some(switch_inline_query_chosen_chat) = switch_inline_query_chosen_chat {
                Some(switch_inline_query_chosen_chat)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."]
    pub fn get_callback_game<'a>(&'a self) -> Option<Cow<'a, CallbackGame>> {
        self.callback_game.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."]
    pub fn get_callback_game_ref<'a>(&'a self) -> Option<&'a CallbackGame> {
        self.callback_game.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."]
    pub fn set_callback_game<'a>(
        &'a mut self,
        callback_game: Option<CallbackGame>,
    ) -> &'a mut Self {
        self.callback_game = if let Some(callback_game) = callback_game {
            Some(callback_game)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."]
    pub fn get_pay<'a>(&'a self) -> Option<bool> {
        self.pay.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."]
    pub fn get_pay_ref<'a>(&'a self) -> Option<bool> {
        self.pay.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."]
    pub fn set_pay<'a>(&'a mut self, pay: Option<bool>) -> &'a mut Self {
        self.pay = if let Some(pay) = pay { Some(pay) } else { None };
        self
    }
}
impl TraitInlineQueryResultCachedAudio for InlineQueryResultCachedAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, audio_file_id, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.audio_file_id,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    fn get_audio_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.audio_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    fn get_audio_file_id_ref<'a>(&'a self) -> &'a str {
        self.audio_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    fn set_audio_file_id<'a>(&'a mut self, audio_file_id: String) -> &'a mut Self {
        self.audio_file_id = audio_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultCachedDocument for InlineQueryResultCachedDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, title, document_file_id, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.title,
            self.document_file_id,
            self.description.map(|description| description),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    fn get_document_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.document_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    fn get_document_file_id_ref<'a>(&'a self) -> &'a str {
        self.document_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the file"]
    fn set_document_file_id<'a>(&'a mut self, document_file_id: String) -> &'a mut Self {
        self.document_file_id = document_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultCachedGif for InlineQueryResultCachedGif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, gif_file_id, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.gif_file_id,
            self.title.map(|title| title),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    fn get_gif_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.gif_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    fn get_gif_file_id_ref<'a>(&'a self) -> &'a str {
        self.gif_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    fn set_gif_file_id<'a>(&'a mut self, gif_file_id: String) -> &'a mut Self {
        self.gif_file_id = gif_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultCachedMpeg4Gif for InlineQueryResultCachedMpeg4Gif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, mpeg4_file_id, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.mpeg_4_file_id,
            self.title.map(|title| title),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    fn get_mpeg_4_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.mpeg_4_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    fn get_mpeg_4_file_id_ref<'a>(&'a self) -> &'a str {
        self.mpeg_4_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    fn set_mpeg_4_file_id<'a>(&'a mut self, mpeg_4_file_id: String) -> &'a mut Self {
        self.mpeg_4_file_id = mpeg_4_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultCachedPhoto for InlineQueryResultCachedPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, photo_file_id, title, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.photo_file_id,
            self.title.map(|title| title),
            self.description.map(|description| description),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    fn get_photo_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.photo_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    fn get_photo_file_id_ref<'a>(&'a self) -> &'a str {
        self.photo_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the photo"]
    fn set_photo_file_id<'a>(&'a mut self, photo_file_id: String) -> &'a mut Self {
        self.photo_file_id = photo_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultCachedSticker for InlineQueryResultCachedSticker {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, sticker_file_id, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.sticker_file_id,
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be sticker"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    fn get_sticker_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.sticker_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    fn get_sticker_file_id_ref<'a>(&'a self) -> &'a str {
        self.sticker_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier of the sticker"]
    fn set_sticker_file_id<'a>(&'a mut self, sticker_file_id: String) -> &'a mut Self {
        self.sticker_file_id = sticker_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the sticker"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultCachedVideo for InlineQueryResultCachedVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, video_file_id, title, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.video_file_id,
            self.title,
            self.description.map(|description| description),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    fn get_video_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.video_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    fn get_video_file_id_ref<'a>(&'a self) -> &'a str {
        self.video_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    fn set_video_file_id<'a>(&'a mut self, video_file_id: String) -> &'a mut Self {
        self.video_file_id = video_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultCachedVoice for InlineQueryResultCachedVoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, voice_file_id, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.voice_file_id,
            self.title,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    fn get_voice_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.voice_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    fn get_voice_file_id_ref<'a>(&'a self) -> &'a str {
        self.voice_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the voice message"]
    fn set_voice_file_id<'a>(&'a mut self, voice_file_id: String) -> &'a mut Self {
        self.voice_file_id = voice_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Voice message title"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice message"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultArticle for InlineQueryResultArticle {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, title, input_message_content, reply_markup, url, hide_url, description, thumbnail_url, thumbnail_width, thumbnail_height)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        InputMessageContent,
        Option<InlineKeyboardMarkup>,
        Option<String>,
        Option<bool>,
        Option<String>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.tg_type,
            self.id,
            self.title,
            self.input_message_content,
            self.reply_markup.map(|reply_markup| reply_markup),
            self.url.map(|url| url),
            self.hide_url.map(|hide_url| hide_url),
            self.description.map(|description| description),
            self.thumbnail_url.map(|thumbnail_url| thumbnail_url),
            self.thumbnail_width.map(|thumbnail_width| thumbnail_width),
            self.thumbnail_height
                .map(|thumbnail_height| thumbnail_height),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be article"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the result"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    fn get_input_message_content<'a>(&'a self) -> Cow<'a, InputMessageContent> {
        Cow::Borrowed(&self.input_message_content)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    fn get_input_message_content_ref<'a>(&'a self) -> &'a InputMessageContent {
        &self.input_message_content
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Content of the message to be sent"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: InputMessageContent,
    ) -> &'a mut Self {
        self.input_message_content = input_message_content;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    fn get_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.url.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    fn get_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the result"]
    fn set_url<'a>(&'a mut self, url: Option<String>) -> &'a mut Self {
        self.url = if let Some(url) = url { Some(url) } else { None };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    fn get_hide_url<'a>(&'a self) -> Option<bool> {
        self.hide_url.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    fn get_hide_url_ref<'a>(&'a self) -> Option<bool> {
        self.hide_url.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you don't want the URL to be shown in the message"]
    fn set_hide_url<'a>(&'a mut self, hide_url: Option<bool>) -> &'a mut Self {
        self.hide_url = if let Some(hide_url) = hide_url {
            Some(hide_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_url
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self {
        self.thumbnail_url = if let Some(thumbnail_url) = thumbnail_url {
            Some(thumbnail_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self {
        self.thumbnail_width = if let Some(thumbnail_width) = thumbnail_width {
            Some(thumbnail_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self {
        self.thumbnail_height = if let Some(thumbnail_height) = thumbnail_height {
            Some(thumbnail_height)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultAudio for InlineQueryResultAudio {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, audio_url, title, caption, parse_mode, caption_entities, performer, audio_duration, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<String>,
        Option<i64>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.audio_url,
            self.title,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.performer.map(|performer| performer),
            self.audio_duration.map(|audio_duration| audio_duration),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    fn get_audio_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.audio_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    fn get_audio_url_ref<'a>(&'a self) -> &'a str {
        self.audio_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    fn set_audio_url<'a>(&'a mut self, audio_url: String) -> &'a mut Self {
        self.audio_url = audio_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    fn get_performer<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.performer.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    fn get_performer_ref<'a>(&'a self) -> Option<&'a str> {
        self.performer.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    fn set_performer<'a>(&'a mut self, performer: Option<String>) -> &'a mut Self {
        self.performer = if let Some(performer) = performer {
            Some(performer)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    fn get_audio_duration<'a>(&'a self) -> Option<i64> {
        self.audio_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    fn get_audio_duration_ref<'a>(&'a self) -> Option<i64> {
        self.audio_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    fn set_audio_duration<'a>(&'a mut self, audio_duration: Option<i64>) -> &'a mut Self {
        self.audio_duration = if let Some(audio_duration) = audio_duration {
            Some(audio_duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultContact for InlineQueryResultContact {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, phone_number, first_name, last_name, vcard, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.tg_type,
            self.id,
            self.phone_number,
            self.first_name,
            self.last_name.map(|last_name| last_name),
            self.vcard.map(|vcard| vcard),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
            self.thumbnail_url.map(|thumbnail_url| thumbnail_url),
            self.thumbnail_width.map(|thumbnail_width| thumbnail_width),
            self.thumbnail_height
                .map(|thumbnail_height| thumbnail_height),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be contact"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn get_phone_number<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.phone_number.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn get_phone_number_ref<'a>(&'a self) -> &'a str {
        self.phone_number.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn set_phone_number<'a>(&'a mut self, phone_number: String) -> &'a mut Self {
        self.phone_number = phone_number;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn get_first_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.first_name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn get_first_name_ref<'a>(&'a self) -> &'a str {
        self.first_name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn set_first_name<'a>(&'a mut self, first_name: String) -> &'a mut Self {
        self.first_name = first_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.last_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn get_last_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.last_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self {
        self.last_name = if let Some(last_name) = last_name {
            Some(last_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn get_vcard<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.vcard.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn get_vcard_ref<'a>(&'a self) -> Option<&'a str> {
        self.vcard.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn set_vcard<'a>(&'a mut self, vcard: Option<String>) -> &'a mut Self {
        self.vcard = if let Some(vcard) = vcard {
            Some(vcard)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the contact"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_url
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self {
        self.thumbnail_url = if let Some(thumbnail_url) = thumbnail_url {
            Some(thumbnail_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self {
        self.thumbnail_width = if let Some(thumbnail_width) = thumbnail_width {
            Some(thumbnail_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self {
        self.thumbnail_height = if let Some(thumbnail_height) = thumbnail_height {
            Some(thumbnail_height)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultGame for InlineQueryResultGame {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, game_short_name, reply_markup)"]
    fn into_tuple(self) -> (String, String, String, Option<InlineKeyboardMarkup>) {
        (
            self.tg_type,
            self.id,
            self.game_short_name,
            self.reply_markup.map(|reply_markup| reply_markup),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be game"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    fn get_game_short_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.game_short_name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    fn get_game_short_name_ref<'a>(&'a self) -> &'a str {
        self.game_short_name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Short name of the game"]
    fn set_game_short_name<'a>(&'a mut self, game_short_name: String) -> &'a mut Self {
        self.game_short_name = game_short_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultDocument for InlineQueryResultDocument {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, title, caption, parse_mode, caption_entities, document_url, mime_type, description, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        String,
        String,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.tg_type,
            self.id,
            self.title,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.document_url,
            self.mime_type,
            self.description.map(|description| description),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
            self.thumbnail_url.map(|thumbnail_url| thumbnail_url),
            self.thumbnail_width.map(|thumbnail_width| thumbnail_width),
            self.thumbnail_height
                .map(|thumbnail_height| thumbnail_height),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    fn get_document_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.document_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    fn get_document_url_ref<'a>(&'a self) -> &'a str {
        self.document_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    fn set_document_url<'a>(&'a mut self, document_url: String) -> &'a mut Self {
        self.document_url = document_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    fn get_mime_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.mime_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    fn get_mime_type_ref<'a>(&'a self) -> &'a str {
        self.mime_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    fn set_mime_type<'a>(&'a mut self, mime_type: String) -> &'a mut Self {
        self.mime_type = mime_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_url
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self {
        self.thumbnail_url = if let Some(thumbnail_url) = thumbnail_url {
            Some(thumbnail_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self {
        self.thumbnail_width = if let Some(thumbnail_width) = thumbnail_width {
            Some(thumbnail_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self {
        self.thumbnail_height = if let Some(thumbnail_height) = thumbnail_height {
            Some(thumbnail_height)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultGif for InlineQueryResultGif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, gif_url, gif_width, gif_height, gif_duration, thumbnail_url, thumbnail_mime_type, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.gif_url,
            self.gif_width.map(|gif_width| gif_width),
            self.gif_height.map(|gif_height| gif_height),
            self.gif_duration.map(|gif_duration| gif_duration),
            self.thumbnail_url,
            self.thumbnail_mime_type
                .map(|thumbnail_mime_type| thumbnail_mime_type),
            self.title.map(|title| title),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    fn get_gif_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.gif_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    fn get_gif_url_ref<'a>(&'a self) -> &'a str {
        self.gif_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    fn set_gif_url<'a>(&'a mut self, gif_url: String) -> &'a mut Self {
        self.gif_url = gif_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    fn get_gif_width<'a>(&'a self) -> Option<i64> {
        self.gif_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    fn get_gif_width_ref<'a>(&'a self) -> Option<i64> {
        self.gif_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    fn set_gif_width<'a>(&'a mut self, gif_width: Option<i64>) -> &'a mut Self {
        self.gif_width = if let Some(gif_width) = gif_width {
            Some(gif_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    fn get_gif_height<'a>(&'a self) -> Option<i64> {
        self.gif_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    fn get_gif_height_ref<'a>(&'a self) -> Option<i64> {
        self.gif_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    fn set_gif_height<'a>(&'a mut self, gif_height: Option<i64>) -> &'a mut Self {
        self.gif_height = if let Some(gif_height) = gif_height {
            Some(gif_height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    fn get_gif_duration<'a>(&'a self) -> Option<i64> {
        self.gif_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    fn get_gif_duration_ref<'a>(&'a self) -> Option<i64> {
        self.gif_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    fn set_gif_duration<'a>(&'a mut self, gif_duration: Option<i64>) -> &'a mut Self {
        self.gif_duration = if let Some(gif_duration) = gif_duration {
            Some(gif_duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.thumbnail_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str {
        self.thumbnail_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn get_thumbnail_mime_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_mime_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn get_thumbnail_mime_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_mime_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn set_thumbnail_mime_type<'a>(
        &'a mut self,
        thumbnail_mime_type: Option<String>,
    ) -> &'a mut Self {
        self.thumbnail_mime_type = if let Some(thumbnail_mime_type) = thumbnail_mime_type {
            Some(thumbnail_mime_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultLocation for InlineQueryResultLocation {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, latitude, longitude, title, horizontal_accuracy, live_period, heading, proximity_alert_radius, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        String,
        Option<::ordered_float::OrderedFloat<f64>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.tg_type,
            self.id,
            self.latitude,
            self.longitude,
            self.title,
            self.horizontal_accuracy
                .map(|horizontal_accuracy| horizontal_accuracy),
            self.live_period.map(|live_period| live_period),
            self.heading.map(|heading| heading),
            self.proximity_alert_radius
                .map(|proximity_alert_radius| proximity_alert_radius),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
            self.thumbnail_url.map(|thumbnail_url| thumbnail_url),
            self.thumbnail_width.map(|thumbnail_width| thumbnail_width),
            self.thumbnail_height
                .map(|thumbnail_height| thumbnail_height),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    fn set_latitude<'a>(
        &'a mut self,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn get_horizontal_accuracy<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>> {
        self.horizontal_accuracy.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn get_horizontal_accuracy_ref<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>> {
        self.horizontal_accuracy.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn set_horizontal_accuracy<'a>(
        &'a mut self,
        horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    ) -> &'a mut Self {
        self.horizontal_accuracy = if let Some(horizontal_accuracy) = horizontal_accuracy {
            Some(horizontal_accuracy)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn get_live_period<'a>(&'a self) -> Option<i64> {
        self.live_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn get_live_period_ref<'a>(&'a self) -> Option<i64> {
        self.live_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn set_live_period<'a>(&'a mut self, live_period: Option<i64>) -> &'a mut Self {
        self.live_period = if let Some(live_period) = live_period {
            Some(live_period)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn get_heading<'a>(&'a self) -> Option<i64> {
        self.heading.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn get_heading_ref<'a>(&'a self) -> Option<i64> {
        self.heading.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn set_heading<'a>(&'a mut self, heading: Option<i64>) -> &'a mut Self {
        self.heading = if let Some(heading) = heading {
            Some(heading)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn get_proximity_alert_radius<'a>(&'a self) -> Option<i64> {
        self.proximity_alert_radius.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn get_proximity_alert_radius_ref<'a>(&'a self) -> Option<i64> {
        self.proximity_alert_radius.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn set_proximity_alert_radius<'a>(
        &'a mut self,
        proximity_alert_radius: Option<i64>,
    ) -> &'a mut Self {
        self.proximity_alert_radius = if let Some(proximity_alert_radius) = proximity_alert_radius {
            Some(proximity_alert_radius)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_url
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self {
        self.thumbnail_url = if let Some(thumbnail_url) = thumbnail_url {
            Some(thumbnail_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self {
        self.thumbnail_width = if let Some(thumbnail_width) = thumbnail_width {
            Some(thumbnail_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self {
        self.thumbnail_height = if let Some(thumbnail_height) = thumbnail_height {
            Some(thumbnail_height)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultMpeg4Gif for InlineQueryResultMpeg4Gif {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, mpeg4_url, mpeg4_width, mpeg4_height, mpeg4_duration, thumbnail_url, thumbnail_mime_type, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.mpeg_4_url,
            self.mpeg_4_width.map(|mpeg_4_width| mpeg_4_width),
            self.mpeg_4_height.map(|mpeg_4_height| mpeg_4_height),
            self.mpeg_4_duration.map(|mpeg_4_duration| mpeg_4_duration),
            self.thumbnail_url,
            self.thumbnail_mime_type
                .map(|thumbnail_mime_type| thumbnail_mime_type),
            self.title.map(|title| title),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    fn get_mpeg_4_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.mpeg_4_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    fn get_mpeg_4_url_ref<'a>(&'a self) -> &'a str {
        self.mpeg_4_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    fn set_mpeg_4_url<'a>(&'a mut self, mpeg_4_url: String) -> &'a mut Self {
        self.mpeg_4_url = mpeg_4_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_mpeg_4_width<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_mpeg_4_width_ref<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn set_mpeg_4_width<'a>(&'a mut self, mpeg_4_width: Option<i64>) -> &'a mut Self {
        self.mpeg_4_width = if let Some(mpeg_4_width) = mpeg_4_width {
            Some(mpeg_4_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_mpeg_4_height<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_mpeg_4_height_ref<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn set_mpeg_4_height<'a>(&'a mut self, mpeg_4_height: Option<i64>) -> &'a mut Self {
        self.mpeg_4_height = if let Some(mpeg_4_height) = mpeg_4_height {
            Some(mpeg_4_height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_mpeg_4_duration<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_mpeg_4_duration_ref<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn set_mpeg_4_duration<'a>(&'a mut self, mpeg_4_duration: Option<i64>) -> &'a mut Self {
        self.mpeg_4_duration = if let Some(mpeg_4_duration) = mpeg_4_duration {
            Some(mpeg_4_duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.thumbnail_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str {
        self.thumbnail_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn get_thumbnail_mime_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_mime_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn get_thumbnail_mime_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_mime_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    fn set_thumbnail_mime_type<'a>(
        &'a mut self,
        thumbnail_mime_type: Option<String>,
    ) -> &'a mut Self {
        self.thumbnail_mime_type = if let Some(thumbnail_mime_type) = thumbnail_mime_type {
            Some(thumbnail_mime_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultPhoto for InlineQueryResultPhoto {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, photo_url, thumbnail_url, photo_width, photo_height, title, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<i64>,
        Option<i64>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.photo_url,
            self.thumbnail_url,
            self.photo_width.map(|photo_width| photo_width),
            self.photo_height.map(|photo_height| photo_height),
            self.title.map(|title| title),
            self.description.map(|description| description),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    fn get_photo_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.photo_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    fn get_photo_url_ref<'a>(&'a self) -> &'a str {
        self.photo_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    fn set_photo_url<'a>(&'a mut self, photo_url: String) -> &'a mut Self {
        self.photo_url = photo_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.thumbnail_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str {
        self.thumbnail_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    fn get_photo_width<'a>(&'a self) -> Option<i64> {
        self.photo_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    fn get_photo_width_ref<'a>(&'a self) -> Option<i64> {
        self.photo_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    fn set_photo_width<'a>(&'a mut self, photo_width: Option<i64>) -> &'a mut Self {
        self.photo_width = if let Some(photo_width) = photo_width {
            Some(photo_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    fn get_photo_height<'a>(&'a self) -> Option<i64> {
        self.photo_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    fn get_photo_height_ref<'a>(&'a self) -> Option<i64> {
        self.photo_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    fn set_photo_height<'a>(&'a mut self, photo_height: Option<i64>) -> &'a mut Self {
        self.photo_height = if let Some(photo_height) = photo_height {
            Some(photo_height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultVenue for InlineQueryResultVenue {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, latitude, longitude, title, address, foursquare_id, foursquare_type, google_place_id, google_place_type, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.tg_type,
            self.id,
            self.latitude,
            self.longitude,
            self.title,
            self.address,
            self.foursquare_id.map(|foursquare_id| foursquare_id),
            self.foursquare_type.map(|foursquare_type| foursquare_type),
            self.google_place_id.map(|google_place_id| google_place_id),
            self.google_place_type
                .map(|google_place_type| google_place_type),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
            self.thumbnail_url.map(|thumbnail_url| thumbnail_url),
            self.thumbnail_width.map(|thumbnail_width| thumbnail_width),
            self.thumbnail_height
                .map(|thumbnail_height| thumbnail_height),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be venue"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue location in degrees"]
    fn set_latitude<'a>(
        &'a mut self,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue location in degrees"]
    fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the venue"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn get_address<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.address.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn get_address_ref<'a>(&'a self) -> &'a str {
        self.address.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn set_address<'a>(&'a mut self, address: String) -> &'a mut Self {
        self.address = address;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    fn get_foursquare_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.foursquare_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    fn get_foursquare_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.foursquare_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue if known"]
    fn set_foursquare_id<'a>(&'a mut self, foursquare_id: Option<String>) -> &'a mut Self {
        self.foursquare_id = if let Some(foursquare_id) = foursquare_id {
            Some(foursquare_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn get_foursquare_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.foursquare_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn get_foursquare_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.foursquare_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn set_foursquare_type<'a>(&'a mut self, foursquare_type: Option<String>) -> &'a mut Self {
        self.foursquare_type = if let Some(foursquare_type) = foursquare_type {
            Some(foursquare_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn get_google_place_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.google_place_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn get_google_place_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.google_place_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn set_google_place_id<'a>(&'a mut self, google_place_id: Option<String>) -> &'a mut Self {
        self.google_place_id = if let Some(google_place_id) = google_place_id {
            Some(google_place_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn get_google_place_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.google_place_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn get_google_place_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.google_place_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn set_google_place_type<'a>(&'a mut self, google_place_type: Option<String>) -> &'a mut Self {
        self.google_place_type = if let Some(google_place_type) = google_place_type {
            Some(google_place_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the venue"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_url
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self {
        self.thumbnail_url = if let Some(thumbnail_url) = thumbnail_url {
            Some(thumbnail_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self {
        self.thumbnail_width = if let Some(thumbnail_width) = thumbnail_width {
            Some(thumbnail_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self {
        self.thumbnail_height = if let Some(thumbnail_height) = thumbnail_height {
            Some(thumbnail_height)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultVideo for InlineQueryResultVideo {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, video_url, mime_type, thumbnail_url, title, caption, parse_mode, caption_entities, video_width, video_height, video_duration, description, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.video_url,
            self.mime_type,
            self.thumbnail_url,
            self.title,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.video_width.map(|video_width| video_width),
            self.video_height.map(|video_height| video_height),
            self.video_duration.map(|video_duration| video_duration),
            self.description.map(|description| description),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    fn get_video_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.video_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    fn get_video_url_ref<'a>(&'a self) -> &'a str {
        self.video_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the embedded video player or video file"]
    fn set_video_url<'a>(&'a mut self, video_url: String) -> &'a mut Self {
        self.video_url = video_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    fn get_mime_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.mime_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    fn get_mime_type_ref<'a>(&'a self) -> &'a str {
        self.mime_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the video URL, \"text/html\" or \"video/mp4\""]
    fn set_mime_type<'a>(&'a mut self, mime_type: String) -> &'a mut Self {
        self.mime_type = mime_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.thumbnail_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str {
        self.thumbnail_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail (JPEG only) for the video"]
    fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_video_width<'a>(&'a self) -> Option<i64> {
        self.video_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn get_video_width_ref<'a>(&'a self) -> Option<i64> {
        self.video_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    fn set_video_width<'a>(&'a mut self, video_width: Option<i64>) -> &'a mut Self {
        self.video_width = if let Some(video_width) = video_width {
            Some(video_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_video_height<'a>(&'a self) -> Option<i64> {
        self.video_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn get_video_height_ref<'a>(&'a self) -> Option<i64> {
        self.video_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    fn set_video_height<'a>(&'a mut self, video_height: Option<i64>) -> &'a mut Self {
        self.video_height = if let Some(video_height) = video_height {
            Some(video_height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_video_duration<'a>(&'a self) -> Option<i64> {
        self.video_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn get_video_duration_ref<'a>(&'a self) -> Option<i64> {
        self.video_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    fn set_video_duration<'a>(&'a mut self, video_duration: Option<i64>) -> &'a mut Self {
        self.video_duration = if let Some(video_duration) = video_duration {
            Some(video_duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
impl TraitInlineQueryResultVoice for InlineQueryResultVoice {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, voice_url, title, caption, parse_mode, caption_entities, voice_duration, reply_markup, input_message_content)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.voice_url,
            self.title,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.voice_duration.map(|voice_duration| voice_duration),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    fn get_voice_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.voice_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    fn get_voice_url_ref<'a>(&'a self) -> &'a str {
        self.voice_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    fn set_voice_url<'a>(&'a mut self, voice_url: String) -> &'a mut Self {
        self.voice_url = voice_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    fn get_voice_duration<'a>(&'a self) -> Option<i64> {
        self.voice_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    fn get_voice_duration_ref<'a>(&'a self) -> Option<i64> {
        self.voice_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    fn set_voice_duration<'a>(&'a mut self, voice_duration: Option<i64>) -> &'a mut Self {
        self.voice_duration = if let Some(voice_duration) = voice_duration {
            Some(voice_duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatShared {
    pub fn new(request_id: i64, chat_id: i64) -> Self {
        Self {
            request_id,
            chat_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (request_id, chat_id)"]
    pub fn into_tuple(self) -> (i64, i64) {
        (self.request_id, self.chat_id)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    pub fn get_request_id<'a>(&'a self) -> i64 {
        self.request_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    pub fn get_request_id_ref<'a>(&'a self) -> i64 {
        self.request_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the request"]
    pub fn set_request_id<'a>(&'a mut self, request_id: i64) -> &'a mut Self {
        self.request_id = request_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."]
    pub fn get_chat_id<'a>(&'a self) -> i64 {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."]
    pub fn get_chat_id_ref<'a>(&'a self) -> i64 {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."]
    pub fn set_chat_id<'a>(&'a mut self, chat_id: i64) -> &'a mut Self {
        self.chat_id = chat_id;
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultMpeg4Gif {
    pub fn new(id: String, mpeg_4_url: String, thumbnail_url: String) -> Self {
        Self {
            tg_type: "mpeg4_gif".to_owned(),
            id,
            mpeg_4_url,
            thumbnail_url,
            mpeg_4_width: None,
            mpeg_4_height: None,
            mpeg_4_duration: None,
            thumbnail_mime_type: None,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, mpeg4_url, mpeg4_width, mpeg4_height, mpeg4_duration, thumbnail_url, thumbnail_mime_type, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.mpeg_4_url,
            self.mpeg_4_width.map(|mpeg_4_width| mpeg_4_width),
            self.mpeg_4_height.map(|mpeg_4_height| mpeg_4_height),
            self.mpeg_4_duration.map(|mpeg_4_duration| mpeg_4_duration),
            self.thumbnail_url,
            self.thumbnail_mime_type
                .map(|thumbnail_mime_type| thumbnail_mime_type),
            self.title.map(|title| title),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    pub fn get_mpeg_4_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.mpeg_4_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    pub fn get_mpeg_4_url_ref<'a>(&'a self) -> &'a str {
        self.mpeg_4_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the MPEG4 file. File size must not exceed 1MB"]
    pub fn set_mpeg_4_url<'a>(&'a mut self, mpeg_4_url: String) -> &'a mut Self {
        self.mpeg_4_url = mpeg_4_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn get_mpeg_4_width<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn get_mpeg_4_width_ref<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video width"]
    pub fn set_mpeg_4_width<'a>(&'a mut self, mpeg_4_width: Option<i64>) -> &'a mut Self {
        self.mpeg_4_width = if let Some(mpeg_4_width) = mpeg_4_width {
            Some(mpeg_4_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn get_mpeg_4_height<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn get_mpeg_4_height_ref<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video height"]
    pub fn set_mpeg_4_height<'a>(&'a mut self, mpeg_4_height: Option<i64>) -> &'a mut Self {
        self.mpeg_4_height = if let Some(mpeg_4_height) = mpeg_4_height {
            Some(mpeg_4_height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn get_mpeg_4_duration<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn get_mpeg_4_duration_ref<'a>(&'a self) -> Option<i64> {
        self.mpeg_4_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video duration in seconds"]
    pub fn set_mpeg_4_duration<'a>(&'a mut self, mpeg_4_duration: Option<i64>) -> &'a mut Self {
        self.mpeg_4_duration = if let Some(mpeg_4_duration) = mpeg_4_duration {
            Some(mpeg_4_duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    pub fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.thumbnail_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    pub fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str {
        self.thumbnail_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    pub fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    pub fn get_thumbnail_mime_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_mime_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    pub fn get_thumbnail_mime_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_mime_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    pub fn set_thumbnail_mime_type<'a>(
        &'a mut self,
        thumbnail_mime_type: Option<String>,
    ) -> &'a mut Self {
        self.thumbnail_mime_type = if let Some(thumbnail_mime_type) = thumbnail_mime_type {
            Some(thumbnail_mime_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ShippingAddress {
    pub fn new(
        country_code: String,
        state: String,
        city: String,
        street_line_1: String,
        street_line_2: String,
        post_code: String,
    ) -> Self {
        Self {
            country_code,
            state,
            city,
            street_line_1,
            street_line_2,
            post_code,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (country_code, state, city, street_line1, street_line2, post_code)"]
    pub fn into_tuple(self) -> (String, String, String, String, String, String) {
        (
            self.country_code,
            self.state,
            self.city,
            self.street_line_1,
            self.street_line_2,
            self.post_code,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Two-letter ISO 3166-1 alpha-2 country code"]
    pub fn get_country_code<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.country_code.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Two-letter ISO 3166-1 alpha-2 country code"]
    pub fn get_country_code_ref<'a>(&'a self) -> &'a str {
        self.country_code.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Two-letter ISO 3166-1 alpha-2 country code"]
    pub fn set_country_code<'a>(&'a mut self, country_code: String) -> &'a mut Self {
        self.country_code = country_code;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "State, if applicable"]
    pub fn get_state<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.state.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "State, if applicable"]
    pub fn get_state_ref<'a>(&'a self) -> &'a str {
        self.state.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "State, if applicable"]
    pub fn set_state<'a>(&'a mut self, state: String) -> &'a mut Self {
        self.state = state;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "City"]
    pub fn get_city<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.city.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "City"]
    pub fn get_city_ref<'a>(&'a self) -> &'a str {
        self.city.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "City"]
    pub fn set_city<'a>(&'a mut self, city: String) -> &'a mut Self {
        self.city = city;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "First line for the address"]
    pub fn get_street_line_1<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.street_line_1.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "First line for the address"]
    pub fn get_street_line_1_ref<'a>(&'a self) -> &'a str {
        self.street_line_1.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "First line for the address"]
    pub fn set_street_line_1<'a>(&'a mut self, street_line_1: String) -> &'a mut Self {
        self.street_line_1 = street_line_1;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Second line for the address"]
    pub fn get_street_line_2<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.street_line_2.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Second line for the address"]
    pub fn get_street_line_2_ref<'a>(&'a self) -> &'a str {
        self.street_line_2.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Second line for the address"]
    pub fn set_street_line_2<'a>(&'a mut self, street_line_2: String) -> &'a mut Self {
        self.street_line_2 = street_line_2;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address post code"]
    pub fn get_post_code<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.post_code.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address post code"]
    pub fn get_post_code_ref<'a>(&'a self) -> &'a str {
        self.post_code.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address post code"]
    pub fn set_post_code<'a>(&'a mut self, post_code: String) -> &'a mut Self {
        self.post_code = post_code;
        self
    }
}
#[allow(dead_code)]
impl PassportElementErrorDataField {
    pub fn new(source: String, field_name: String, data_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorDataField".to_owned(),
            source,
            field_name,
            data_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, field_name, data_hash, message)"]
    pub fn into_tuple(self) -> (String, String, String, String, String) {
        (
            self.source,
            self.tg_type,
            self.field_name,
            self.data_hash,
            self.message,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    pub fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    pub fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be data"]
    pub fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the error, one of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\""]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    pub fn get_field_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.field_name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    pub fn get_field_name_ref<'a>(&'a self) -> &'a str {
        self.field_name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the data field which has the error"]
    pub fn set_field_name<'a>(&'a mut self, field_name: String) -> &'a mut Self {
        self.field_name = field_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    pub fn get_data_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.data_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    pub fn get_data_hash_ref<'a>(&'a self) -> &'a str {
        self.data_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded data hash"]
    pub fn set_data_hash<'a>(&'a mut self, data_hash: String) -> &'a mut Self {
        self.data_hash = data_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
#[allow(dead_code)]
impl Dice {
    pub fn new(emoji: String, value: i64) -> Self {
        Self { emoji, value }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (emoji, value)"]
    pub fn into_tuple(self) -> (String, i64) {
        (self.emoji, self.value)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Emoji on which the dice throw animation is based"]
    pub fn get_emoji<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.emoji.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Emoji on which the dice throw animation is based"]
    pub fn get_emoji_ref<'a>(&'a self) -> &'a str {
        self.emoji.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Emoji on which the dice throw animation is based"]
    pub fn set_emoji<'a>(&'a mut self, emoji: String) -> &'a mut Self {
        self.emoji = emoji;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Value of the dice, 1-6 for \"\", \"\" and \"\" base emoji, 1-5 for \"\" and \"\" base emoji, 1-64 for \"\" base emoji"]
    pub fn get_value<'a>(&'a self) -> i64 {
        self.value
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Value of the dice, 1-6 for \"\", \"\" and \"\" base emoji, 1-5 for \"\" and \"\" base emoji, 1-64 for \"\" base emoji"]
    pub fn get_value_ref<'a>(&'a self) -> i64 {
        self.value
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Value of the dice, 1-6 for \"\", \"\" and \"\" base emoji, 1-5 for \"\" and \"\" base emoji, 1-64 for \"\" base emoji"]
    pub fn set_value<'a>(&'a mut self, value: i64) -> &'a mut Self {
        self.value = value;
        self
    }
}
#[allow(dead_code)]
impl PassportElementErrorTranslationFile {
    pub fn new(source: String, file_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorTranslationFile".to_owned(),
            source,
            file_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    pub fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.file_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    pub fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    pub fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be translation_file"]
    pub fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue, one of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\""]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    pub fn get_file_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    pub fn get_file_hash_ref<'a>(&'a self) -> &'a str {
        self.file_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded file hash"]
    pub fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
#[allow(dead_code)]
impl VideoChatScheduled {
    pub fn new(start_date: i64) -> Self {
        Self { start_date }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (start_date)"]
    pub fn into_tuple(self) -> i64 {
        self.start_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"]
    pub fn get_start_date<'a>(&'a self) -> i64 {
        self.start_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"]
    pub fn get_start_date_ref<'a>(&'a self) -> i64 {
        self.start_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"]
    pub fn set_start_date<'a>(&'a mut self, start_date: i64) -> &'a mut Self {
        self.start_date = start_date;
        self
    }
}
#[allow(dead_code)]
impl ShippingOption {
    pub fn new(id: String, title: String, prices: Vec<LabeledPrice>) -> Self {
        Self { id, title, prices }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, title, prices)"]
    pub fn into_tuple(self) -> (String, String, Vec<LabeledPrice>) {
        (self.id, self.title, self.prices)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shipping option identifier"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shipping option identifier"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Shipping option identifier"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option title"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option title"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Option title"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of price portions"]
    pub fn get_prices<'a>(&'a self) -> Cow<'a, Vec<LabeledPrice>> {
        Cow::Borrowed(&self.prices)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of price portions"]
    pub fn get_prices_ref<'a>(&'a self) -> &'a Vec<LabeledPrice> {
        &self.prices
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of price portions"]
    pub fn set_prices<'a>(&'a mut self, prices: Vec<LabeledPrice>) -> &'a mut Self {
        self.prices = prices;
        self
    }
}
#[allow(dead_code)]
impl WebAppInfo {
    pub fn new(url: String) -> Self {
        Self { url }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (url)"]
    pub fn into_tuple(self) -> String {
        self.url
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"]
    pub fn get_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"]
    pub fn get_url_ref<'a>(&'a self) -> &'a str {
        self.url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"]
    pub fn set_url<'a>(&'a mut self, url: String) -> &'a mut Self {
        self.url = url;
        self
    }
}
#[allow(dead_code)]
impl ChatMemberBanned {
    pub fn new(user: User, until_date: i64) -> Self {
        Self { user, until_date }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, until_date)"]
    pub fn into_tuple(self) -> (User, i64) {
        (self.user, self.until_date)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    pub fn get_until_date<'a>(&'a self) -> i64 {
        self.until_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    pub fn get_until_date_ref<'a>(&'a self) -> i64 {
        self.until_date
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"]
    pub fn set_until_date<'a>(&'a mut self, until_date: i64) -> &'a mut Self {
        self.until_date = until_date;
        self
    }
}
#[allow(dead_code)]
impl BotCommandScopeDefault {
    pub fn new() -> Self {
        Self {
            tg_type: "default".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    pub fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be default"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
#[allow(dead_code)]
impl PassportData {
    pub fn new(data: Vec<EncryptedPassportElement>, credentials: EncryptedCredentials) -> Self {
        Self { data, credentials }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (data, credentials)"]
    pub fn into_tuple(self) -> (Vec<EncryptedPassportElement>, EncryptedCredentials) {
        (self.data, self.credentials)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array with information about documents and other Telegram Passport elements that was shared with the bot"]
    pub fn get_data<'a>(&'a self) -> Cow<'a, Vec<EncryptedPassportElement>> {
        Cow::Borrowed(&self.data)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array with information about documents and other Telegram Passport elements that was shared with the bot"]
    pub fn get_data_ref<'a>(&'a self) -> &'a Vec<EncryptedPassportElement> {
        &self.data
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Array with information about documents and other Telegram Passport elements that was shared with the bot"]
    pub fn set_data<'a>(&'a mut self, data: Vec<EncryptedPassportElement>) -> &'a mut Self {
        self.data = data;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Encrypted credentials required to decrypt the data"]
    pub fn get_credentials<'a>(&'a self) -> Cow<'a, EncryptedCredentials> {
        Cow::Borrowed(&self.credentials)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Encrypted credentials required to decrypt the data"]
    pub fn get_credentials_ref<'a>(&'a self) -> &'a EncryptedCredentials {
        &self.credentials
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Encrypted credentials required to decrypt the data"]
    pub fn set_credentials<'a>(&'a mut self, credentials: EncryptedCredentials) -> &'a mut Self {
        self.credentials = credentials;
        self
    }
}
#[allow(dead_code)]
impl InputSticker {
    pub fn new(sticker: InputFile, emoji_list: Vec<String>) -> Self {
        Self {
            sticker,
            emoji_list,
            mask_position: None,
            keywords: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (sticker, emoji_list, mask_position, keywords)"]
    pub fn into_tuple(
        self,
    ) -> (
        InputFile,
        Vec<String>,
        Option<MaskPosition>,
        Option<Vec<String>>,
    ) {
        (
            self.sticker,
            self.emoji_list,
            self.mask_position.map(|mask_position| mask_position),
            self.keywords.map(|keywords| keywords),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_sticker<'a>(&'a self) -> Cow<'a, InputFile> {
        Cow::Borrowed(&self.sticker)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn get_sticker_ref<'a>(&'a self) -> &'a InputFile {
        &self.sticker
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass \"attach://<file_attach_name>\" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"]
    pub fn set_sticker<'a>(&'a mut self, sticker: InputFile) -> &'a mut Self {
        self.sticker = sticker;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of 1-20 emoji associated with the sticker"]
    pub fn get_emoji_list<'a>(&'a self) -> Cow<'a, Vec<String>> {
        Cow::Borrowed(&self.emoji_list)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of 1-20 emoji associated with the sticker"]
    pub fn get_emoji_list_ref<'a>(&'a self) -> &'a Vec<String> {
        &self.emoji_list
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "List of 1-20 emoji associated with the sticker"]
    pub fn set_emoji_list<'a>(&'a mut self, emoji_list: Vec<String>) -> &'a mut Self {
        self.emoji_list = emoji_list;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Position where the mask should be placed on faces. For \"mask\" stickers only."]
    pub fn get_mask_position<'a>(&'a self) -> Option<Cow<'a, MaskPosition>> {
        self.mask_position.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Position where the mask should be placed on faces. For \"mask\" stickers only."]
    pub fn get_mask_position_ref<'a>(&'a self) -> Option<&'a MaskPosition> {
        self.mask_position.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Position where the mask should be placed on faces. For \"mask\" stickers only."]
    pub fn set_mask_position<'a>(
        &'a mut self,
        mask_position: Option<MaskPosition>,
    ) -> &'a mut Self {
        self.mask_position = if let Some(mask_position) = mask_position {
            Some(mask_position)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For \"regular\" and \"custom_emoji\" stickers only."]
    pub fn get_keywords<'a>(&'a self) -> Option<Cow<'a, Vec<String>>> {
        self.keywords.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For \"regular\" and \"custom_emoji\" stickers only."]
    pub fn get_keywords_ref<'a>(&'a self) -> Option<&'a Vec<String>> {
        self.keywords.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For \"regular\" and \"custom_emoji\" stickers only."]
    pub fn set_keywords<'a>(&'a mut self, keywords: Option<Vec<String>>) -> &'a mut Self {
        self.keywords = if let Some(keywords) = keywords {
            Some(keywords)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatLocation {
    pub fn new(location: Location, address: String) -> Self {
        Self { location, address }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (location, address)"]
    pub fn into_tuple(self) -> (Location, String) {
        (self.location, self.address)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The location to which the supergroup is connected. Can't be a live location."]
    pub fn get_location<'a>(&'a self) -> Cow<'a, Location> {
        Cow::Borrowed(&self.location)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The location to which the supergroup is connected. Can't be a live location."]
    pub fn get_location_ref<'a>(&'a self) -> &'a Location {
        &self.location
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The location to which the supergroup is connected. Can't be a live location."]
    pub fn set_location<'a>(&'a mut self, location: Location) -> &'a mut Self {
        self.location = location;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location address; 1-64 characters, as defined by the chat owner"]
    pub fn get_address<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.address.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location address; 1-64 characters, as defined by the chat owner"]
    pub fn get_address_ref<'a>(&'a self) -> &'a str {
        self.address.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location address; 1-64 characters, as defined by the chat owner"]
    pub fn set_address<'a>(&'a mut self, address: String) -> &'a mut Self {
        self.address = address;
        self
    }
}
#[allow(dead_code)]
impl CallbackGame {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    pub fn into_tuple(self) {
        ()
    }
}
#[allow(dead_code)]
impl InlineQueryResultGif {
    pub fn new(id: String, gif_url: String, thumbnail_url: String) -> Self {
        Self {
            tg_type: "gif".to_owned(),
            id,
            gif_url,
            thumbnail_url,
            gif_width: None,
            gif_height: None,
            gif_duration: None,
            thumbnail_mime_type: None,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, gif_url, gif_width, gif_height, gif_duration, thumbnail_url, thumbnail_mime_type, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.gif_url,
            self.gif_width.map(|gif_width| gif_width),
            self.gif_height.map(|gif_height| gif_height),
            self.gif_duration.map(|gif_duration| gif_duration),
            self.thumbnail_url,
            self.thumbnail_mime_type
                .map(|thumbnail_mime_type| thumbnail_mime_type),
            self.title.map(|title| title),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    pub fn get_gif_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.gif_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    pub fn get_gif_url_ref<'a>(&'a self) -> &'a str {
        self.gif_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the GIF file. File size must not exceed 1MB"]
    pub fn set_gif_url<'a>(&'a mut self, gif_url: String) -> &'a mut Self {
        self.gif_url = gif_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    pub fn get_gif_width<'a>(&'a self) -> Option<i64> {
        self.gif_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    pub fn get_gif_width_ref<'a>(&'a self) -> Option<i64> {
        self.gif_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the GIF"]
    pub fn set_gif_width<'a>(&'a mut self, gif_width: Option<i64>) -> &'a mut Self {
        self.gif_width = if let Some(gif_width) = gif_width {
            Some(gif_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    pub fn get_gif_height<'a>(&'a self) -> Option<i64> {
        self.gif_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    pub fn get_gif_height_ref<'a>(&'a self) -> Option<i64> {
        self.gif_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the GIF"]
    pub fn set_gif_height<'a>(&'a mut self, gif_height: Option<i64>) -> &'a mut Self {
        self.gif_height = if let Some(gif_height) = gif_height {
            Some(gif_height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    pub fn get_gif_duration<'a>(&'a self) -> Option<i64> {
        self.gif_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    pub fn get_gif_duration_ref<'a>(&'a self) -> Option<i64> {
        self.gif_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Duration of the GIF in seconds"]
    pub fn set_gif_duration<'a>(&'a mut self, gif_duration: Option<i64>) -> &'a mut Self {
        self.gif_duration = if let Some(gif_duration) = gif_duration {
            Some(gif_duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    pub fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.thumbnail_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    pub fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str {
        self.thumbnail_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"]
    pub fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    pub fn get_thumbnail_mime_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_mime_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    pub fn get_thumbnail_mime_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_mime_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the thumbnail, must be one of \"image/jpeg\", \"image/gif\", or \"video/mp4\". Defaults to \"image/jpeg\""]
    pub fn set_thumbnail_mime_type<'a>(
        &'a mut self,
        thumbnail_mime_type: Option<String>,
    ) -> &'a mut Self {
        self.thumbnail_mime_type = if let Some(thumbnail_mime_type) = thumbnail_mime_type {
            Some(thumbnail_mime_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl BotName {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (name)"]
    pub fn into_tuple(self) -> String {
        self.name
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's name"]
    pub fn get_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's name"]
    pub fn get_name_ref<'a>(&'a self) -> &'a str {
        self.name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The bot's name"]
    pub fn set_name<'a>(&'a mut self, name: String) -> &'a mut Self {
        self.name = name;
        self
    }
}
#[allow(dead_code)]
impl Video {
    pub fn new(
        file_id: String,
        file_unique_id: String,
        width: i64,
        height: i64,
        duration: i64,
    ) -> Self {
        Self {
            file_id,
            file_unique_id,
            width,
            height,
            duration,
            thumbnail: None,
            file_name: None,
            mime_type: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, width, height, duration, thumbnail, file_name, mime_type, file_size)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        i64,
        i64,
        i64,
        Option<PhotoSize>,
        Option<String>,
        Option<String>,
        Option<i64>,
    ) {
        (
            self.file_id,
            self.file_unique_id,
            self.width,
            self.height,
            self.duration,
            self.thumbnail.map(|thumbnail| thumbnail),
            self.file_name.map(|file_name| file_name),
            self.mime_type.map(|mime_type| mime_type),
            self.file_size.map(|file_size| file_size),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id_ref<'a>(&'a self) -> &'a str {
        self.file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    pub fn get_width<'a>(&'a self) -> i64 {
        self.width
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    pub fn get_width_ref<'a>(&'a self) -> i64 {
        self.width
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video width as defined by sender"]
    pub fn set_width<'a>(&'a mut self, width: i64) -> &'a mut Self {
        self.width = width;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    pub fn get_height<'a>(&'a self) -> i64 {
        self.height
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    pub fn get_height_ref<'a>(&'a self) -> i64 {
        self.height
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video height as defined by sender"]
    pub fn set_height<'a>(&'a mut self, height: i64) -> &'a mut Self {
        self.height = height;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn get_duration<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn get_duration_ref<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the video in seconds as defined by sender"]
    pub fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self {
        self.duration = duration;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    pub fn get_thumbnail<'a>(&'a self) -> Option<Cow<'a, PhotoSize>> {
        self.thumbnail.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    pub fn get_thumbnail_ref<'a>(&'a self) -> Option<&'a PhotoSize> {
        self.thumbnail.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Video thumbnail"]
    pub fn set_thumbnail<'a>(&'a mut self, thumbnail: Option<PhotoSize>) -> &'a mut Self {
        self.thumbnail = if let Some(thumbnail) = thumbnail {
            Some(thumbnail)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn get_file_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.file_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn get_file_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.file_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Original filename as defined by sender"]
    pub fn set_file_name<'a>(&'a mut self, file_name: Option<String>) -> &'a mut Self {
        self.file_name = if let Some(file_name) = file_name {
            Some(file_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn get_mime_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.mime_type.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn get_mime_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.mime_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn set_mime_type<'a>(&'a mut self, mime_type: Option<String>) -> &'a mut Self {
        self.mime_type = if let Some(mime_type) = mime_type {
            Some(mime_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size_ref<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self {
        self.file_size = if let Some(file_size) = file_size {
            Some(file_size)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InputTextMessageContent {
    pub fn new(message_text: String) -> Self {
        Self {
            message_text,
            parse_mode: None,
            entities: None,
            disable_web_page_preview: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_text, parse_mode, entities, disable_web_page_preview)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
    ) {
        (
            self.message_text,
            self.parse_mode.map(|parse_mode| parse_mode),
            self.entities.map(|entities| entities),
            self.disable_web_page_preview
                .map(|disable_web_page_preview| disable_web_page_preview),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    pub fn get_message_text<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message_text.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    pub fn get_message_text_ref<'a>(&'a self) -> &'a str {
        self.message_text.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    pub fn set_message_text<'a>(&'a mut self, message_text: String) -> &'a mut Self {
        self.message_text = message_text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    pub fn get_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    pub fn get_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    pub fn set_entities<'a>(&'a mut self, entities: Option<Vec<MessageEntity>>) -> &'a mut Self {
        self.entities = if let Some(entities) = entities {
            Some(entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    pub fn get_disable_web_page_preview<'a>(&'a self) -> Option<bool> {
        self.disable_web_page_preview.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    pub fn get_disable_web_page_preview_ref<'a>(&'a self) -> Option<bool> {
        self.disable_web_page_preview.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    pub fn set_disable_web_page_preview<'a>(
        &'a mut self,
        disable_web_page_preview: Option<bool>,
    ) -> &'a mut Self {
        self.disable_web_page_preview =
            if let Some(disable_web_page_preview) = disable_web_page_preview {
                Some(disable_web_page_preview)
            } else {
                None
            };
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultCachedMpeg4Gif {
    pub fn new(id: String, mpeg_4_file_id: String) -> Self {
        Self {
            tg_type: "mpeg4_gif".to_owned(),
            id,
            mpeg_4_file_id,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, mpeg4_file_id, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.mpeg_4_file_id,
            self.title.map(|title| title),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be mpeg4_gif"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    pub fn get_mpeg_4_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.mpeg_4_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    pub fn get_mpeg_4_file_id_ref<'a>(&'a self) -> &'a str {
        self.mpeg_4_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the MPEG4 file"]
    pub fn set_mpeg_4_file_id<'a>(&'a mut self, mpeg_4_file_id: String) -> &'a mut Self {
        self.mpeg_4_file_id = mpeg_4_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video animation"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultDocument {
    pub fn new(id: String, title: String, document_url: String, mime_type: String) -> Self {
        Self {
            tg_type: "document".to_owned(),
            id,
            title,
            document_url,
            mime_type,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            description: None,
            reply_markup: None,
            input_message_content: None,
            thumbnail_url: None,
            thumbnail_width: None,
            thumbnail_height: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, title, caption, parse_mode, caption_entities, document_url, mime_type, description, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        String,
        String,
        Option<String>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.tg_type,
            self.id,
            self.title,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.document_url,
            self.mime_type,
            self.description.map(|description| description),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
            self.thumbnail_url.map(|thumbnail_url| thumbnail_url),
            self.thumbnail_width.map(|thumbnail_width| thumbnail_width),
            self.thumbnail_height
                .map(|thumbnail_height| thumbnail_height),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be document"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the document caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    pub fn get_document_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.document_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    pub fn get_document_url_ref<'a>(&'a self) -> &'a str {
        self.document_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the file"]
    pub fn set_document_url<'a>(&'a mut self, document_url: String) -> &'a mut Self {
        self.document_url = document_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    pub fn get_mime_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.mime_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    pub fn get_mime_type_ref<'a>(&'a self) -> &'a str {
        self.mime_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "MIME type of the content of the file, either \"application/pdf\" or \"application/zip\""]
    pub fn set_mime_type<'a>(&'a mut self, mime_type: String) -> &'a mut Self {
        self.mime_type = mime_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the file"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    pub fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_url
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    pub fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the thumbnail (JPEG only) for the file"]
    pub fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self {
        self.thumbnail_url = if let Some(thumbnail_url) = thumbnail_url {
            Some(thumbnail_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn get_thumbnail_width<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self {
        self.thumbnail_width = if let Some(thumbnail_width) = thumbnail_width {
            Some(thumbnail_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn get_thumbnail_height<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self {
        self.thumbnail_height = if let Some(thumbnail_height) = thumbnail_height {
            Some(thumbnail_height)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl PassportElementErrorUnspecified {
    pub fn new(source: String, element_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorUnspecified".to_owned(),
            source,
            element_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, element_hash, message)"]
    pub fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.element_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    pub fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    pub fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be unspecified"]
    pub fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of element of the user's Telegram Passport which has the issue"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    pub fn get_element_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.element_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    pub fn get_element_hash_ref<'a>(&'a self) -> &'a str {
        self.element_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash"]
    pub fn set_element_hash<'a>(&'a mut self, element_hash: String) -> &'a mut Self {
        self.element_hash = element_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultCachedAudio {
    pub fn new(id: String, audio_file_id: String) -> Self {
        Self {
            tg_type: "audio".to_owned(),
            id,
            audio_file_id,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, audio_file_id, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.audio_file_id,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    pub fn get_audio_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.audio_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    pub fn get_audio_file_id_ref<'a>(&'a self) -> &'a str {
        self.audio_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the audio file"]
    pub fn set_audio_file_id<'a>(&'a mut self, audio_file_id: String) -> &'a mut Self {
        self.audio_file_id = audio_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl VideoChatEnded {
    pub fn new(duration: i64) -> Self {
        Self { duration }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (duration)"]
    pub fn into_tuple(self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video chat duration in seconds"]
    pub fn get_duration<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video chat duration in seconds"]
    pub fn get_duration_ref<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Video chat duration in seconds"]
    pub fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self {
        self.duration = duration;
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultVoice {
    pub fn new(id: String, voice_url: String, title: String) -> Self {
        Self {
            tg_type: "voice".to_owned(),
            id,
            voice_url,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            voice_duration: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, voice_url, title, caption, parse_mode, caption_entities, voice_duration, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<i64>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.voice_url,
            self.title,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.voice_duration.map(|voice_duration| voice_duration),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be voice"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    pub fn get_voice_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.voice_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    pub fn get_voice_url_ref<'a>(&'a self) -> &'a str {
        self.voice_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the voice recording"]
    pub fn set_voice_url<'a>(&'a mut self, voice_url: String) -> &'a mut Self {
        self.voice_url = voice_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Recording title"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    pub fn get_voice_duration<'a>(&'a self) -> Option<i64> {
        self.voice_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    pub fn get_voice_duration_ref<'a>(&'a self) -> Option<i64> {
        self.voice_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Recording duration in seconds"]
    pub fn set_voice_duration<'a>(&'a mut self, voice_duration: Option<i64>) -> &'a mut Self {
        self.voice_duration = if let Some(voice_duration) = voice_duration {
            Some(voice_duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the voice recording"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ResponseParameters {
    pub fn new() -> Self {
        Self {
            migrate_to_chat_id: None,
            retry_after: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (migrate_to_chat_id, retry_after)"]
    pub fn into_tuple(self) -> (Option<i64>, Option<i64>) {
        (
            self.migrate_to_chat_id
                .map(|migrate_to_chat_id| migrate_to_chat_id),
            self.retry_after.map(|retry_after| retry_after),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_migrate_to_chat_id<'a>(&'a self) -> Option<i64> {
        self.migrate_to_chat_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_migrate_to_chat_id_ref<'a>(&'a self) -> Option<i64> {
        self.migrate_to_chat_id.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_migrate_to_chat_id<'a>(
        &'a mut self,
        migrate_to_chat_id: Option<i64>,
    ) -> &'a mut Self {
        self.migrate_to_chat_id = if let Some(migrate_to_chat_id) = migrate_to_chat_id {
            Some(migrate_to_chat_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"]
    pub fn get_retry_after<'a>(&'a self) -> Option<i64> {
        self.retry_after.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"]
    pub fn get_retry_after_ref<'a>(&'a self) -> Option<i64> {
        self.retry_after.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"]
    pub fn set_retry_after<'a>(&'a mut self, retry_after: Option<i64>) -> &'a mut Self {
        self.retry_after = if let Some(retry_after) = retry_after {
            Some(retry_after)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl EncryptedPassportElement {
    pub fn new(hash: String) -> Self {
        Self {
            tg_type: "EncryptedPassportElement".to_owned(),
            hash,
            data: None,
            phone_number: None,
            email: None,
            files: None,
            front_side: None,
            reverse_side: None,
            selfie: None,
            translation: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, data, phone_number, email, files, front_side, reverse_side, selfie, translation, hash)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<PassportFile>>,
        Option<PassportFile>,
        Option<PassportFile>,
        Option<PassportFile>,
        Option<Vec<PassportFile>>,
        String,
    ) {
        (
            self.tg_type,
            self.data.map(|data| data),
            self.phone_number.map(|phone_number| phone_number),
            self.email.map(|email| email),
            self.files.map(|files| files),
            self.front_side.map(|front_side| front_side),
            self.reverse_side.map(|reverse_side| reverse_side),
            self.selfie.map(|selfie| selfie),
            self.translation.map(|translation| translation),
            self.hash,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Element type. One of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\", \"phone_number\", \"email\"."]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Element type. One of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\", \"phone_number\", \"email\"."]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Element type. One of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"address\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\", \"temporary_registration\", \"phone_number\", \"email\"."]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\" and \"address\" types. Can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_data<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.data.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\" and \"address\" types. Can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_data_ref<'a>(&'a self) -> Option<&'a str> {
        self.data.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for \"personal_details\", \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\" and \"address\" types. Can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_data<'a>(&'a mut self, data: Option<String>) -> &'a mut Self {
        self.data = if let Some(data) = data {
            Some(data)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified phone number, available only for \"phone_number\" type"]
    pub fn get_phone_number<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.phone_number
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified phone number, available only for \"phone_number\" type"]
    pub fn get_phone_number_ref<'a>(&'a self) -> Option<&'a str> {
        self.phone_number.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified phone number, available only for \"phone_number\" type"]
    pub fn set_phone_number<'a>(&'a mut self, phone_number: Option<String>) -> &'a mut Self {
        self.phone_number = if let Some(phone_number) = phone_number {
            Some(phone_number)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified email address, available only for \"email\" type"]
    pub fn get_email<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.email.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified email address, available only for \"email\" type"]
    pub fn get_email_ref<'a>(&'a self) -> Option<&'a str> {
        self.email.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's verified email address, available only for \"email\" type"]
    pub fn set_email<'a>(&'a mut self, email: Option<String>) -> &'a mut Self {
        self.email = if let Some(email) = email {
            Some(email)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with documents provided by the user, available for \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_files<'a>(&'a self) -> Option<Cow<'a, Vec<PassportFile>>> {
        self.files.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with documents provided by the user, available for \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_files_ref<'a>(&'a self) -> Option<&'a Vec<PassportFile>> {
        self.files.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with documents provided by the user, available for \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_files<'a>(&'a mut self, files: Option<Vec<PassportFile>>) -> &'a mut Self {
        self.files = if let Some(files) = files {
            Some(files)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the front side of the document, provided by the user. Available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_front_side<'a>(&'a self) -> Option<Cow<'a, PassportFile>> {
        self.front_side.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the front side of the document, provided by the user. Available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_front_side_ref<'a>(&'a self) -> Option<&'a PassportFile> {
        self.front_side.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the front side of the document, provided by the user. Available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_front_side<'a>(&'a mut self, front_side: Option<PassportFile>) -> &'a mut Self {
        self.front_side = if let Some(front_side) = front_side {
            Some(front_side)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the reverse side of the document, provided by the user. Available for \"driver_license\" and \"identity_card\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_reverse_side<'a>(&'a self) -> Option<Cow<'a, PassportFile>> {
        self.reverse_side.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the reverse side of the document, provided by the user. Available for \"driver_license\" and \"identity_card\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_reverse_side_ref<'a>(&'a self) -> Option<&'a PassportFile> {
        self.reverse_side.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the reverse side of the document, provided by the user. Available for \"driver_license\" and \"identity_card\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_reverse_side<'a>(&'a mut self, reverse_side: Option<PassportFile>) -> &'a mut Self {
        self.reverse_side = if let Some(reverse_side) = reverse_side {
            Some(reverse_side)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_selfie<'a>(&'a self) -> Option<Cow<'a, PassportFile>> {
        self.selfie.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_selfie_ref<'a>(&'a self) -> Option<&'a PassportFile> {
        self.selfie.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for \"passport\", \"driver_license\", \"identity_card\" and \"internal_passport\". The file can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_selfie<'a>(&'a mut self, selfie: Option<PassportFile>) -> &'a mut Self {
        self.selfie = if let Some(selfie) = selfie {
            Some(selfie)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_translation<'a>(&'a self) -> Option<Cow<'a, Vec<PassportFile>>> {
        self.translation.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn get_translation_ref<'a>(&'a self) -> Option<&'a Vec<PassportFile>> {
        self.translation.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\", \"utility_bill\", \"bank_statement\", \"rental_agreement\", \"passport_registration\" and \"temporary_registration\" types. Files can be decrypted and verified using the accompanying EncryptedCredentials."]
    pub fn set_translation<'a>(
        &'a mut self,
        translation: Option<Vec<PassportFile>>,
    ) -> &'a mut Self {
        self.translation = if let Some(translation) = translation {
            Some(translation)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash for using in PassportElementErrorUnspecified"]
    pub fn get_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash for using in PassportElementErrorUnspecified"]
    pub fn get_hash_ref<'a>(&'a self) -> &'a str {
        self.hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded element hash for using in PassportElementErrorUnspecified"]
    pub fn set_hash<'a>(&'a mut self, hash: String) -> &'a mut Self {
        self.hash = hash;
        self
    }
}
#[allow(dead_code)]
impl PhotoSize {
    pub fn new(file_id: String, file_unique_id: String, width: i64, height: i64) -> Self {
        Self {
            file_id,
            file_unique_id,
            width,
            height,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, width, height, file_size)"]
    pub fn into_tuple(self) -> (String, String, i64, i64, Option<i64>) {
        (
            self.file_id,
            self.file_unique_id,
            self.width,
            self.height,
            self.file_size.map(|file_size| file_size),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id_ref<'a>(&'a self) -> &'a str {
        self.file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo width"]
    pub fn get_width<'a>(&'a self) -> i64 {
        self.width
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo width"]
    pub fn get_width_ref<'a>(&'a self) -> i64 {
        self.width
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo width"]
    pub fn set_width<'a>(&'a mut self, width: i64) -> &'a mut Self {
        self.width = width;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo height"]
    pub fn get_height<'a>(&'a self) -> i64 {
        self.height
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo height"]
    pub fn get_height_ref<'a>(&'a self) -> i64 {
        self.height
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo height"]
    pub fn set_height<'a>(&'a mut self, height: i64) -> &'a mut Self {
        self.height = height;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn get_file_size<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn get_file_size_ref<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes"]
    pub fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self {
        self.file_size = if let Some(file_size) = file_size {
            Some(file_size)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultCachedVideo {
    pub fn new(id: String, video_file_id: String, title: String) -> Self {
        Self {
            tg_type: "video".to_owned(),
            id,
            video_file_id,
            title,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, video_file_id, title, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.video_file_id,
            self.title,
            self.description.map(|description| description),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be video"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    pub fn get_video_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.video_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    pub fn get_video_file_id_ref<'a>(&'a self) -> &'a str {
        self.video_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the video file"]
    pub fn set_video_file_id<'a>(&'a mut self, video_file_id: String) -> &'a mut Self {
        self.video_file_id = video_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title for the result"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the video caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the video"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl Voice {
    pub fn new(file_id: String, file_unique_id: String, duration: i64) -> Self {
        Self {
            file_id,
            file_unique_id,
            duration,
            mime_type: None,
            file_size: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (file_id, file_unique_id, duration, mime_type, file_size)"]
    pub fn into_tuple(self) -> (String, String, i64, Option<String>, Option<i64>) {
        (
            self.file_id,
            self.file_unique_id,
            self.duration,
            self.mime_type.map(|mime_type| mime_type),
            self.file_size.map(|file_size| file_size),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn get_file_id_ref<'a>(&'a self) -> &'a str {
        self.file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Identifier for this file, which can be used to download or reuse the file"]
    pub fn set_file_id<'a>(&'a mut self, file_id: String) -> &'a mut Self {
        self.file_id = file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_unique_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn get_file_unique_id_ref<'a>(&'a self) -> &'a str {
        self.file_unique_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."]
    pub fn set_file_unique_id<'a>(&'a mut self, file_unique_id: String) -> &'a mut Self {
        self.file_unique_id = file_unique_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    pub fn get_duration<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    pub fn get_duration_ref<'a>(&'a self) -> i64 {
        self.duration
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Duration of the audio in seconds as defined by sender"]
    pub fn set_duration<'a>(&'a mut self, duration: i64) -> &'a mut Self {
        self.duration = duration;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn get_mime_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.mime_type.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn get_mime_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.mime_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. MIME type of the file as defined by sender"]
    pub fn set_mime_type<'a>(&'a mut self, mime_type: Option<String>) -> &'a mut Self {
        self.mime_type = if let Some(mime_type) = mime_type {
            Some(mime_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn get_file_size_ref<'a>(&'a self) -> Option<i64> {
        self.file_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."]
    pub fn set_file_size<'a>(&'a mut self, file_size: Option<i64>) -> &'a mut Self {
        self.file_size = if let Some(file_size) = file_size {
            Some(file_size)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl Game {
    pub fn new(title: String, description: String, photo: Vec<PhotoSize>) -> Self {
        Self {
            title,
            description,
            photo,
            text: None,
            text_entities: None,
            animation: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (title, description, photo, text, text_entities, animation)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        Vec<PhotoSize>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<Animation>,
    ) {
        (
            self.title,
            self.description,
            self.photo,
            self.text.map(|text| text),
            self.text_entities.map(|text_entities| text_entities),
            self.animation.map(|animation| animation),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the game"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the game"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title of the game"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the game"]
    pub fn get_description<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.description.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the game"]
    pub fn get_description_ref<'a>(&'a self) -> &'a str {
        self.description.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the game"]
    pub fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self {
        self.description = description;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo that will be displayed in the game message in chats."]
    pub fn get_photo<'a>(&'a self) -> Cow<'a, Vec<PhotoSize>> {
        Cow::Borrowed(&self.photo)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo that will be displayed in the game message in chats."]
    pub fn get_photo_ref<'a>(&'a self) -> &'a Vec<PhotoSize> {
        &self.photo
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Photo that will be displayed in the game message in chats."]
    pub fn set_photo<'a>(&'a mut self, photo: Vec<PhotoSize>) -> &'a mut Self {
        self.photo = photo;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."]
    pub fn get_text<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.text.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."]
    pub fn get_text_ref<'a>(&'a self) -> Option<&'a str> {
        self.text.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."]
    pub fn set_text<'a>(&'a mut self, text: Option<String>) -> &'a mut Self {
        self.text = if let Some(text) = text {
            Some(text)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."]
    pub fn get_text_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.text_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."]
    pub fn get_text_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.text_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."]
    pub fn set_text_entities<'a>(
        &'a mut self,
        text_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.text_entities = if let Some(text_entities) = text_entities {
            Some(text_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"]
    pub fn get_animation<'a>(&'a self) -> Option<Cow<'a, Animation>> {
        self.animation.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"]
    pub fn get_animation_ref<'a>(&'a self) -> Option<&'a Animation> {
        self.animation.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"]
    pub fn set_animation<'a>(&'a mut self, animation: Option<Animation>) -> &'a mut Self {
        self.animation = if let Some(animation) = animation {
            Some(animation)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultPhoto {
    pub fn new(id: String, photo_url: String, thumbnail_url: String) -> Self {
        Self {
            tg_type: "photo".to_owned(),
            id,
            photo_url,
            thumbnail_url,
            photo_width: None,
            photo_height: None,
            title: None,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, photo_url, thumbnail_url, photo_width, photo_height, title, description, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<i64>,
        Option<i64>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.photo_url,
            self.thumbnail_url,
            self.photo_width.map(|photo_width| photo_width),
            self.photo_height.map(|photo_height| photo_height),
            self.title.map(|title| title),
            self.description.map(|description| description),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be photo"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    pub fn get_photo_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.photo_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    pub fn get_photo_url_ref<'a>(&'a self) -> &'a str {
        self.photo_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"]
    pub fn set_photo_url<'a>(&'a mut self, photo_url: String) -> &'a mut Self {
        self.photo_url = photo_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    pub fn get_thumbnail_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.thumbnail_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    pub fn get_thumbnail_url_ref<'a>(&'a self) -> &'a str {
        self.thumbnail_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "URL of the thumbnail for the photo"]
    pub fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: String) -> &'a mut Self {
        self.thumbnail_url = thumbnail_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    pub fn get_photo_width<'a>(&'a self) -> Option<i64> {
        self.photo_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    pub fn get_photo_width_ref<'a>(&'a self) -> Option<i64> {
        self.photo_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Width of the photo"]
    pub fn set_photo_width<'a>(&'a mut self, photo_width: Option<i64>) -> &'a mut Self {
        self.photo_width = if let Some(photo_width) = photo_width {
            Some(photo_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    pub fn get_photo_height<'a>(&'a self) -> Option<i64> {
        self.photo_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    pub fn get_photo_height_ref<'a>(&'a self) -> Option<i64> {
        self.photo_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Height of the photo"]
    pub fn set_photo_height<'a>(&'a mut self, photo_height: Option<i64>) -> &'a mut Self {
        self.photo_height = if let Some(photo_height) = photo_height {
            Some(photo_height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.description.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn get_description_ref<'a>(&'a self) -> Option<&'a str> {
        self.description.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Short description of the result"]
    pub fn set_description<'a>(&'a mut self, description: Option<String>) -> &'a mut Self {
        self.description = if let Some(description) = description {
            Some(description)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the photo"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultLocation {
    pub fn new(
        id: String,
        latitude: ::ordered_float::OrderedFloat<f64>,
        longitude: ::ordered_float::OrderedFloat<f64>,
        title: String,
    ) -> Self {
        Self {
            tg_type: "location".to_owned(),
            id,
            latitude,
            longitude,
            title,
            horizontal_accuracy: None,
            live_period: None,
            heading: None,
            proximity_alert_radius: None,
            reply_markup: None,
            input_message_content: None,
            thumbnail_url: None,
            thumbnail_width: None,
            thumbnail_height: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, latitude, longitude, title, horizontal_accuracy, live_period, heading, proximity_alert_radius, reply_markup, input_message_content, thumbnail_url, thumbnail_width, thumbnail_height)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        String,
        Option<::ordered_float::OrderedFloat<f64>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
        Option<String>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.tg_type,
            self.id,
            self.latitude,
            self.longitude,
            self.title,
            self.horizontal_accuracy
                .map(|horizontal_accuracy| horizontal_accuracy),
            self.live_period.map(|live_period| live_period),
            self.heading.map(|heading| heading),
            self.proximity_alert_radius
                .map(|proximity_alert_radius| proximity_alert_radius),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
            self.thumbnail_url.map(|thumbnail_url| thumbnail_url),
            self.thumbnail_width.map(|thumbnail_width| thumbnail_width),
            self.thumbnail_height
                .map(|thumbnail_height| thumbnail_height),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be location"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 Bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    pub fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    pub fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location latitude in degrees"]
    pub fn set_latitude<'a>(
        &'a mut self,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    pub fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    pub fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location longitude in degrees"]
    pub fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Location title"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn get_horizontal_accuracy<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>> {
        self.horizontal_accuracy.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn get_horizontal_accuracy_ref<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>> {
        self.horizontal_accuracy.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    pub fn set_horizontal_accuracy<'a>(
        &'a mut self,
        horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    ) -> &'a mut Self {
        self.horizontal_accuracy = if let Some(horizontal_accuracy) = horizontal_accuracy {
            Some(horizontal_accuracy)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    pub fn get_live_period<'a>(&'a self) -> Option<i64> {
        self.live_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    pub fn get_live_period_ref<'a>(&'a self) -> Option<i64> {
        self.live_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    pub fn set_live_period<'a>(&'a mut self, live_period: Option<i64>) -> &'a mut Self {
        self.live_period = if let Some(live_period) = live_period {
            Some(live_period)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    pub fn get_heading<'a>(&'a self) -> Option<i64> {
        self.heading.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    pub fn get_heading_ref<'a>(&'a self) -> Option<i64> {
        self.heading.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    pub fn set_heading<'a>(&'a mut self, heading: Option<i64>) -> &'a mut Self {
        self.heading = if let Some(heading) = heading {
            Some(heading)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    pub fn get_proximity_alert_radius<'a>(&'a self) -> Option<i64> {
        self.proximity_alert_radius.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    pub fn get_proximity_alert_radius_ref<'a>(&'a self) -> Option<i64> {
        self.proximity_alert_radius.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    pub fn set_proximity_alert_radius<'a>(
        &'a mut self,
        proximity_alert_radius: Option<i64>,
    ) -> &'a mut Self {
        self.proximity_alert_radius = if let Some(proximity_alert_radius) = proximity_alert_radius {
            Some(proximity_alert_radius)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the location"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn get_thumbnail_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.thumbnail_url
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn get_thumbnail_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.thumbnail_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Url of the thumbnail for the result"]
    pub fn set_thumbnail_url<'a>(&'a mut self, thumbnail_url: Option<String>) -> &'a mut Self {
        self.thumbnail_url = if let Some(thumbnail_url) = thumbnail_url {
            Some(thumbnail_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn get_thumbnail_width<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn get_thumbnail_width_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail width"]
    pub fn set_thumbnail_width<'a>(&'a mut self, thumbnail_width: Option<i64>) -> &'a mut Self {
        self.thumbnail_width = if let Some(thumbnail_width) = thumbnail_width {
            Some(thumbnail_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn get_thumbnail_height<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn get_thumbnail_height_ref<'a>(&'a self) -> Option<i64> {
        self.thumbnail_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Thumbnail height"]
    pub fn set_thumbnail_height<'a>(&'a mut self, thumbnail_height: Option<i64>) -> &'a mut Self {
        self.thumbnail_height = if let Some(thumbnail_height) = thumbnail_height {
            Some(thumbnail_height)
        } else {
            None
        };
        self
    }
}
impl TraitInputTextMessageContent for InputTextMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_text, parse_mode, entities, disable_web_page_preview)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<bool>,
    ) {
        (
            self.message_text,
            self.parse_mode.map(|parse_mode| parse_mode),
            self.entities.map(|entities| entities),
            self.disable_web_page_preview
                .map(|disable_web_page_preview| disable_web_page_preview),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    fn get_message_text<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message_text.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    fn get_message_text_ref<'a>(&'a self) -> &'a str {
        self.message_text.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text of the message to be sent, 1-4096 characters"]
    fn set_message_text<'a>(&'a mut self, message_text: String) -> &'a mut Self {
        self.message_text = message_text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the message text. See formatting options for more details."]
    fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    fn get_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    fn get_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"]
    fn set_entities<'a>(&'a mut self, entities: Option<Vec<MessageEntity>>) -> &'a mut Self {
        self.entities = if let Some(entities) = entities {
            Some(entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    fn get_disable_web_page_preview<'a>(&'a self) -> Option<bool> {
        self.disable_web_page_preview.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    fn get_disable_web_page_preview_ref<'a>(&'a self) -> Option<bool> {
        self.disable_web_page_preview.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Disables link previews for links in the sent message"]
    fn set_disable_web_page_preview<'a>(
        &'a mut self,
        disable_web_page_preview: Option<bool>,
    ) -> &'a mut Self {
        self.disable_web_page_preview =
            if let Some(disable_web_page_preview) = disable_web_page_preview {
                Some(disable_web_page_preview)
            } else {
                None
            };
        self
    }
}
impl TraitInputLocationMessageContent for InputLocationMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (latitude, longitude, horizontal_accuracy, live_period, heading, proximity_alert_radius)"]
    fn into_tuple(
        self,
    ) -> (
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        Option<::ordered_float::OrderedFloat<f64>>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.latitude,
            self.longitude,
            self.horizontal_accuracy
                .map(|horizontal_accuracy| horizontal_accuracy),
            self.live_period.map(|live_period| live_period),
            self.heading.map(|heading| heading),
            self.proximity_alert_radius
                .map(|proximity_alert_radius| proximity_alert_radius),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the location in degrees"]
    fn set_latitude<'a>(
        &'a mut self,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the location in degrees"]
    fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn get_horizontal_accuracy<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>> {
        self.horizontal_accuracy.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn get_horizontal_accuracy_ref<'a>(&'a self) -> Option<::ordered_float::OrderedFloat<f64>> {
        self.horizontal_accuracy.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"]
    fn set_horizontal_accuracy<'a>(
        &'a mut self,
        horizontal_accuracy: Option<::ordered_float::OrderedFloat<f64>>,
    ) -> &'a mut Self {
        self.horizontal_accuracy = if let Some(horizontal_accuracy) = horizontal_accuracy {
            Some(horizontal_accuracy)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn get_live_period<'a>(&'a self) -> Option<i64> {
        self.live_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn get_live_period_ref<'a>(&'a self) -> Option<i64> {
        self.live_period.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."]
    fn set_live_period<'a>(&'a mut self, live_period: Option<i64>) -> &'a mut Self {
        self.live_period = if let Some(live_period) = live_period {
            Some(live_period)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn get_heading<'a>(&'a self) -> Option<i64> {
        self.heading.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn get_heading_ref<'a>(&'a self) -> Option<i64> {
        self.heading.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."]
    fn set_heading<'a>(&'a mut self, heading: Option<i64>) -> &'a mut Self {
        self.heading = if let Some(heading) = heading {
            Some(heading)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn get_proximity_alert_radius<'a>(&'a self) -> Option<i64> {
        self.proximity_alert_radius.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn get_proximity_alert_radius_ref<'a>(&'a self) -> Option<i64> {
        self.proximity_alert_radius.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."]
    fn set_proximity_alert_radius<'a>(
        &'a mut self,
        proximity_alert_radius: Option<i64>,
    ) -> &'a mut Self {
        self.proximity_alert_radius = if let Some(proximity_alert_radius) = proximity_alert_radius {
            Some(proximity_alert_radius)
        } else {
            None
        };
        self
    }
}
impl TraitInputVenueMessageContent for InputVenueMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (latitude, longitude, title, address, foursquare_id, foursquare_type, google_place_id, google_place_type)"]
    fn into_tuple(
        self,
    ) -> (
        ::ordered_float::OrderedFloat<f64>,
        ::ordered_float::OrderedFloat<f64>,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<String>,
    ) {
        (
            self.latitude,
            self.longitude,
            self.title,
            self.address,
            self.foursquare_id.map(|foursquare_id| foursquare_id),
            self.foursquare_type.map(|foursquare_type| foursquare_type),
            self.google_place_id.map(|google_place_id| google_place_id),
            self.google_place_type
                .map(|google_place_type| google_place_type),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    fn get_latitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    fn get_latitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.latitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Latitude of the venue in degrees"]
    fn set_latitude<'a>(
        &'a mut self,
        latitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.latitude = latitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    fn get_longitude<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    fn get_longitude_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.longitude
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Longitude of the venue in degrees"]
    fn set_longitude<'a>(
        &'a mut self,
        longitude: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.longitude = longitude;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Name of the venue"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn get_address<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.address.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn get_address_ref<'a>(&'a self) -> &'a str {
        self.address.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Address of the venue"]
    fn set_address<'a>(&'a mut self, address: String) -> &'a mut Self {
        self.address = address;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    fn get_foursquare_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.foursquare_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    fn get_foursquare_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.foursquare_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare identifier of the venue, if known"]
    fn set_foursquare_id<'a>(&'a mut self, foursquare_id: Option<String>) -> &'a mut Self {
        self.foursquare_id = if let Some(foursquare_id) = foursquare_id {
            Some(foursquare_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn get_foursquare_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.foursquare_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn get_foursquare_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.foursquare_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Foursquare type of the venue, if known. (For example, \"arts_entertainment/default\", \"arts_entertainment/aquarium\" or \"food/icecream\".)"]
    fn set_foursquare_type<'a>(&'a mut self, foursquare_type: Option<String>) -> &'a mut Self {
        self.foursquare_type = if let Some(foursquare_type) = foursquare_type {
            Some(foursquare_type)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn get_google_place_id<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.google_place_id
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn get_google_place_id_ref<'a>(&'a self) -> Option<&'a str> {
        self.google_place_id.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places identifier of the venue"]
    fn set_google_place_id<'a>(&'a mut self, google_place_id: Option<String>) -> &'a mut Self {
        self.google_place_id = if let Some(google_place_id) = google_place_id {
            Some(google_place_id)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn get_google_place_type<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.google_place_type
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn get_google_place_type_ref<'a>(&'a self) -> Option<&'a str> {
        self.google_place_type.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Google Places type of the venue. (See supported types.)"]
    fn set_google_place_type<'a>(&'a mut self, google_place_type: Option<String>) -> &'a mut Self {
        self.google_place_type = if let Some(google_place_type) = google_place_type {
            Some(google_place_type)
        } else {
            None
        };
        self
    }
}
impl TraitInputContactMessageContent for InputContactMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (phone_number, first_name, last_name, vcard)"]
    fn into_tuple(self) -> (String, String, Option<String>, Option<String>) {
        (
            self.phone_number,
            self.first_name,
            self.last_name.map(|last_name| last_name),
            self.vcard.map(|vcard| vcard),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn get_phone_number<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.phone_number.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn get_phone_number_ref<'a>(&'a self) -> &'a str {
        self.phone_number.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's phone number"]
    fn set_phone_number<'a>(&'a mut self, phone_number: String) -> &'a mut Self {
        self.phone_number = phone_number;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn get_first_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.first_name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn get_first_name_ref<'a>(&'a self) -> &'a str {
        self.first_name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Contact's first name"]
    fn set_first_name<'a>(&'a mut self, first_name: String) -> &'a mut Self {
        self.first_name = first_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.last_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn get_last_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.last_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Contact's last name"]
    fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self {
        self.last_name = if let Some(last_name) = last_name {
            Some(last_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn get_vcard<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.vcard.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn get_vcard_ref<'a>(&'a self) -> Option<&'a str> {
        self.vcard.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"]
    fn set_vcard<'a>(&'a mut self, vcard: Option<String>) -> &'a mut Self {
        self.vcard = if let Some(vcard) = vcard {
            Some(vcard)
        } else {
            None
        };
        self
    }
}
impl TraitInputInvoiceMessageContent for InputInvoiceMessageContent {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (title, description, payload, provider_token, currency, prices, max_tip_amount, suggested_tip_amounts, provider_data, photo_url, photo_size, photo_width, photo_height, need_name, need_phone_number, need_email, need_shipping_address, send_phone_number_to_provider, send_email_to_provider, is_flexible)"]
    fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        Vec<LabeledPrice>,
        Option<i64>,
        Option<Vec<i64>>,
        Option<String>,
        Option<String>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    ) {
        (
            self.title,
            self.description,
            self.payload,
            self.provider_token,
            self.currency,
            self.prices,
            self.max_tip_amount.map(|max_tip_amount| max_tip_amount),
            self.suggested_tip_amounts
                .map(|suggested_tip_amounts| suggested_tip_amounts),
            self.provider_data.map(|provider_data| provider_data),
            self.photo_url.map(|photo_url| photo_url),
            self.photo_size.map(|photo_size| photo_size),
            self.photo_width.map(|photo_width| photo_width),
            self.photo_height.map(|photo_height| photo_height),
            self.need_name.map(|need_name| need_name),
            self.need_phone_number
                .map(|need_phone_number| need_phone_number),
            self.need_email.map(|need_email| need_email),
            self.need_shipping_address
                .map(|need_shipping_address| need_shipping_address),
            self.send_phone_number_to_provider
                .map(|send_phone_number_to_provider| send_phone_number_to_provider),
            self.send_email_to_provider
                .map(|send_email_to_provider| send_email_to_provider),
            self.is_flexible.map(|is_flexible| is_flexible),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name, 1-32 characters"]
    fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    fn get_description<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.description.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    fn get_description_ref<'a>(&'a self) -> &'a str {
        self.description.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description, 1-255 characters"]
    fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self {
        self.description = description;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    fn get_payload<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.payload.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    fn get_payload_ref<'a>(&'a self) -> &'a str {
        self.payload.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."]
    fn set_payload<'a>(&'a mut self, payload: String) -> &'a mut Self {
        self.payload = payload;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    fn get_provider_token<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.provider_token.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    fn get_provider_token_ref<'a>(&'a self) -> &'a str {
        self.provider_token.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Payment provider token, obtained via @BotFather"]
    fn set_provider_token<'a>(&'a mut self, provider_token: String) -> &'a mut Self {
        self.provider_token = provider_token;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    fn get_currency<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.currency.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    fn get_currency_ref<'a>(&'a self) -> &'a str {
        self.currency.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code, see more on currencies"]
    fn set_currency<'a>(&'a mut self, currency: String) -> &'a mut Self {
        self.currency = currency;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    fn get_prices<'a>(&'a self) -> Cow<'a, Vec<LabeledPrice>> {
        Cow::Borrowed(&self.prices)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    fn get_prices_ref<'a>(&'a self) -> &'a Vec<LabeledPrice> {
        &self.prices
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"]
    fn set_prices<'a>(&'a mut self, prices: Vec<LabeledPrice>) -> &'a mut Self {
        self.prices = prices;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    fn get_max_tip_amount<'a>(&'a self) -> Option<i64> {
        self.max_tip_amount.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    fn get_max_tip_amount_ref<'a>(&'a self) -> Option<i64> {
        self.max_tip_amount.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"]
    fn set_max_tip_amount<'a>(&'a mut self, max_tip_amount: Option<i64>) -> &'a mut Self {
        self.max_tip_amount = if let Some(max_tip_amount) = max_tip_amount {
            Some(max_tip_amount)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    fn get_suggested_tip_amounts<'a>(&'a self) -> Option<Cow<'a, Vec<i64>>> {
        self.suggested_tip_amounts
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    fn get_suggested_tip_amounts_ref<'a>(&'a self) -> Option<&'a Vec<i64>> {
        self.suggested_tip_amounts.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."]
    fn set_suggested_tip_amounts<'a>(
        &'a mut self,
        suggested_tip_amounts: Option<Vec<i64>>,
    ) -> &'a mut Self {
        self.suggested_tip_amounts = if let Some(suggested_tip_amounts) = suggested_tip_amounts {
            Some(suggested_tip_amounts)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    fn get_provider_data<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.provider_data
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    fn get_provider_data_ref<'a>(&'a self) -> Option<&'a str> {
        self.provider_data.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."]
    fn set_provider_data<'a>(&'a mut self, provider_data: Option<String>) -> &'a mut Self {
        self.provider_data = if let Some(provider_data) = provider_data {
            Some(provider_data)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    fn get_photo_url<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.photo_url.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    fn get_photo_url_ref<'a>(&'a self) -> Option<&'a str> {
        self.photo_url.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."]
    fn set_photo_url<'a>(&'a mut self, photo_url: Option<String>) -> &'a mut Self {
        self.photo_url = if let Some(photo_url) = photo_url {
            Some(photo_url)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    fn get_photo_size<'a>(&'a self) -> Option<i64> {
        self.photo_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    fn get_photo_size_ref<'a>(&'a self) -> Option<i64> {
        self.photo_size.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo size in bytes"]
    fn set_photo_size<'a>(&'a mut self, photo_size: Option<i64>) -> &'a mut Self {
        self.photo_size = if let Some(photo_size) = photo_size {
            Some(photo_size)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    fn get_photo_width<'a>(&'a self) -> Option<i64> {
        self.photo_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    fn get_photo_width_ref<'a>(&'a self) -> Option<i64> {
        self.photo_width.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo width"]
    fn set_photo_width<'a>(&'a mut self, photo_width: Option<i64>) -> &'a mut Self {
        self.photo_width = if let Some(photo_width) = photo_width {
            Some(photo_width)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    fn get_photo_height<'a>(&'a self) -> Option<i64> {
        self.photo_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    fn get_photo_height_ref<'a>(&'a self) -> Option<i64> {
        self.photo_height.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Photo height"]
    fn set_photo_height<'a>(&'a mut self, photo_height: Option<i64>) -> &'a mut Self {
        self.photo_height = if let Some(photo_height) = photo_height {
            Some(photo_height)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    fn get_need_name<'a>(&'a self) -> Option<bool> {
        self.need_name.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    fn get_need_name_ref<'a>(&'a self) -> Option<bool> {
        self.need_name.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's full name to complete the order"]
    fn set_need_name<'a>(&'a mut self, need_name: Option<bool>) -> &'a mut Self {
        self.need_name = if let Some(need_name) = need_name {
            Some(need_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    fn get_need_phone_number<'a>(&'a self) -> Option<bool> {
        self.need_phone_number.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    fn get_need_phone_number_ref<'a>(&'a self) -> Option<bool> {
        self.need_phone_number.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's phone number to complete the order"]
    fn set_need_phone_number<'a>(&'a mut self, need_phone_number: Option<bool>) -> &'a mut Self {
        self.need_phone_number = if let Some(need_phone_number) = need_phone_number {
            Some(need_phone_number)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    fn get_need_email<'a>(&'a self) -> Option<bool> {
        self.need_email.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    fn get_need_email_ref<'a>(&'a self) -> Option<bool> {
        self.need_email.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's email address to complete the order"]
    fn set_need_email<'a>(&'a mut self, need_email: Option<bool>) -> &'a mut Self {
        self.need_email = if let Some(need_email) = need_email {
            Some(need_email)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    fn get_need_shipping_address<'a>(&'a self) -> Option<bool> {
        self.need_shipping_address.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    fn get_need_shipping_address_ref<'a>(&'a self) -> Option<bool> {
        self.need_shipping_address.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if you require the user's shipping address to complete the order"]
    fn set_need_shipping_address<'a>(
        &'a mut self,
        need_shipping_address: Option<bool>,
    ) -> &'a mut Self {
        self.need_shipping_address = if let Some(need_shipping_address) = need_shipping_address {
            Some(need_shipping_address)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    fn get_send_phone_number_to_provider<'a>(&'a self) -> Option<bool> {
        self.send_phone_number_to_provider.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    fn get_send_phone_number_to_provider_ref<'a>(&'a self) -> Option<bool> {
        self.send_phone_number_to_provider.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's phone number should be sent to provider"]
    fn set_send_phone_number_to_provider<'a>(
        &'a mut self,
        send_phone_number_to_provider: Option<bool>,
    ) -> &'a mut Self {
        self.send_phone_number_to_provider =
            if let Some(send_phone_number_to_provider) = send_phone_number_to_provider {
                Some(send_phone_number_to_provider)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    fn get_send_email_to_provider<'a>(&'a self) -> Option<bool> {
        self.send_email_to_provider.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    fn get_send_email_to_provider_ref<'a>(&'a self) -> Option<bool> {
        self.send_email_to_provider.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the user's email address should be sent to provider"]
    fn set_send_email_to_provider<'a>(
        &'a mut self,
        send_email_to_provider: Option<bool>,
    ) -> &'a mut Self {
        self.send_email_to_provider = if let Some(send_email_to_provider) = send_email_to_provider {
            Some(send_email_to_provider)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    fn get_is_flexible<'a>(&'a self) -> Option<bool> {
        self.is_flexible.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    fn get_is_flexible_ref<'a>(&'a self) -> Option<bool> {
        self.is_flexible.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True if the final price depends on the shipping method"]
    fn set_is_flexible<'a>(&'a mut self, is_flexible: Option<bool>) -> &'a mut Self {
        self.is_flexible = if let Some(is_flexible) = is_flexible {
            Some(is_flexible)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatMemberOwner {
    pub fn new(user: User, is_anonymous: bool) -> Self {
        Self {
            user,
            is_anonymous,
            custom_title: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (user, is_anonymous, custom_title)"]
    pub fn into_tuple(self) -> (User, bool, Option<String>) {
        (
            self.user,
            self.is_anonymous,
            self.custom_title.map(|custom_title| custom_title),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.user)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn get_user_ref<'a>(&'a self) -> &'a User {
        &self.user
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Information about the user"]
    pub fn set_user<'a>(&'a mut self, user: User) -> &'a mut Self {
        self.user = user;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn get_is_anonymous<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn get_is_anonymous_ref<'a>(&'a self) -> bool {
        self.is_anonymous
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the user's presence in the chat is hidden"]
    pub fn set_is_anonymous<'a>(&'a mut self, is_anonymous: bool) -> &'a mut Self {
        self.is_anonymous = is_anonymous;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    pub fn get_custom_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.custom_title
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    pub fn get_custom_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.custom_title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Custom title for this user"]
    pub fn set_custom_title<'a>(&'a mut self, custom_title: Option<String>) -> &'a mut Self {
        self.custom_title = if let Some(custom_title) = custom_title {
            Some(custom_title)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl Story {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: ()"]
    pub fn into_tuple(self) {
        ()
    }
}
impl TraitMenuButtonCommands for MenuButtonCommands {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be commands"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
impl TraitMenuButtonWebApp for MenuButtonWebApp {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, text, web_app)"]
    fn into_tuple(self) -> (String, String, WebAppInfo) {
        (self.tg_type, self.text, self.web_app)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be web_app"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    fn get_text<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.text.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    fn get_text_ref<'a>(&'a self) -> &'a str {
        self.text.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Text on the button"]
    fn set_text<'a>(&'a mut self, text: String) -> &'a mut Self {
        self.text = text;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    fn get_web_app<'a>(&'a self) -> Cow<'a, WebAppInfo> {
        Cow::Borrowed(&self.web_app)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    fn get_web_app_ref<'a>(&'a self) -> &'a WebAppInfo {
        &self.web_app
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."]
    fn set_web_app<'a>(&'a mut self, web_app: WebAppInfo) -> &'a mut Self {
        self.web_app = web_app;
        self
    }
}
impl TraitMenuButtonDefault for MenuButtonDefault {
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the button, must be default"]
    fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
#[allow(dead_code)]
impl User {
    pub fn new(id: i64, is_bot: bool, first_name: String) -> Self {
        Self {
            id,
            is_bot,
            first_name,
            last_name: None,
            username: None,
            language_code: None,
            is_premium: None,
            added_to_attachment_menu: None,
            can_join_groups: None,
            can_read_all_group_messages: None,
            supports_inline_queries: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (id, is_bot, first_name, last_name, username, language_code, is_premium, added_to_attachment_menu, can_join_groups, can_read_all_group_messages, supports_inline_queries)"]
    pub fn into_tuple(
        self,
    ) -> (
        i64,
        bool,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<bool>,
    ) {
        (
            self.id,
            self.is_bot,
            self.first_name,
            self.last_name.map(|last_name| last_name),
            self.username.map(|username| username),
            self.language_code.map(|language_code| language_code),
            self.is_premium.map(|is_premium| is_premium),
            self.added_to_attachment_menu
                .map(|added_to_attachment_menu| added_to_attachment_menu),
            self.can_join_groups.map(|can_join_groups| can_join_groups),
            self.can_read_all_group_messages
                .map(|can_read_all_group_messages| can_read_all_group_messages),
            self.supports_inline_queries
                .map(|supports_inline_queries| supports_inline_queries),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_id<'a>(&'a self) -> i64 {
        self.id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn get_id_ref<'a>(&'a self) -> i64 {
        self.id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."]
    pub fn set_id<'a>(&'a mut self, id: i64) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if this user is a bot"]
    pub fn get_is_bot<'a>(&'a self) -> bool {
        self.is_bot
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if this user is a bot"]
    pub fn get_is_bot_ref<'a>(&'a self) -> bool {
        self.is_bot
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if this user is a bot"]
    pub fn set_is_bot<'a>(&'a mut self, is_bot: bool) -> &'a mut Self {
        self.is_bot = is_bot;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User's or bot's first name"]
    pub fn get_first_name<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.first_name.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User's or bot's first name"]
    pub fn get_first_name_ref<'a>(&'a self) -> &'a str {
        self.first_name.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "User's or bot's first name"]
    pub fn set_first_name<'a>(&'a mut self, first_name: String) -> &'a mut Self {
        self.first_name = first_name;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's last name"]
    pub fn get_last_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.last_name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's last name"]
    pub fn get_last_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.last_name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's last name"]
    pub fn set_last_name<'a>(&'a mut self, last_name: Option<String>) -> &'a mut Self {
        self.last_name = if let Some(last_name) = last_name {
            Some(last_name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's username"]
    pub fn get_username<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.username.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's username"]
    pub fn get_username_ref<'a>(&'a self) -> Option<&'a str> {
        self.username.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. User's or bot's username"]
    pub fn set_username<'a>(&'a mut self, username: Option<String>) -> &'a mut Self {
        self.username = if let Some(username) = username {
            Some(username)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. IETF language tag of the user's language"]
    pub fn get_language_code<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.language_code
            .as_ref()
            .map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. IETF language tag of the user's language"]
    pub fn get_language_code_ref<'a>(&'a self) -> Option<&'a str> {
        self.language_code.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. IETF language tag of the user's language"]
    pub fn set_language_code<'a>(&'a mut self, language_code: Option<String>) -> &'a mut Self {
        self.language_code = if let Some(language_code) = language_code {
            Some(language_code)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user is a Telegram Premium user"]
    pub fn get_is_premium<'a>(&'a self) -> Option<bool> {
        self.is_premium.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user is a Telegram Premium user"]
    pub fn get_is_premium_ref<'a>(&'a self) -> Option<bool> {
        self.is_premium.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user is a Telegram Premium user"]
    pub fn set_is_premium<'a>(&'a mut self, is_premium: Option<bool>) -> &'a mut Self {
        self.is_premium = if let Some(is_premium) = is_premium {
            Some(is_premium)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user added the bot to the attachment menu"]
    pub fn get_added_to_attachment_menu<'a>(&'a self) -> Option<bool> {
        self.added_to_attachment_menu.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user added the bot to the attachment menu"]
    pub fn get_added_to_attachment_menu_ref<'a>(&'a self) -> Option<bool> {
        self.added_to_attachment_menu.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if this user added the bot to the attachment menu"]
    pub fn set_added_to_attachment_menu<'a>(
        &'a mut self,
        added_to_attachment_menu: Option<bool>,
    ) -> &'a mut Self {
        self.added_to_attachment_menu =
            if let Some(added_to_attachment_menu) = added_to_attachment_menu {
                Some(added_to_attachment_menu)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can be invited to groups. Returned only in getMe."]
    pub fn get_can_join_groups<'a>(&'a self) -> Option<bool> {
        self.can_join_groups.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can be invited to groups. Returned only in getMe."]
    pub fn get_can_join_groups_ref<'a>(&'a self) -> Option<bool> {
        self.can_join_groups.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot can be invited to groups. Returned only in getMe."]
    pub fn set_can_join_groups<'a>(&'a mut self, can_join_groups: Option<bool>) -> &'a mut Self {
        self.can_join_groups = if let Some(can_join_groups) = can_join_groups {
            Some(can_join_groups)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."]
    pub fn get_can_read_all_group_messages<'a>(&'a self) -> Option<bool> {
        self.can_read_all_group_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."]
    pub fn get_can_read_all_group_messages_ref<'a>(&'a self) -> Option<bool> {
        self.can_read_all_group_messages.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."]
    pub fn set_can_read_all_group_messages<'a>(
        &'a mut self,
        can_read_all_group_messages: Option<bool>,
    ) -> &'a mut Self {
        self.can_read_all_group_messages =
            if let Some(can_read_all_group_messages) = can_read_all_group_messages {
                Some(can_read_all_group_messages)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot supports inline queries. Returned only in getMe."]
    pub fn get_supports_inline_queries<'a>(&'a self) -> Option<bool> {
        self.supports_inline_queries.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot supports inline queries. Returned only in getMe."]
    pub fn get_supports_inline_queries_ref<'a>(&'a self) -> Option<bool> {
        self.supports_inline_queries.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. True, if the bot supports inline queries. Returned only in getMe."]
    pub fn set_supports_inline_queries<'a>(
        &'a mut self,
        supports_inline_queries: Option<bool>,
    ) -> &'a mut Self {
        self.supports_inline_queries =
            if let Some(supports_inline_queries) = supports_inline_queries {
                Some(supports_inline_queries)
            } else {
                None
            };
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultAudio {
    pub fn new(id: String, audio_url: String, title: String) -> Self {
        Self {
            tg_type: "audio".to_owned(),
            id,
            audio_url,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            performer: None,
            audio_duration: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, audio_url, title, caption, parse_mode, caption_entities, performer, audio_duration, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<String>,
        Option<i64>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.audio_url,
            self.title,
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.performer.map(|performer| performer),
            self.audio_duration.map(|audio_duration| audio_duration),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be audio"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    pub fn get_audio_url<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.audio_url.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    pub fn get_audio_url_ref<'a>(&'a self) -> &'a str {
        self.audio_url.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid URL for the audio file"]
    pub fn set_audio_url<'a>(&'a mut self, audio_url: String) -> &'a mut Self {
        self.audio_url = audio_url;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Title"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    pub fn get_performer<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.performer.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    pub fn get_performer_ref<'a>(&'a self) -> Option<&'a str> {
        self.performer.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Performer"]
    pub fn set_performer<'a>(&'a mut self, performer: Option<String>) -> &'a mut Self {
        self.performer = if let Some(performer) = performer {
            Some(performer)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    pub fn get_audio_duration<'a>(&'a self) -> Option<i64> {
        self.audio_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    pub fn get_audio_duration_ref<'a>(&'a self) -> Option<i64> {
        self.audio_duration.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Audio duration in seconds"]
    pub fn set_audio_duration<'a>(&'a mut self, audio_duration: Option<i64>) -> &'a mut Self {
        self.audio_duration = if let Some(audio_duration) = audio_duration {
            Some(audio_duration)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the audio"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl ChatInviteLink {
    pub fn new(
        invite_link: String,
        creator: User,
        creates_join_request: bool,
        is_primary: bool,
        is_revoked: bool,
    ) -> Self {
        Self {
            invite_link,
            creator,
            creates_join_request,
            is_primary,
            is_revoked,
            name: None,
            expire_date: None,
            member_limit: None,
            pending_join_request_count: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (invite_link, creator, creates_join_request, is_primary, is_revoked, name, expire_date, member_limit, pending_join_request_count)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        User,
        bool,
        bool,
        bool,
        Option<String>,
        Option<i64>,
        Option<i64>,
        Option<i64>,
    ) {
        (
            self.invite_link,
            self.creator,
            self.creates_join_request,
            self.is_primary,
            self.is_revoked,
            self.name.map(|name| name),
            self.expire_date.map(|expire_date| expire_date),
            self.member_limit.map(|member_limit| member_limit),
            self.pending_join_request_count
                .map(|pending_join_request_count| pending_join_request_count),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with \"...\"."]
    pub fn get_invite_link<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.invite_link.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with \"...\"."]
    pub fn get_invite_link_ref<'a>(&'a self) -> &'a str {
        self.invite_link.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with \"...\"."]
    pub fn set_invite_link<'a>(&'a mut self, invite_link: String) -> &'a mut Self {
        self.invite_link = invite_link;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Creator of the link"]
    pub fn get_creator<'a>(&'a self) -> Cow<'a, User> {
        Cow::Borrowed(&self.creator)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Creator of the link"]
    pub fn get_creator_ref<'a>(&'a self) -> &'a User {
        &self.creator
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Creator of the link"]
    pub fn set_creator<'a>(&'a mut self, creator: User) -> &'a mut Self {
        self.creator = creator;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if users joining the chat via the link need to be approved by chat administrators"]
    pub fn get_creates_join_request<'a>(&'a self) -> bool {
        self.creates_join_request
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if users joining the chat via the link need to be approved by chat administrators"]
    pub fn get_creates_join_request_ref<'a>(&'a self) -> bool {
        self.creates_join_request
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if users joining the chat via the link need to be approved by chat administrators"]
    pub fn set_creates_join_request<'a>(&'a mut self, creates_join_request: bool) -> &'a mut Self {
        self.creates_join_request = creates_join_request;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is primary"]
    pub fn get_is_primary<'a>(&'a self) -> bool {
        self.is_primary
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is primary"]
    pub fn get_is_primary_ref<'a>(&'a self) -> bool {
        self.is_primary
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is primary"]
    pub fn set_is_primary<'a>(&'a mut self, is_primary: bool) -> &'a mut Self {
        self.is_primary = is_primary;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is revoked"]
    pub fn get_is_revoked<'a>(&'a self) -> bool {
        self.is_revoked
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is revoked"]
    pub fn get_is_revoked_ref<'a>(&'a self) -> bool {
        self.is_revoked
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "True, if the link is revoked"]
    pub fn set_is_revoked<'a>(&'a mut self, is_revoked: bool) -> &'a mut Self {
        self.is_revoked = is_revoked;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Invite link name"]
    pub fn get_name<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.name.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Invite link name"]
    pub fn get_name_ref<'a>(&'a self) -> Option<&'a str> {
        self.name.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Invite link name"]
    pub fn set_name<'a>(&'a mut self, name: Option<String>) -> &'a mut Self {
        self.name = if let Some(name) = name {
            Some(name)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"]
    pub fn get_expire_date<'a>(&'a self) -> Option<i64> {
        self.expire_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"]
    pub fn get_expire_date_ref<'a>(&'a self) -> Option<i64> {
        self.expire_date.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"]
    pub fn set_expire_date<'a>(&'a mut self, expire_date: Option<i64>) -> &'a mut Self {
        self.expire_date = if let Some(expire_date) = expire_date {
            Some(expire_date)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"]
    pub fn get_member_limit<'a>(&'a self) -> Option<i64> {
        self.member_limit.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"]
    pub fn get_member_limit_ref<'a>(&'a self) -> Option<i64> {
        self.member_limit.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"]
    pub fn set_member_limit<'a>(&'a mut self, member_limit: Option<i64>) -> &'a mut Self {
        self.member_limit = if let Some(member_limit) = member_limit {
            Some(member_limit)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Number of pending join requests created using this link"]
    pub fn get_pending_join_request_count<'a>(&'a self) -> Option<i64> {
        self.pending_join_request_count.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Number of pending join requests created using this link"]
    pub fn get_pending_join_request_count_ref<'a>(&'a self) -> Option<i64> {
        self.pending_join_request_count.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Number of pending join requests created using this link"]
    pub fn set_pending_join_request_count<'a>(
        &'a mut self,
        pending_join_request_count: Option<i64>,
    ) -> &'a mut Self {
        self.pending_join_request_count =
            if let Some(pending_join_request_count) = pending_join_request_count {
                Some(pending_join_request_count)
            } else {
                None
            };
        self
    }
}
#[allow(dead_code)]
impl MessageAutoDeleteTimerChanged {
    pub fn new(message_auto_delete_time: i64) -> Self {
        Self {
            message_auto_delete_time,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (message_auto_delete_time)"]
    pub fn into_tuple(self) -> i64 {
        self.message_auto_delete_time
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New auto-delete time for messages in the chat; in seconds"]
    pub fn get_message_auto_delete_time<'a>(&'a self) -> i64 {
        self.message_auto_delete_time
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New auto-delete time for messages in the chat; in seconds"]
    pub fn get_message_auto_delete_time_ref<'a>(&'a self) -> i64 {
        self.message_auto_delete_time
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "New auto-delete time for messages in the chat; in seconds"]
    pub fn set_message_auto_delete_time<'a>(
        &'a mut self,
        message_auto_delete_time: i64,
    ) -> &'a mut Self {
        self.message_auto_delete_time = message_auto_delete_time;
        self
    }
}
#[allow(dead_code)]
impl InlineQueryResultCachedGif {
    pub fn new(id: String, gif_file_id: String) -> Self {
        Self {
            tg_type: "gif".to_owned(),
            id,
            gif_file_id,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, id, gif_file_id, title, caption, parse_mode, caption_entities, reply_markup, input_message_content)"]
    pub fn into_tuple(
        self,
    ) -> (
        String,
        String,
        String,
        Option<String>,
        Option<String>,
        Option<String>,
        Option<Vec<MessageEntity>>,
        Option<InlineKeyboardMarkup>,
        Option<InputMessageContent>,
    ) {
        (
            self.tg_type,
            self.id,
            self.gif_file_id,
            self.title.map(|title| title),
            self.caption.map(|caption| caption),
            self.parse_mode.map(|parse_mode| parse_mode),
            self.caption_entities
                .map(|caption_entities| caption_entities),
            self.reply_markup.map(|reply_markup| reply_markup),
            self.input_message_content
                .map(|input_message_content| input_message_content),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Type of the result, must be gif"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn get_id_ref<'a>(&'a self) -> &'a str {
        self.id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for this result, 1-64 bytes"]
    pub fn set_id<'a>(&'a mut self, id: String) -> &'a mut Self {
        self.id = id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    pub fn get_gif_file_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.gif_file_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    pub fn get_gif_file_id_ref<'a>(&'a self) -> &'a str {
        self.gif_file_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "A valid file identifier for the GIF file"]
    pub fn set_gif_file_id<'a>(&'a mut self, gif_file_id: String) -> &'a mut Self {
        self.gif_file_id = gif_file_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.title.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn get_title_ref<'a>(&'a self) -> Option<&'a str> {
        self.title.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Title for the result"]
    pub fn set_title<'a>(&'a mut self, title: Option<String>) -> &'a mut Self {
        self.title = if let Some(title) = title {
            Some(title)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.caption.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    pub fn get_caption_ref<'a>(&'a self) -> Option<&'a str> {
        self.caption.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"]
    pub fn set_caption<'a>(&'a mut self, caption: Option<String>) -> &'a mut Self {
        self.caption = if let Some(caption) = caption {
            Some(caption)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn get_parse_mode<'a>(&'a self) -> Option<Cow<'a, str>> {
        self.parse_mode.as_ref().map(|v| Cow::Borrowed(v.as_str()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn get_parse_mode_ref<'a>(&'a self) -> Option<&'a str> {
        self.parse_mode.as_ref().map(|v| v.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Mode for parsing entities in the caption. See formatting options for more details."]
    pub fn set_parse_mode<'a>(&'a mut self, parse_mode: Option<String>) -> &'a mut Self {
        self.parse_mode = if let Some(parse_mode) = parse_mode {
            Some(parse_mode)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities<'a>(&'a self) -> Option<Cow<'a, Vec<MessageEntity>>> {
        self.caption_entities.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn get_caption_entities_ref<'a>(&'a self) -> Option<&'a Vec<MessageEntity>> {
        self.caption_entities.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"]
    pub fn set_caption_entities<'a>(
        &'a mut self,
        caption_entities: Option<Vec<MessageEntity>>,
    ) -> &'a mut Self {
        self.caption_entities = if let Some(caption_entities) = caption_entities {
            Some(caption_entities)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup<'a>(&'a self) -> Option<Cow<'a, InlineKeyboardMarkup>> {
        self.reply_markup.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn get_reply_markup_ref<'a>(&'a self) -> Option<&'a InlineKeyboardMarkup> {
        self.reply_markup.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Inline keyboard attached to the message"]
    pub fn set_reply_markup<'a>(
        &'a mut self,
        reply_markup: Option<InlineKeyboardMarkup>,
    ) -> &'a mut Self {
        self.reply_markup = if let Some(reply_markup) = reply_markup {
            Some(reply_markup)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    pub fn get_input_message_content<'a>(&'a self) -> Option<Cow<'a, InputMessageContent>> {
        self.input_message_content
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    pub fn get_input_message_content_ref<'a>(&'a self) -> Option<&'a InputMessageContent> {
        self.input_message_content.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Content of the message to be sent instead of the GIF animation"]
    pub fn set_input_message_content<'a>(
        &'a mut self,
        input_message_content: Option<InputMessageContent>,
    ) -> &'a mut Self {
        self.input_message_content = if let Some(input_message_content) = input_message_content {
            Some(input_message_content)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl LabeledPrice {
    pub fn new(label: String, amount: i64) -> Self {
        Self { label, amount }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (label, amount)"]
    pub fn into_tuple(self) -> (String, i64) {
        (self.label, self.amount)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Portion label"]
    pub fn get_label<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.label.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Portion label"]
    pub fn get_label_ref<'a>(&'a self) -> &'a str {
        self.label.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Portion label"]
    pub fn set_label<'a>(&'a mut self, label: String) -> &'a mut Self {
        self.label = label;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn get_amount<'a>(&'a self) -> i64 {
        self.amount
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn get_amount_ref<'a>(&'a self) -> i64 {
        self.amount
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn set_amount<'a>(&'a mut self, amount: i64) -> &'a mut Self {
        self.amount = amount;
        self
    }
}
#[allow(dead_code)]
impl PollAnswer {
    pub fn new(poll_id: String, option_ids: Vec<i64>) -> Self {
        Self {
            poll_id,
            option_ids,
            voter_chat: None,
            user: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (poll_id, voter_chat, user, option_ids)"]
    pub fn into_tuple(self) -> (String, Option<Chat>, Option<User>, Vec<i64>) {
        (
            self.poll_id,
            self.voter_chat.map(|voter_chat| (*voter_chat)),
            self.user.map(|user| user),
            self.option_ids,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    pub fn get_poll_id<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.poll_id.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    pub fn get_poll_id_ref<'a>(&'a self) -> &'a str {
        self.poll_id.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique poll identifier"]
    pub fn set_poll_id<'a>(&'a mut self, poll_id: String) -> &'a mut Self {
        self.poll_id = poll_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    pub fn get_voter_chat<'a>(&'a self) -> Option<Cow<'a, Chat>> {
        self.voter_chat.as_ref().map(|v| Cow::Borrowed(v.as_ref()))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    pub fn get_voter_chat_ref<'a>(&'a self) -> Option<&'a Chat> {
        self.voter_chat.as_ref().map(|v| v.as_ref())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The chat that changed the answer to the poll, if the voter is anonymous"]
    pub fn set_voter_chat<'a>(&'a mut self, voter_chat: Option<Chat>) -> &'a mut Self {
        self.voter_chat = if let Some(voter_chat) = voter_chat {
            Some(Box::new(voter_chat))
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    pub fn get_user<'a>(&'a self) -> Option<Cow<'a, User>> {
        self.user.as_ref().map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    pub fn get_user_ref<'a>(&'a self) -> Option<&'a User> {
        self.user.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"]
    pub fn set_user<'a>(&'a mut self, user: Option<User>) -> &'a mut Self {
        self.user = if let Some(user) = user {
            Some(user)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    pub fn get_option_ids<'a>(&'a self) -> Cow<'a, Vec<i64>> {
        Cow::Borrowed(&self.option_ids)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    pub fn get_option_ids_ref<'a>(&'a self) -> &'a Vec<i64> {
        &self.option_ids
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "0-based identifiers of chosen answer options. May be empty if the vote was retracted."]
    pub fn set_option_ids<'a>(&'a mut self, option_ids: Vec<i64>) -> &'a mut Self {
        self.option_ids = option_ids;
        self
    }
}
#[allow(dead_code)]
impl Invoice {
    pub fn new(
        title: String,
        description: String,
        start_parameter: String,
        currency: String,
        total_amount: i64,
    ) -> Self {
        Self {
            title,
            description,
            start_parameter,
            currency,
            total_amount,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (title, description, start_parameter, currency, total_amount)"]
    pub fn into_tuple(self) -> (String, String, String, String, i64) {
        (
            self.title,
            self.description,
            self.start_parameter,
            self.currency,
            self.total_amount,
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name"]
    pub fn get_title<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.title.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name"]
    pub fn get_title_ref<'a>(&'a self) -> &'a str {
        self.title.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product name"]
    pub fn set_title<'a>(&'a mut self, title: String) -> &'a mut Self {
        self.title = title;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description"]
    pub fn get_description<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.description.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description"]
    pub fn get_description_ref<'a>(&'a self) -> &'a str {
        self.description.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Product description"]
    pub fn set_description<'a>(&'a mut self, description: String) -> &'a mut Self {
        self.description = description;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique bot deep-linking parameter that can be used to generate this invoice"]
    pub fn get_start_parameter<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.start_parameter.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique bot deep-linking parameter that can be used to generate this invoice"]
    pub fn get_start_parameter_ref<'a>(&'a self) -> &'a str {
        self.start_parameter.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique bot deep-linking parameter that can be used to generate this invoice"]
    pub fn set_start_parameter<'a>(&'a mut self, start_parameter: String) -> &'a mut Self {
        self.start_parameter = start_parameter;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn get_currency<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.currency.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn get_currency_ref<'a>(&'a self) -> &'a str {
        self.currency.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Three-letter ISO 4217 currency code"]
    pub fn set_currency<'a>(&'a mut self, currency: String) -> &'a mut Self {
        self.currency = currency;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn get_total_amount<'a>(&'a self) -> i64 {
        self.total_amount
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn get_total_amount_ref<'a>(&'a self) -> i64 {
        self.total_amount
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."]
    pub fn set_total_amount<'a>(&'a mut self, total_amount: i64) -> &'a mut Self {
        self.total_amount = total_amount;
        self
    }
}
#[allow(dead_code)]
impl PassportElementErrorReverseSide {
    pub fn new(source: String, file_hash: String, message: String) -> Self {
        Self {
            tg_type: "PassportElementErrorReverseSide".to_owned(),
            source,
            file_hash,
            message,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (source, type, file_hash, message)"]
    pub fn into_tuple(self) -> (String, String, String, String) {
        (self.source, self.tg_type, self.file_hash, self.message)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    pub fn get_source<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.source.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    pub fn get_source_ref<'a>(&'a self) -> &'a str {
        self.source.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error source, must be reverse_side"]
    pub fn set_source<'a>(&'a mut self, source: String) -> &'a mut Self {
        self.source = source;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "The section of the user's Telegram Passport which has the issue, one of \"driver_license\", \"identity_card\""]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    pub fn get_file_hash<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.file_hash.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    pub fn get_file_hash_ref<'a>(&'a self) -> &'a str {
        self.file_hash.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Base64-encoded hash of the file with the reverse side of the document"]
    pub fn set_file_hash<'a>(&'a mut self, file_hash: String) -> &'a mut Self {
        self.file_hash = file_hash;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.message.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn get_message_ref<'a>(&'a self) -> &'a str {
        self.message.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Error message"]
    pub fn set_message<'a>(&'a mut self, message: String) -> &'a mut Self {
        self.message = message;
        self
    }
}
#[allow(dead_code)]
impl ReplyKeyboardRemove {
    pub fn new(remove_keyboard: bool) -> Self {
        Self {
            remove_keyboard,
            selective: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (remove_keyboard, selective)"]
    pub fn into_tuple(self) -> (bool, Option<bool>) {
        (
            self.remove_keyboard,
            self.selective.map(|selective| selective),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"]
    pub fn get_remove_keyboard<'a>(&'a self) -> bool {
        self.remove_keyboard
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"]
    pub fn get_remove_keyboard_ref<'a>(&'a self) -> bool {
        self.remove_keyboard
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"]
    pub fn set_remove_keyboard<'a>(&'a mut self, remove_keyboard: bool) -> &'a mut Self {
        self.remove_keyboard = remove_keyboard;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."]
    pub fn get_selective<'a>(&'a self) -> Option<bool> {
        self.selective.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."]
    pub fn get_selective_ref<'a>(&'a self) -> Option<bool> {
        self.selective.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."]
    pub fn set_selective<'a>(&'a mut self, selective: Option<bool>) -> &'a mut Self {
        self.selective = if let Some(selective) = selective {
            Some(selective)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl KeyboardButtonRequestChat {
    pub fn new(request_id: i64, chat_is_channel: bool) -> Self {
        Self {
            request_id,
            chat_is_channel,
            chat_is_forum: None,
            chat_has_username: None,
            chat_is_created: None,
            user_administrator_rights: None,
            bot_administrator_rights: None,
            bot_is_member: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (request_id, chat_is_channel, chat_is_forum, chat_has_username, chat_is_created, user_administrator_rights, bot_administrator_rights, bot_is_member)"]
    pub fn into_tuple(
        self,
    ) -> (
        i64,
        bool,
        Option<bool>,
        Option<bool>,
        Option<bool>,
        Option<ChatAdministratorRights>,
        Option<ChatAdministratorRights>,
        Option<bool>,
    ) {
        (
            self.request_id,
            self.chat_is_channel,
            self.chat_is_forum.map(|chat_is_forum| chat_is_forum),
            self.chat_has_username
                .map(|chat_has_username| chat_has_username),
            self.chat_is_created.map(|chat_is_created| chat_is_created),
            self.user_administrator_rights
                .map(|user_administrator_rights| user_administrator_rights),
            self.bot_administrator_rights
                .map(|bot_administrator_rights| bot_administrator_rights),
            self.bot_is_member.map(|bot_is_member| bot_is_member),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"]
    pub fn get_request_id<'a>(&'a self) -> i64 {
        self.request_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"]
    pub fn get_request_id_ref<'a>(&'a self) -> i64 {
        self.request_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"]
    pub fn set_request_id<'a>(&'a mut self, request_id: i64) -> &'a mut Self {
        self.request_id = request_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Pass True to request a channel chat, pass False to request a group or a supergroup chat."]
    pub fn get_chat_is_channel<'a>(&'a self) -> bool {
        self.chat_is_channel
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Pass True to request a channel chat, pass False to request a group or a supergroup chat."]
    pub fn get_chat_is_channel_ref<'a>(&'a self) -> bool {
        self.chat_is_channel
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Pass True to request a channel chat, pass False to request a group or a supergroup chat."]
    pub fn set_chat_is_channel<'a>(&'a mut self, chat_is_channel: bool) -> &'a mut Self {
        self.chat_is_channel = chat_is_channel;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."]
    pub fn get_chat_is_forum<'a>(&'a self) -> Option<bool> {
        self.chat_is_forum.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."]
    pub fn get_chat_is_forum_ref<'a>(&'a self) -> Option<bool> {
        self.chat_is_forum.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."]
    pub fn set_chat_is_forum<'a>(&'a mut self, chat_is_forum: Option<bool>) -> &'a mut Self {
        self.chat_is_forum = if let Some(chat_is_forum) = chat_is_forum {
            Some(chat_is_forum)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."]
    pub fn get_chat_has_username<'a>(&'a self) -> Option<bool> {
        self.chat_has_username.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."]
    pub fn get_chat_has_username_ref<'a>(&'a self) -> Option<bool> {
        self.chat_has_username.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."]
    pub fn set_chat_has_username<'a>(
        &'a mut self,
        chat_has_username: Option<bool>,
    ) -> &'a mut Self {
        self.chat_has_username = if let Some(chat_has_username) = chat_has_username {
            Some(chat_has_username)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."]
    pub fn get_chat_is_created<'a>(&'a self) -> Option<bool> {
        self.chat_is_created.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."]
    pub fn get_chat_is_created_ref<'a>(&'a self) -> Option<bool> {
        self.chat_is_created.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."]
    pub fn set_chat_is_created<'a>(&'a mut self, chat_is_created: Option<bool>) -> &'a mut Self {
        self.chat_is_created = if let Some(chat_is_created) = chat_is_created {
            Some(chat_is_created)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."]
    pub fn get_user_administrator_rights<'a>(&'a self) -> Option<Cow<'a, ChatAdministratorRights>> {
        self.user_administrator_rights
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."]
    pub fn get_user_administrator_rights_ref<'a>(&'a self) -> Option<&'a ChatAdministratorRights> {
        self.user_administrator_rights.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."]
    pub fn set_user_administrator_rights<'a>(
        &'a mut self,
        user_administrator_rights: Option<ChatAdministratorRights>,
    ) -> &'a mut Self {
        self.user_administrator_rights =
            if let Some(user_administrator_rights) = user_administrator_rights {
                Some(user_administrator_rights)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."]
    pub fn get_bot_administrator_rights<'a>(&'a self) -> Option<Cow<'a, ChatAdministratorRights>> {
        self.bot_administrator_rights
            .as_ref()
            .map(|v| Cow::Borrowed(v))
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."]
    pub fn get_bot_administrator_rights_ref<'a>(&'a self) -> Option<&'a ChatAdministratorRights> {
        self.bot_administrator_rights.as_ref().map(|v| v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."]
    pub fn set_bot_administrator_rights<'a>(
        &'a mut self,
        bot_administrator_rights: Option<ChatAdministratorRights>,
    ) -> &'a mut Self {
        self.bot_administrator_rights =
            if let Some(bot_administrator_rights) = bot_administrator_rights {
                Some(bot_administrator_rights)
            } else {
                None
            };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."]
    pub fn get_bot_is_member<'a>(&'a self) -> Option<bool> {
        self.bot_is_member.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."]
    pub fn get_bot_is_member_ref<'a>(&'a self) -> Option<bool> {
        self.bot_is_member.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."]
    pub fn set_bot_is_member<'a>(&'a mut self, bot_is_member: Option<bool>) -> &'a mut Self {
        self.bot_is_member = if let Some(bot_is_member) = bot_is_member {
            Some(bot_is_member)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl KeyboardButtonRequestUser {
    pub fn new(request_id: i64) -> Self {
        Self {
            request_id,
            user_is_bot: None,
            user_is_premium: None,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (request_id, user_is_bot, user_is_premium)"]
    pub fn into_tuple(self) -> (i64, Option<bool>, Option<bool>) {
        (
            self.request_id,
            self.user_is_bot.map(|user_is_bot| user_is_bot),
            self.user_is_premium.map(|user_is_premium| user_is_premium),
        )
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"]
    pub fn get_request_id<'a>(&'a self) -> i64 {
        self.request_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"]
    pub fn get_request_id_ref<'a>(&'a self) -> i64 {
        self.request_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"]
    pub fn set_request_id<'a>(&'a mut self, request_id: i64) -> &'a mut Self {
        self.request_id = request_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."]
    pub fn get_user_is_bot<'a>(&'a self) -> Option<bool> {
        self.user_is_bot.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."]
    pub fn get_user_is_bot_ref<'a>(&'a self) -> Option<bool> {
        self.user_is_bot.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."]
    pub fn set_user_is_bot<'a>(&'a mut self, user_is_bot: Option<bool>) -> &'a mut Self {
        self.user_is_bot = if let Some(user_is_bot) = user_is_bot {
            Some(user_is_bot)
        } else {
            None
        };
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."]
    pub fn get_user_is_premium<'a>(&'a self) -> Option<bool> {
        self.user_is_premium.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."]
    pub fn get_user_is_premium_ref<'a>(&'a self) -> Option<bool> {
        self.user_is_premium.as_ref().map(|v| *v)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."]
    pub fn set_user_is_premium<'a>(&'a mut self, user_is_premium: Option<bool>) -> &'a mut Self {
        self.user_is_premium = if let Some(user_is_premium) = user_is_premium {
            Some(user_is_premium)
        } else {
            None
        };
        self
    }
}
#[allow(dead_code)]
impl BotCommandScopeAllGroupChats {
    pub fn new() -> Self {
        Self {
            tg_type: "all_group_chats".to_owned(),
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type)"]
    pub fn into_tuple(self) -> String {
        self.tg_type
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be all_group_chats"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
}
#[allow(dead_code)]
impl BotCommandScopeChatMember {
    pub fn new(chat_id: ::ordered_float::OrderedFloat<f64>, user_id: i64) -> Self {
        Self {
            tg_type: "chat_member".to_owned(),
            chat_id,
            user_id,
        }
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Consumes and deconstructs this type into a tuple with one element per field.\n            Tuple type returned is: (type, chat_id, user_id)"]
    pub fn into_tuple(self) -> (String, ::ordered_float::OrderedFloat<f64>, i64) {
        (self.tg_type, self.chat_id, self.user_id)
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    pub fn get_tg_type<'a>(&'a self) -> Cow<'a, str> {
        Cow::Borrowed(self.tg_type.as_str())
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    pub fn get_tg_type_ref<'a>(&'a self) -> &'a str {
        self.tg_type.as_str()
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Scope type, must be chat_member"]
    pub fn set_tg_type<'a>(&'a mut self, tg_type: String) -> &'a mut Self {
        self.tg_type = tg_type;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn get_chat_id<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn get_chat_id_ref<'a>(&'a self) -> ::ordered_float::OrderedFloat<f64> {
        self.chat_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"]
    pub fn set_chat_id<'a>(
        &'a mut self,
        chat_id: ::ordered_float::OrderedFloat<f64>,
    ) -> &'a mut Self {
        self.chat_id = chat_id;
        self
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    pub fn get_user_id<'a>(&'a self) -> i64 {
        self.user_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    pub fn get_user_id_ref<'a>(&'a self) -> i64 {
        self.user_id
    }
    #[allow(rustdoc::invalid_html_tags)]
    #[doc = "Unique identifier of the target user"]
    pub fn set_user_id<'a>(&'a mut self, user_id: i64) -> &'a mut Self {
        self.user_id = user_id;
        self
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum GlobalTypes {
    LoginUrl(LoginUrl),
    BotCommandScopeChat(BotCommandScopeChat),
    ChatPermissions(ChatPermissions),
    Audio(Audio),
    InputContactMessageContent(InputContactMessageContent),
    InputMediaPhoto(InputMediaPhoto),
    OrderInfo(OrderInfo),
    ForumTopic(ForumTopic),
    WriteAccessAllowed(WriteAccessAllowed),
    BotCommandScope(BotCommandScope),
    InputMediaAudio(InputMediaAudio),
    InputMedia(InputMedia),
    ChosenInlineResult(ChosenInlineResult),
    GeneralForumTopicUnhidden(GeneralForumTopicUnhidden),
    CallbackQuery(CallbackQuery),
    Chat(Chat),
    ChatMemberUpdated(ChatMemberUpdated),
    BotDescription(BotDescription),
    InputLocationMessageContent(InputLocationMessageContent),
    ReplyKeyboardMarkup(ReplyKeyboardMarkup),
    MessageId(MessageId),
    PollOption(PollOption),
    BotShortDescription(BotShortDescription),
    InputMediaVideo(InputMediaVideo),
    PassportElementErrorFrontSide(PassportElementErrorFrontSide),
    MenuButtonDefault(MenuButtonDefault),
    EncryptedCredentials(EncryptedCredentials),
    PassportElementErrorFile(PassportElementErrorFile),
    GameHighScore(GameHighScore),
    ShippingQuery(ShippingQuery),
    InlineQueryResultVideo(InlineQueryResultVideo),
    SwitchInlineQueryChosenChat(SwitchInlineQueryChosenChat),
    Document(Document),
    PassportElementErrorTranslationFiles(PassportElementErrorTranslationFiles),
    MessageEntity(MessageEntity),
    ChatMemberAdministrator(ChatMemberAdministrator),
    InlineQueryResultVenue(InlineQueryResultVenue),
    Contact(Contact),
    InlineQueryResultGame(InlineQueryResultGame),
    BotCommandScopeAllPrivateChats(BotCommandScopeAllPrivateChats),
    ForumTopicReopened(ForumTopicReopened),
    UserProfilePhotos(UserProfilePhotos),
    InlineQueryResultsButton(InlineQueryResultsButton),
    Message(Message),
    PreCheckoutQuery(PreCheckoutQuery),
    ForumTopicEdited(ForumTopicEdited),
    File(File),
    ChatMember(ChatMember),
    Poll(Poll),
    InlineQueryResultCachedVoice(InlineQueryResultCachedVoice),
    SuccessfulPayment(SuccessfulPayment),
    InputMediaDocument(InputMediaDocument),
    Location(Location),
    KeyboardButton(KeyboardButton),
    ChatMemberLeft(ChatMemberLeft),
    BotCommand(BotCommand),
    Venue(Venue),
    PassportElementErrorSelfie(PassportElementErrorSelfie),
    ForumTopicClosed(ForumTopicClosed),
    VideoNote(VideoNote),
    InlineKeyboardMarkup(InlineKeyboardMarkup),
    ProximityAlertTriggered(ProximityAlertTriggered),
    ForumTopicCreated(ForumTopicCreated),
    Sticker(Sticker),
    InlineQueryResultContact(InlineQueryResultContact),
    MaskPosition(MaskPosition),
    UserShared(UserShared),
    BotCommandScopeAllChatAdministrators(BotCommandScopeAllChatAdministrators),
    InputMediaAnimation(InputMediaAnimation),
    KeyboardButtonPollType(KeyboardButtonPollType),
    ChatJoinRequest(ChatJoinRequest),
    InputFile(InputFile),
    InlineQueryResultCachedDocument(InlineQueryResultCachedDocument),
    ChatAdministratorRights(ChatAdministratorRights),
    VideoChatStarted(VideoChatStarted),
    WebhookInfo(WebhookInfo),
    WebAppData(WebAppData),
    InlineQuery(InlineQuery),
    PassportFile(PassportFile),
    InlineQueryResultCachedSticker(InlineQueryResultCachedSticker),
    Animation(Animation),
    ChatPhoto(ChatPhoto),
    StickerSet(StickerSet),
    InputVenueMessageContent(InputVenueMessageContent),
    PassportElementErrorFiles(PassportElementErrorFiles),
    BotCommandScopeChatAdministrators(BotCommandScopeChatAdministrators),
    InlineQueryResultCachedPhoto(InlineQueryResultCachedPhoto),
    InputInvoiceMessageContent(InputInvoiceMessageContent),
    ChatMemberMember(ChatMemberMember),
    ForceReply(ForceReply),
    MenuButtonWebApp(MenuButtonWebApp),
    Update(Update),
    MenuButtonCommands(MenuButtonCommands),
    ChatMemberRestricted(ChatMemberRestricted),
    InlineQueryResultArticle(InlineQueryResultArticle),
    PassportElementError(PassportElementError),
    GeneralForumTopicHidden(GeneralForumTopicHidden),
    SentWebAppMessage(SentWebAppMessage),
    VideoChatParticipantsInvited(VideoChatParticipantsInvited),
    InlineKeyboardButton(InlineKeyboardButton),
    InlineQueryResult(InlineQueryResult),
    ChatShared(ChatShared),
    InlineQueryResultMpeg4Gif(InlineQueryResultMpeg4Gif),
    ShippingAddress(ShippingAddress),
    PassportElementErrorDataField(PassportElementErrorDataField),
    Dice(Dice),
    PassportElementErrorTranslationFile(PassportElementErrorTranslationFile),
    VideoChatScheduled(VideoChatScheduled),
    ShippingOption(ShippingOption),
    WebAppInfo(WebAppInfo),
    ChatMemberBanned(ChatMemberBanned),
    BotCommandScopeDefault(BotCommandScopeDefault),
    PassportData(PassportData),
    InputSticker(InputSticker),
    ChatLocation(ChatLocation),
    CallbackGame(CallbackGame),
    InlineQueryResultGif(InlineQueryResultGif),
    BotName(BotName),
    Video(Video),
    InputTextMessageContent(InputTextMessageContent),
    InlineQueryResultCachedMpeg4Gif(InlineQueryResultCachedMpeg4Gif),
    InlineQueryResultDocument(InlineQueryResultDocument),
    PassportElementErrorUnspecified(PassportElementErrorUnspecified),
    InlineQueryResultCachedAudio(InlineQueryResultCachedAudio),
    VideoChatEnded(VideoChatEnded),
    InlineQueryResultVoice(InlineQueryResultVoice),
    ResponseParameters(ResponseParameters),
    EncryptedPassportElement(EncryptedPassportElement),
    PhotoSize(PhotoSize),
    InlineQueryResultCachedVideo(InlineQueryResultCachedVideo),
    Voice(Voice),
    Game(Game),
    InlineQueryResultPhoto(InlineQueryResultPhoto),
    InlineQueryResultLocation(InlineQueryResultLocation),
    InputMessageContent(InputMessageContent),
    ChatMemberOwner(ChatMemberOwner),
    Story(Story),
    MenuButton(MenuButton),
    User(User),
    InlineQueryResultAudio(InlineQueryResultAudio),
    ChatInviteLink(ChatInviteLink),
    MessageAutoDeleteTimerChanged(MessageAutoDeleteTimerChanged),
    InlineQueryResultCachedGif(InlineQueryResultCachedGif),
    LabeledPrice(LabeledPrice),
    PollAnswer(PollAnswer),
    Invoice(Invoice),
    PassportElementErrorReverseSide(PassportElementErrorReverseSide),
    ReplyKeyboardRemove(ReplyKeyboardRemove),
    KeyboardButtonRequestChat(KeyboardButtonRequestChat),
    KeyboardButtonRequestUser(KeyboardButtonRequestUser),
    BotCommandScopeAllGroupChats(BotCommandScopeAllGroupChats),
    BotCommandScopeChatMember(BotCommandScopeChatMember),
}
impl Default for GlobalTypes {
    fn default() -> Self {
        GlobalTypes::LoginUrl(LoginUrl::default())
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum EChatId {
    I64(i64),
    String(String),
}
impl Default for EChatId {
    fn default() -> Self {
        EChatId::I64(i64::default())
    }
}
impl fmt::Display for EChatId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let v = match self {
            EChatId::I64(thing) => {
                serde_json::to_string(thing).unwrap_or_else(|err| format!("invalid: {err}"))
            }
            EChatId::String(thing) => {
                serde_json::to_string(thing).unwrap_or_else(|err| format!("invalid: {err}"))
            }
        };
        write!(f, "{}", v)?;
        Ok(())
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum EReplyMarkup {
    InlineKeyboardMarkup(InlineKeyboardMarkup),
    ReplyKeyboardMarkup(ReplyKeyboardMarkup),
    ReplyKeyboardRemove(ReplyKeyboardRemove),
    ForceReply(ForceReply),
}
impl Default for EReplyMarkup {
    fn default() -> Self {
        EReplyMarkup::InlineKeyboardMarkup(InlineKeyboardMarkup::default())
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum EMedia {
    InputMediaAudio(InputMediaAudio),
    InputMediaDocument(InputMediaDocument),
    InputMediaPhoto(InputMediaPhoto),
    InputMediaVideo(InputMediaVideo),
}
impl Default for EMedia {
    fn default() -> Self {
        EMedia::InputMediaAudio(InputMediaAudio::default())
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(untagged)]
pub enum MessageBool {
    Message(Message),
    Bool(bool),
}
impl Default for MessageBool {
    fn default() -> Self {
        MessageBool::Message(Message::default())
    }
}
impl fmt::Display for MessageBool {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let v = match self {
            MessageBool::Message(thing) => {
                serde_json::to_string(thing).unwrap_or_else(|err| format!("invalid: {err}"))
            }
            MessageBool::Bool(thing) => {
                serde_json::to_string(thing).unwrap_or_else(|err| format!("invalid: {err}"))
            }
        };
        write!(f, "{}", v)?;
        Ok(())
    }
}
#[allow(unused_imports)]
mod test {
    use super::*;
    use std::default::Default;
    #[test]
    fn rmp_serialize_named_login_url() {
        let t = LoginUrl::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: LoginUrl = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_login_url() {
        let t = LoginUrl::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: LoginUrl = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_login_url() {
        let t = LoginUrl::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: LoginUrl = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_command_scope_chat() {
        let t = BotCommandScopeChat::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotCommandScopeChat = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_command_scope_chat() {
        let t = BotCommandScopeChat::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotCommandScopeChat = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_command_scope_chat() {
        let t = BotCommandScopeChat::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotCommandScopeChat = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_permissions() {
        let t = ChatPermissions::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatPermissions = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_permissions() {
        let t = ChatPermissions::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatPermissions = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_permissions() {
        let t = ChatPermissions::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatPermissions = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_audio() {
        let t = Audio::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Audio = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_audio() {
        let t = Audio::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Audio = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_audio() {
        let t = Audio::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Audio = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_contact_message_content() {
        let t = InputContactMessageContent::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputContactMessageContent = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_contact_message_content() {
        let t = InputContactMessageContent::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputContactMessageContent = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_contact_message_content() {
        let t = InputContactMessageContent::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputContactMessageContent = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_media_photo() {
        let t = InputMediaPhoto::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputMediaPhoto = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_media_photo() {
        let t = InputMediaPhoto::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputMediaPhoto = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_media_photo() {
        let t = InputMediaPhoto::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputMediaPhoto = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_order_info() {
        let t = OrderInfo::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: OrderInfo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_order_info() {
        let t = OrderInfo::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: OrderInfo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_order_info() {
        let t = OrderInfo::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: OrderInfo = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_forum_topic() {
        let t = ForumTopic::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ForumTopic = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_forum_topic() {
        let t = ForumTopic::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ForumTopic = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_forum_topic() {
        let t = ForumTopic::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ForumTopic = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_write_access_allowed() {
        let t = WriteAccessAllowed::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: WriteAccessAllowed = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_write_access_allowed() {
        let t = WriteAccessAllowed::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: WriteAccessAllowed = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_write_access_allowed() {
        let t = WriteAccessAllowed::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: WriteAccessAllowed = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_media_audio() {
        let t = InputMediaAudio::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputMediaAudio = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_media_audio() {
        let t = InputMediaAudio::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputMediaAudio = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_media_audio() {
        let t = InputMediaAudio::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputMediaAudio = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chosen_inline_result() {
        let t = ChosenInlineResult::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChosenInlineResult = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chosen_inline_result() {
        let t = ChosenInlineResult::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChosenInlineResult = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chosen_inline_result() {
        let t = ChosenInlineResult::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChosenInlineResult = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_callback_query() {
        let t = CallbackQuery::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: CallbackQuery = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_callback_query() {
        let t = CallbackQuery::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: CallbackQuery = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_callback_query() {
        let t = CallbackQuery::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: CallbackQuery = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat() {
        let t = Chat::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Chat = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat() {
        let t = Chat::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Chat = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat() {
        let t = Chat::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Chat = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_member_updated() {
        let t = ChatMemberUpdated::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatMemberUpdated = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_member_updated() {
        let t = ChatMemberUpdated::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatMemberUpdated = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_member_updated() {
        let t = ChatMemberUpdated::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatMemberUpdated = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_description() {
        let t = BotDescription::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotDescription = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_description() {
        let t = BotDescription::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotDescription = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_description() {
        let t = BotDescription::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotDescription = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_location_message_content() {
        let t = InputLocationMessageContent::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputLocationMessageContent = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_location_message_content() {
        let t = InputLocationMessageContent::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputLocationMessageContent = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_location_message_content() {
        let t = InputLocationMessageContent::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputLocationMessageContent = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_reply_keyboard_markup() {
        let t = ReplyKeyboardMarkup::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ReplyKeyboardMarkup = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_reply_keyboard_markup() {
        let t = ReplyKeyboardMarkup::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ReplyKeyboardMarkup = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_reply_keyboard_markup() {
        let t = ReplyKeyboardMarkup::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ReplyKeyboardMarkup = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_message_id() {
        let t = MessageId::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: MessageId = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_message_id() {
        let t = MessageId::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: MessageId = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_message_id() {
        let t = MessageId::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: MessageId = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_poll_option() {
        let t = PollOption::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PollOption = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_poll_option() {
        let t = PollOption::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PollOption = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_poll_option() {
        let t = PollOption::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PollOption = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_short_description() {
        let t = BotShortDescription::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotShortDescription = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_short_description() {
        let t = BotShortDescription::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotShortDescription = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_short_description() {
        let t = BotShortDescription::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotShortDescription = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_media_video() {
        let t = InputMediaVideo::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputMediaVideo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_media_video() {
        let t = InputMediaVideo::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputMediaVideo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_media_video() {
        let t = InputMediaVideo::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputMediaVideo = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_element_error_front_side() {
        let t = PassportElementErrorFrontSide::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportElementErrorFrontSide = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_element_error_front_side() {
        let t = PassportElementErrorFrontSide::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportElementErrorFrontSide = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_element_error_front_side() {
        let t = PassportElementErrorFrontSide::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportElementErrorFrontSide = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_menu_button_default() {
        let t = MenuButtonDefault::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: MenuButtonDefault = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_menu_button_default() {
        let t = MenuButtonDefault::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: MenuButtonDefault = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_menu_button_default() {
        let t = MenuButtonDefault::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: MenuButtonDefault = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_encrypted_credentials() {
        let t = EncryptedCredentials::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: EncryptedCredentials = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_encrypted_credentials() {
        let t = EncryptedCredentials::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: EncryptedCredentials = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_encrypted_credentials() {
        let t = EncryptedCredentials::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: EncryptedCredentials = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_element_error_file() {
        let t = PassportElementErrorFile::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportElementErrorFile = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_element_error_file() {
        let t = PassportElementErrorFile::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportElementErrorFile = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_element_error_file() {
        let t = PassportElementErrorFile::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportElementErrorFile = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_game_high_score() {
        let t = GameHighScore::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: GameHighScore = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_game_high_score() {
        let t = GameHighScore::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: GameHighScore = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_game_high_score() {
        let t = GameHighScore::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: GameHighScore = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_shipping_query() {
        let t = ShippingQuery::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ShippingQuery = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_shipping_query() {
        let t = ShippingQuery::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ShippingQuery = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_shipping_query() {
        let t = ShippingQuery::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ShippingQuery = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_video() {
        let t = InlineQueryResultVideo::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultVideo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_video() {
        let t = InlineQueryResultVideo::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultVideo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_video() {
        let t = InlineQueryResultVideo::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultVideo = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_switch_inline_query_chosen_chat() {
        let t = SwitchInlineQueryChosenChat::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: SwitchInlineQueryChosenChat = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_switch_inline_query_chosen_chat() {
        let t = SwitchInlineQueryChosenChat::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: SwitchInlineQueryChosenChat = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_switch_inline_query_chosen_chat() {
        let t = SwitchInlineQueryChosenChat::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: SwitchInlineQueryChosenChat = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_document() {
        let t = Document::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Document = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_document() {
        let t = Document::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Document = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_document() {
        let t = Document::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Document = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_element_error_translation_files() {
        let t = PassportElementErrorTranslationFiles::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportElementErrorTranslationFiles =
            rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_element_error_translation_files() {
        let t = PassportElementErrorTranslationFiles::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportElementErrorTranslationFiles =
            rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_element_error_translation_files() {
        let t = PassportElementErrorTranslationFiles::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportElementErrorTranslationFiles = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_message_entity() {
        let t = MessageEntity::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: MessageEntity = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_message_entity() {
        let t = MessageEntity::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: MessageEntity = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_message_entity() {
        let t = MessageEntity::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: MessageEntity = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_member_administrator() {
        let t = ChatMemberAdministrator::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatMemberAdministrator = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_member_administrator() {
        let t = ChatMemberAdministrator::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatMemberAdministrator = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_member_administrator() {
        let t = ChatMemberAdministrator::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatMemberAdministrator = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_venue() {
        let t = InlineQueryResultVenue::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultVenue = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_venue() {
        let t = InlineQueryResultVenue::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultVenue = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_venue() {
        let t = InlineQueryResultVenue::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultVenue = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_contact() {
        let t = Contact::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Contact = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_contact() {
        let t = Contact::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Contact = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_contact() {
        let t = Contact::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Contact = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_game() {
        let t = InlineQueryResultGame::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultGame = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_game() {
        let t = InlineQueryResultGame::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultGame = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_game() {
        let t = InlineQueryResultGame::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultGame = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_command_scope_all_private_chats() {
        let t = BotCommandScopeAllPrivateChats::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotCommandScopeAllPrivateChats = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_command_scope_all_private_chats() {
        let t = BotCommandScopeAllPrivateChats::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotCommandScopeAllPrivateChats = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_command_scope_all_private_chats() {
        let t = BotCommandScopeAllPrivateChats::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotCommandScopeAllPrivateChats = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_user_profile_photos() {
        let t = UserProfilePhotos::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: UserProfilePhotos = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_user_profile_photos() {
        let t = UserProfilePhotos::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: UserProfilePhotos = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_user_profile_photos() {
        let t = UserProfilePhotos::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: UserProfilePhotos = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_results_button() {
        let t = InlineQueryResultsButton::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultsButton = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_results_button() {
        let t = InlineQueryResultsButton::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultsButton = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_results_button() {
        let t = InlineQueryResultsButton::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultsButton = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_message() {
        let t = Message::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Message = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_message() {
        let t = Message::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Message = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_message() {
        let t = Message::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Message = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_pre_checkout_query() {
        let t = PreCheckoutQuery::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PreCheckoutQuery = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_pre_checkout_query() {
        let t = PreCheckoutQuery::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PreCheckoutQuery = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_pre_checkout_query() {
        let t = PreCheckoutQuery::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PreCheckoutQuery = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_forum_topic_edited() {
        let t = ForumTopicEdited::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ForumTopicEdited = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_forum_topic_edited() {
        let t = ForumTopicEdited::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ForumTopicEdited = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_forum_topic_edited() {
        let t = ForumTopicEdited::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ForumTopicEdited = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_file() {
        let t = File::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: File = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_file() {
        let t = File::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: File = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_file() {
        let t = File::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: File = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_poll() {
        let t = Poll::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Poll = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_poll() {
        let t = Poll::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Poll = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_poll() {
        let t = Poll::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Poll = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_cached_voice() {
        let t = InlineQueryResultCachedVoice::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultCachedVoice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_cached_voice() {
        let t = InlineQueryResultCachedVoice::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultCachedVoice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_cached_voice() {
        let t = InlineQueryResultCachedVoice::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultCachedVoice = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_successful_payment() {
        let t = SuccessfulPayment::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: SuccessfulPayment = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_successful_payment() {
        let t = SuccessfulPayment::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: SuccessfulPayment = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_successful_payment() {
        let t = SuccessfulPayment::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: SuccessfulPayment = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_media_document() {
        let t = InputMediaDocument::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputMediaDocument = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_media_document() {
        let t = InputMediaDocument::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputMediaDocument = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_media_document() {
        let t = InputMediaDocument::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputMediaDocument = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_location() {
        let t = Location::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Location = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_location() {
        let t = Location::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Location = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_location() {
        let t = Location::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Location = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_keyboard_button() {
        let t = KeyboardButton::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: KeyboardButton = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_keyboard_button() {
        let t = KeyboardButton::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: KeyboardButton = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_keyboard_button() {
        let t = KeyboardButton::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: KeyboardButton = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_member_left() {
        let t = ChatMemberLeft::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatMemberLeft = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_member_left() {
        let t = ChatMemberLeft::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatMemberLeft = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_member_left() {
        let t = ChatMemberLeft::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatMemberLeft = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_command() {
        let t = BotCommand::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotCommand = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_command() {
        let t = BotCommand::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotCommand = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_command() {
        let t = BotCommand::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotCommand = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_venue() {
        let t = Venue::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Venue = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_venue() {
        let t = Venue::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Venue = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_venue() {
        let t = Venue::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Venue = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_element_error_selfie() {
        let t = PassportElementErrorSelfie::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportElementErrorSelfie = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_element_error_selfie() {
        let t = PassportElementErrorSelfie::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportElementErrorSelfie = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_element_error_selfie() {
        let t = PassportElementErrorSelfie::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportElementErrorSelfie = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_video_note() {
        let t = VideoNote::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: VideoNote = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_video_note() {
        let t = VideoNote::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: VideoNote = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_video_note() {
        let t = VideoNote::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: VideoNote = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_keyboard_markup() {
        let t = InlineKeyboardMarkup::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineKeyboardMarkup = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_keyboard_markup() {
        let t = InlineKeyboardMarkup::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineKeyboardMarkup = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_keyboard_markup() {
        let t = InlineKeyboardMarkup::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineKeyboardMarkup = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_proximity_alert_triggered() {
        let t = ProximityAlertTriggered::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ProximityAlertTriggered = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_proximity_alert_triggered() {
        let t = ProximityAlertTriggered::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ProximityAlertTriggered = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_proximity_alert_triggered() {
        let t = ProximityAlertTriggered::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ProximityAlertTriggered = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_forum_topic_created() {
        let t = ForumTopicCreated::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ForumTopicCreated = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_forum_topic_created() {
        let t = ForumTopicCreated::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ForumTopicCreated = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_forum_topic_created() {
        let t = ForumTopicCreated::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ForumTopicCreated = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_sticker() {
        let t = Sticker::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Sticker = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_sticker() {
        let t = Sticker::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Sticker = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_sticker() {
        let t = Sticker::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Sticker = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_contact() {
        let t = InlineQueryResultContact::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultContact = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_contact() {
        let t = InlineQueryResultContact::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultContact = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_contact() {
        let t = InlineQueryResultContact::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultContact = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_mask_position() {
        let t = MaskPosition::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: MaskPosition = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_mask_position() {
        let t = MaskPosition::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: MaskPosition = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_mask_position() {
        let t = MaskPosition::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: MaskPosition = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_user_shared() {
        let t = UserShared::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: UserShared = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_user_shared() {
        let t = UserShared::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: UserShared = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_user_shared() {
        let t = UserShared::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: UserShared = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_command_scope_all_chat_administrators() {
        let t = BotCommandScopeAllChatAdministrators::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotCommandScopeAllChatAdministrators =
            rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_command_scope_all_chat_administrators() {
        let t = BotCommandScopeAllChatAdministrators::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotCommandScopeAllChatAdministrators =
            rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_command_scope_all_chat_administrators() {
        let t = BotCommandScopeAllChatAdministrators::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotCommandScopeAllChatAdministrators = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_media_animation() {
        let t = InputMediaAnimation::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputMediaAnimation = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_media_animation() {
        let t = InputMediaAnimation::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputMediaAnimation = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_media_animation() {
        let t = InputMediaAnimation::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputMediaAnimation = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_keyboard_button_poll_type() {
        let t = KeyboardButtonPollType::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: KeyboardButtonPollType = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_keyboard_button_poll_type() {
        let t = KeyboardButtonPollType::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: KeyboardButtonPollType = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_keyboard_button_poll_type() {
        let t = KeyboardButtonPollType::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: KeyboardButtonPollType = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_join_request() {
        let t = ChatJoinRequest::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatJoinRequest = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_join_request() {
        let t = ChatJoinRequest::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatJoinRequest = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_join_request() {
        let t = ChatJoinRequest::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatJoinRequest = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_cached_document() {
        let t = InlineQueryResultCachedDocument::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultCachedDocument = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_cached_document() {
        let t = InlineQueryResultCachedDocument::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultCachedDocument = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_cached_document() {
        let t = InlineQueryResultCachedDocument::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultCachedDocument = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_administrator_rights() {
        let t = ChatAdministratorRights::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatAdministratorRights = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_administrator_rights() {
        let t = ChatAdministratorRights::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatAdministratorRights = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_administrator_rights() {
        let t = ChatAdministratorRights::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatAdministratorRights = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_webhook_info() {
        let t = WebhookInfo::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: WebhookInfo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_webhook_info() {
        let t = WebhookInfo::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: WebhookInfo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_webhook_info() {
        let t = WebhookInfo::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: WebhookInfo = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_web_app_data() {
        let t = WebAppData::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: WebAppData = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_web_app_data() {
        let t = WebAppData::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: WebAppData = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_web_app_data() {
        let t = WebAppData::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: WebAppData = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query() {
        let t = InlineQuery::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQuery = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query() {
        let t = InlineQuery::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQuery = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query() {
        let t = InlineQuery::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQuery = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_file() {
        let t = PassportFile::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportFile = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_file() {
        let t = PassportFile::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportFile = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_file() {
        let t = PassportFile::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportFile = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_cached_sticker() {
        let t = InlineQueryResultCachedSticker::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultCachedSticker = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_cached_sticker() {
        let t = InlineQueryResultCachedSticker::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultCachedSticker = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_cached_sticker() {
        let t = InlineQueryResultCachedSticker::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultCachedSticker = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_animation() {
        let t = Animation::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Animation = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_animation() {
        let t = Animation::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Animation = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_animation() {
        let t = Animation::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Animation = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_photo() {
        let t = ChatPhoto::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatPhoto = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_photo() {
        let t = ChatPhoto::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatPhoto = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_photo() {
        let t = ChatPhoto::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatPhoto = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_sticker_set() {
        let t = StickerSet::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: StickerSet = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_sticker_set() {
        let t = StickerSet::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: StickerSet = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_sticker_set() {
        let t = StickerSet::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: StickerSet = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_venue_message_content() {
        let t = InputVenueMessageContent::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputVenueMessageContent = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_venue_message_content() {
        let t = InputVenueMessageContent::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputVenueMessageContent = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_venue_message_content() {
        let t = InputVenueMessageContent::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputVenueMessageContent = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_element_error_files() {
        let t = PassportElementErrorFiles::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportElementErrorFiles = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_element_error_files() {
        let t = PassportElementErrorFiles::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportElementErrorFiles = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_element_error_files() {
        let t = PassportElementErrorFiles::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportElementErrorFiles = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_command_scope_chat_administrators() {
        let t = BotCommandScopeChatAdministrators::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotCommandScopeChatAdministrators = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_command_scope_chat_administrators() {
        let t = BotCommandScopeChatAdministrators::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotCommandScopeChatAdministrators = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_command_scope_chat_administrators() {
        let t = BotCommandScopeChatAdministrators::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotCommandScopeChatAdministrators = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_cached_photo() {
        let t = InlineQueryResultCachedPhoto::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultCachedPhoto = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_cached_photo() {
        let t = InlineQueryResultCachedPhoto::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultCachedPhoto = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_cached_photo() {
        let t = InlineQueryResultCachedPhoto::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultCachedPhoto = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_invoice_message_content() {
        let t = InputInvoiceMessageContent::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputInvoiceMessageContent = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_invoice_message_content() {
        let t = InputInvoiceMessageContent::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputInvoiceMessageContent = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_invoice_message_content() {
        let t = InputInvoiceMessageContent::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputInvoiceMessageContent = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_member_member() {
        let t = ChatMemberMember::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatMemberMember = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_member_member() {
        let t = ChatMemberMember::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatMemberMember = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_member_member() {
        let t = ChatMemberMember::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatMemberMember = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_force_reply() {
        let t = ForceReply::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ForceReply = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_force_reply() {
        let t = ForceReply::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ForceReply = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_force_reply() {
        let t = ForceReply::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ForceReply = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_menu_button_web_app() {
        let t = MenuButtonWebApp::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: MenuButtonWebApp = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_menu_button_web_app() {
        let t = MenuButtonWebApp::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: MenuButtonWebApp = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_menu_button_web_app() {
        let t = MenuButtonWebApp::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: MenuButtonWebApp = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_update() {
        let t = Update::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Update = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_update() {
        let t = Update::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Update = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_update() {
        let t = Update::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Update = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_menu_button_commands() {
        let t = MenuButtonCommands::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: MenuButtonCommands = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_menu_button_commands() {
        let t = MenuButtonCommands::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: MenuButtonCommands = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_menu_button_commands() {
        let t = MenuButtonCommands::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: MenuButtonCommands = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_member_restricted() {
        let t = ChatMemberRestricted::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatMemberRestricted = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_member_restricted() {
        let t = ChatMemberRestricted::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatMemberRestricted = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_member_restricted() {
        let t = ChatMemberRestricted::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatMemberRestricted = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_article() {
        let t = InlineQueryResultArticle::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultArticle = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_article() {
        let t = InlineQueryResultArticle::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultArticle = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_article() {
        let t = InlineQueryResultArticle::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultArticle = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_sent_web_app_message() {
        let t = SentWebAppMessage::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: SentWebAppMessage = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_sent_web_app_message() {
        let t = SentWebAppMessage::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: SentWebAppMessage = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_sent_web_app_message() {
        let t = SentWebAppMessage::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: SentWebAppMessage = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_video_chat_participants_invited() {
        let t = VideoChatParticipantsInvited::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: VideoChatParticipantsInvited = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_video_chat_participants_invited() {
        let t = VideoChatParticipantsInvited::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: VideoChatParticipantsInvited = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_video_chat_participants_invited() {
        let t = VideoChatParticipantsInvited::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: VideoChatParticipantsInvited = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_keyboard_button() {
        let t = InlineKeyboardButton::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineKeyboardButton = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_keyboard_button() {
        let t = InlineKeyboardButton::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineKeyboardButton = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_keyboard_button() {
        let t = InlineKeyboardButton::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineKeyboardButton = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_shared() {
        let t = ChatShared::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatShared = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_shared() {
        let t = ChatShared::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatShared = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_shared() {
        let t = ChatShared::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatShared = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_mpeg_4_gif() {
        let t = InlineQueryResultMpeg4Gif::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultMpeg4Gif = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_mpeg_4_gif() {
        let t = InlineQueryResultMpeg4Gif::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultMpeg4Gif = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_mpeg_4_gif() {
        let t = InlineQueryResultMpeg4Gif::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultMpeg4Gif = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_shipping_address() {
        let t = ShippingAddress::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ShippingAddress = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_shipping_address() {
        let t = ShippingAddress::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ShippingAddress = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_shipping_address() {
        let t = ShippingAddress::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ShippingAddress = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_element_error_data_field() {
        let t = PassportElementErrorDataField::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportElementErrorDataField = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_element_error_data_field() {
        let t = PassportElementErrorDataField::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportElementErrorDataField = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_element_error_data_field() {
        let t = PassportElementErrorDataField::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportElementErrorDataField = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_dice() {
        let t = Dice::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Dice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_dice() {
        let t = Dice::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Dice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_dice() {
        let t = Dice::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Dice = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_element_error_translation_file() {
        let t = PassportElementErrorTranslationFile::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportElementErrorTranslationFile = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_element_error_translation_file() {
        let t = PassportElementErrorTranslationFile::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportElementErrorTranslationFile = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_element_error_translation_file() {
        let t = PassportElementErrorTranslationFile::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportElementErrorTranslationFile = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_video_chat_scheduled() {
        let t = VideoChatScheduled::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: VideoChatScheduled = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_video_chat_scheduled() {
        let t = VideoChatScheduled::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: VideoChatScheduled = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_video_chat_scheduled() {
        let t = VideoChatScheduled::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: VideoChatScheduled = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_shipping_option() {
        let t = ShippingOption::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ShippingOption = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_shipping_option() {
        let t = ShippingOption::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ShippingOption = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_shipping_option() {
        let t = ShippingOption::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ShippingOption = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_web_app_info() {
        let t = WebAppInfo::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: WebAppInfo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_web_app_info() {
        let t = WebAppInfo::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: WebAppInfo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_web_app_info() {
        let t = WebAppInfo::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: WebAppInfo = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_member_banned() {
        let t = ChatMemberBanned::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatMemberBanned = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_member_banned() {
        let t = ChatMemberBanned::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatMemberBanned = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_member_banned() {
        let t = ChatMemberBanned::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatMemberBanned = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_command_scope_default() {
        let t = BotCommandScopeDefault::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotCommandScopeDefault = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_command_scope_default() {
        let t = BotCommandScopeDefault::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotCommandScopeDefault = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_command_scope_default() {
        let t = BotCommandScopeDefault::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotCommandScopeDefault = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_data() {
        let t = PassportData::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportData = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_data() {
        let t = PassportData::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportData = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_data() {
        let t = PassportData::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportData = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_sticker() {
        let t = InputSticker::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputSticker = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_sticker() {
        let t = InputSticker::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputSticker = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_sticker() {
        let t = InputSticker::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputSticker = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_location() {
        let t = ChatLocation::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatLocation = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_location() {
        let t = ChatLocation::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatLocation = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_location() {
        let t = ChatLocation::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatLocation = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_gif() {
        let t = InlineQueryResultGif::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultGif = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_gif() {
        let t = InlineQueryResultGif::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultGif = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_gif() {
        let t = InlineQueryResultGif::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultGif = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_name() {
        let t = BotName::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotName = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_name() {
        let t = BotName::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotName = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_name() {
        let t = BotName::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotName = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_video() {
        let t = Video::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Video = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_video() {
        let t = Video::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Video = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_video() {
        let t = Video::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Video = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_input_text_message_content() {
        let t = InputTextMessageContent::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InputTextMessageContent = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_input_text_message_content() {
        let t = InputTextMessageContent::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InputTextMessageContent = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_input_text_message_content() {
        let t = InputTextMessageContent::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InputTextMessageContent = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_cached_mpeg_4_gif() {
        let t = InlineQueryResultCachedMpeg4Gif::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultCachedMpeg4Gif = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_cached_mpeg_4_gif() {
        let t = InlineQueryResultCachedMpeg4Gif::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultCachedMpeg4Gif = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_cached_mpeg_4_gif() {
        let t = InlineQueryResultCachedMpeg4Gif::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultCachedMpeg4Gif = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_document() {
        let t = InlineQueryResultDocument::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultDocument = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_document() {
        let t = InlineQueryResultDocument::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultDocument = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_document() {
        let t = InlineQueryResultDocument::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultDocument = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_element_error_unspecified() {
        let t = PassportElementErrorUnspecified::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportElementErrorUnspecified = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_element_error_unspecified() {
        let t = PassportElementErrorUnspecified::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportElementErrorUnspecified = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_element_error_unspecified() {
        let t = PassportElementErrorUnspecified::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportElementErrorUnspecified = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_cached_audio() {
        let t = InlineQueryResultCachedAudio::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultCachedAudio = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_cached_audio() {
        let t = InlineQueryResultCachedAudio::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultCachedAudio = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_cached_audio() {
        let t = InlineQueryResultCachedAudio::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultCachedAudio = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_video_chat_ended() {
        let t = VideoChatEnded::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: VideoChatEnded = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_video_chat_ended() {
        let t = VideoChatEnded::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: VideoChatEnded = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_video_chat_ended() {
        let t = VideoChatEnded::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: VideoChatEnded = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_voice() {
        let t = InlineQueryResultVoice::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultVoice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_voice() {
        let t = InlineQueryResultVoice::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultVoice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_voice() {
        let t = InlineQueryResultVoice::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultVoice = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_response_parameters() {
        let t = ResponseParameters::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ResponseParameters = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_response_parameters() {
        let t = ResponseParameters::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ResponseParameters = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_response_parameters() {
        let t = ResponseParameters::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ResponseParameters = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_encrypted_passport_element() {
        let t = EncryptedPassportElement::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: EncryptedPassportElement = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_encrypted_passport_element() {
        let t = EncryptedPassportElement::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: EncryptedPassportElement = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_encrypted_passport_element() {
        let t = EncryptedPassportElement::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: EncryptedPassportElement = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_photo_size() {
        let t = PhotoSize::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PhotoSize = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_photo_size() {
        let t = PhotoSize::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PhotoSize = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_photo_size() {
        let t = PhotoSize::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PhotoSize = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_cached_video() {
        let t = InlineQueryResultCachedVideo::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultCachedVideo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_cached_video() {
        let t = InlineQueryResultCachedVideo::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultCachedVideo = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_cached_video() {
        let t = InlineQueryResultCachedVideo::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultCachedVideo = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_voice() {
        let t = Voice::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Voice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_voice() {
        let t = Voice::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Voice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_voice() {
        let t = Voice::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Voice = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_game() {
        let t = Game::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Game = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_game() {
        let t = Game::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Game = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_game() {
        let t = Game::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Game = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_photo() {
        let t = InlineQueryResultPhoto::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultPhoto = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_photo() {
        let t = InlineQueryResultPhoto::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultPhoto = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_photo() {
        let t = InlineQueryResultPhoto::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultPhoto = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_location() {
        let t = InlineQueryResultLocation::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultLocation = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_location() {
        let t = InlineQueryResultLocation::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultLocation = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_location() {
        let t = InlineQueryResultLocation::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultLocation = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_member_owner() {
        let t = ChatMemberOwner::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatMemberOwner = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_member_owner() {
        let t = ChatMemberOwner::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatMemberOwner = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_member_owner() {
        let t = ChatMemberOwner::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatMemberOwner = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_user() {
        let t = User::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: User = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_user() {
        let t = User::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: User = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_user() {
        let t = User::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: User = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_audio() {
        let t = InlineQueryResultAudio::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultAudio = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_audio() {
        let t = InlineQueryResultAudio::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultAudio = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_audio() {
        let t = InlineQueryResultAudio::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultAudio = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_chat_invite_link() {
        let t = ChatInviteLink::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ChatInviteLink = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_chat_invite_link() {
        let t = ChatInviteLink::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ChatInviteLink = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_chat_invite_link() {
        let t = ChatInviteLink::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ChatInviteLink = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_message_auto_delete_timer_changed() {
        let t = MessageAutoDeleteTimerChanged::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: MessageAutoDeleteTimerChanged = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_message_auto_delete_timer_changed() {
        let t = MessageAutoDeleteTimerChanged::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: MessageAutoDeleteTimerChanged = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_message_auto_delete_timer_changed() {
        let t = MessageAutoDeleteTimerChanged::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: MessageAutoDeleteTimerChanged = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_inline_query_result_cached_gif() {
        let t = InlineQueryResultCachedGif::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: InlineQueryResultCachedGif = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_inline_query_result_cached_gif() {
        let t = InlineQueryResultCachedGif::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: InlineQueryResultCachedGif = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_inline_query_result_cached_gif() {
        let t = InlineQueryResultCachedGif::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: InlineQueryResultCachedGif = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_labeled_price() {
        let t = LabeledPrice::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: LabeledPrice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_labeled_price() {
        let t = LabeledPrice::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: LabeledPrice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_labeled_price() {
        let t = LabeledPrice::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: LabeledPrice = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_poll_answer() {
        let t = PollAnswer::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PollAnswer = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_poll_answer() {
        let t = PollAnswer::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PollAnswer = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_poll_answer() {
        let t = PollAnswer::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PollAnswer = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_invoice() {
        let t = Invoice::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: Invoice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_invoice() {
        let t = Invoice::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: Invoice = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_invoice() {
        let t = Invoice::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: Invoice = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_passport_element_error_reverse_side() {
        let t = PassportElementErrorReverseSide::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: PassportElementErrorReverseSide = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_passport_element_error_reverse_side() {
        let t = PassportElementErrorReverseSide::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: PassportElementErrorReverseSide = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_passport_element_error_reverse_side() {
        let t = PassportElementErrorReverseSide::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: PassportElementErrorReverseSide = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_reply_keyboard_remove() {
        let t = ReplyKeyboardRemove::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: ReplyKeyboardRemove = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_reply_keyboard_remove() {
        let t = ReplyKeyboardRemove::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: ReplyKeyboardRemove = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_reply_keyboard_remove() {
        let t = ReplyKeyboardRemove::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: ReplyKeyboardRemove = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_keyboard_button_request_chat() {
        let t = KeyboardButtonRequestChat::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: KeyboardButtonRequestChat = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_keyboard_button_request_chat() {
        let t = KeyboardButtonRequestChat::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: KeyboardButtonRequestChat = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_keyboard_button_request_chat() {
        let t = KeyboardButtonRequestChat::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: KeyboardButtonRequestChat = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_keyboard_button_request_user() {
        let t = KeyboardButtonRequestUser::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: KeyboardButtonRequestUser = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_keyboard_button_request_user() {
        let t = KeyboardButtonRequestUser::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: KeyboardButtonRequestUser = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_keyboard_button_request_user() {
        let t = KeyboardButtonRequestUser::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: KeyboardButtonRequestUser = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_command_scope_all_group_chats() {
        let t = BotCommandScopeAllGroupChats::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotCommandScopeAllGroupChats = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_command_scope_all_group_chats() {
        let t = BotCommandScopeAllGroupChats::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotCommandScopeAllGroupChats = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_command_scope_all_group_chats() {
        let t = BotCommandScopeAllGroupChats::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotCommandScopeAllGroupChats = serde_json::from_str(&ser).unwrap();
    }
    #[test]
    fn rmp_serialize_named_bot_command_scope_chat_member() {
        let t = BotCommandScopeChatMember::default();
        let ser = rmp_serde::to_vec_named(&t).unwrap();
        let _: BotCommandScopeChatMember = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn rmp_serialize_array_bot_command_scope_chat_member() {
        let t = BotCommandScopeChatMember::default();
        let t = t.noskip();
        let ser = rmp_serde::to_vec(&t).unwrap();
        let _: BotCommandScopeChatMember = rmp_serde::from_slice(ser.as_slice()).unwrap();
    }
    #[test]
    fn json_serialize_bot_command_scope_chat_member() {
        let t = BotCommandScopeChatMember::default();
        let ser = serde_json::to_string(&t).unwrap();
        println!("{}", ser);
        let _: BotCommandScopeChatMember = serde_json::from_str(&ser).unwrap();
    }
}
